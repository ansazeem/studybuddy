Chunk Number,Length,Content (First 300 Chars)
1,77,"CRACKING 
��the ��· 
CODING INTERVIEW 
189 PROGRAMMING Q!JESTIONS & SOLUTIONS"
2,44,"CRACKING 
the 
CODING INTERVIEW 
6TH EDITION"
3,219,"ALso BY GAYLE LAAKMANN McDowELL 
(RACKING THE PM INTERVIEW 
How TO LAND A PRODUCT MANAGER JoB IN TECHNOLOGY
CRACKING THE TECH CAREER 
INSIDER ADVICE ON LANDING A JOB AT GOOGLE, MICROSOFT, APP LE, OR ANY TOP TECH COMPANY"
4,173,"CRACKING 
the 
CODING INTERVIEW 
6th Edition 
189 Programming Questions and Solutions 
GAYLE LAAKMANN MCDOWELL 
Founder and CEO, CareerCup.com 
CareerCup, LLC 
Palo Alto, CA"
5,489,"CRACKING THE CODING INTERVIEW, SIXTH EDITION 
Copyright © 2015 by CareerCup. 
All rights reserved. No part of this book may be reproduced in any form by any electronic or me­
chanical means, including information storage and retrieval systems, without permission in writing 
from the author or publis"
6,81,"For more information, contact support@careercup.com. 
978-0-9847828-5-7 (ISBN 13)"
7,67,"For Davis and Tobin, 
and all the things that bring us joy in life."
8,489,"Introduction 
Introduction . ........................... • · • . • · · • • · · • · · · · · · · · · · · · · · · · · 2 
I. The Interview Process ............. ................... · .. · · . · · · · · · · · · 4 
Why? .... · .................................................... ····· 4 
How Questions are"
9,490,"Frequently Asked Questions .............................................. 7 
II. Behind the Scenes . .......... .................................•..... 8 
The Microsof t Interview ................................................. 9 
The Amazon Interview ............... , . . . . . . . . . . . . . . "
10,475,"The Face book Interview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 
The Palantir Interview .................................................. 13 
Ill. Special Situations ................................................. 15 
Experienced Candidat"
11,478,"Product (and Program) Management ....................................... 16 
Dev Lead and Managers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 
Startups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ."
12,505,"IV. Before the Interview ............................................... 26 
Getting the Right Experience ............................................. 26 
Writing a Great Resume . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 
Preparation Map ....."
13,479,"KnowYourTechnical Projects ............................................. 33 
Responding to Behavioral Questions ........................................ 34 
So, tell me about yourself... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 
VI. BigO ........"
14,394,"Time Complexity ..................................................... 38 
Space Complexity. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 
Drop the Constants ................................................... 41 
Drop the Non-Dominant Terms"
15,495,"Introduction 
Multi-Part Algorithms: Add vs. Multiply ......... ....... .......... ........... . 42 
Amortized Time ......... ............. ............ .......... · . . . . . . . . . 43 
Log N Runtimes .................... ..................... ............ 44 
Recursive Runtimes ...... ..........."
16,449,"How to Prepare . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 
What You Need To Know. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 
Walking Through a Problem . . . . . . . . . . . . . . "
17,456,"Optimize & Solve Technique #2: DIY (Do It Yourself) ....... .......... ............. 69 
Optimize & Solve Technique #3: Simplify and Generalize ........... ................ 71 
Optimize & Solve Technique #4: Base Cas e and Build ........... ................... 71 
Optimize & Solve Technique #5: Data"
18,477,"Handling Incorrect Answers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 
When You've Heard a Question Before. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 
The ""Perfect"" Language for Interview s . . . . . . . . . . . ."
19,401,"Don't Give Up! .................... .......... ........................ 81 
VIII. The Offer and Beyond ....................... ....................... 82 
Handling Offers and Rejection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82 
Evaluating the Offer. ."
20,403,"Negotiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 
On the Job . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85 
IX. Interview Questions .............. ......"
21,485,"Chapter 1 I Arrays and Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88 
Hash Tables . .......................................................... 88 
ArrayList & Resizable Arrays . ............................................... 89 
StringBuilder . ."
22,371,"Creating a Linked List .................................................... 92 
Deleting a Node from a Singly Linked List . ...................................... 93 
The ""Runner""Technique .................................................. 93 
Recursive Problems . ..................................."
23,452,"Introduction 
Chapter 3 J Stacks and Queues. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96 
Implementing a Stock . ................................................... 96 
Implementing a Queue . .................................................. 97 
Chapter "
24,494,"Binary Tree Traversal. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 
Binary Heaps (Min-Heaps and Mox-Heaps) .................................... 103 
Tries (Prefix Trees). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ."
25,443,"Concepts and Algorithms ........................................... 112 
Chapter 5 \ Bit Manipulation ........... ............. ...... ............... 112 
Bit Manipulation By Hand . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 
Bit Facts and Tric"
26,420,"Arithmetic vs. Logical Right Shift . .......................... � ................ 113 
Common Bit Tasks: Getting and Setting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114 
Chapter 6 \ Math and Logic Puzzles ............ ........... .................. 117 
Prime N"
27,474,"Probability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119 
Start Talking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121 
Develop Rules and Patterns . ....."
28,465,"Algorithm Approaches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122 
Chapter 7 \ Object-Oriented Design ........... ............................. 125 
How to Approach. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ."
29,506,"Chapter 8 \ Recursion and Dynamic Programming .......... ..................... 130 
How to Approach. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 30 
Recursive vs. Iterative Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . ."
30,364,"Handling the Questions ................................................. 137 
Design: Step-By-Step ................................................... 138 
Algorithms that Scale: Step-By-Step ......................................... 139 
Key Concepts . .............................................."
31,455,"Introduction 
Considerations ....................................................... 142 
There is no ""perfect"" system ................................................ 143 
Example Problem ...................................................... 143 
Chapter 10 j Sorting and Searching ................"
32,408,"Searching Algorithms . .........•........................................ 149 
Chapter11 ITesting ....... ......... .............. ..... ...... .......... 152 
What the Interviewer Is Looking For . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152 
Testing a Real Wo"
33,425,"Testing a Piece of Software . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154 
Testing a Function ..................................................... 155 
Troubleshooting Questions ............................................... 156 
Knowledge Based "
34,468,"Classes and Inheritance. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158 
Constructors and Destructors .............................................. 159 
Virtual Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ."
35,458,"Default Values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161 
Operator Overloading. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161 
Pointers and References . . . . . . . . . "
36,446,"Chapter 13 I Java ................. .................. ...... ............ 165 
How to Approach. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165 
Overloading vs. Overriding ............................................... 165 
Collection F"
37,446,"SQL Syntax and Variations ................................................ 169 
Denormalized vs. Normalized Databases ...................................... 169 
SQL Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169 
Small Dat"
38,410,"Chapter 15 j Threads and Locks ........................................... 174 
Threads in Java ....................................................... 174 
Synchronization and Locks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176 
Deadlocks and Dead"
39,474,"Introduction 
Additional Review Problems ..•...................................... 181 
Chapter 16 j Moderate ................. · ................................ 181 
Chapter 17 j Hard .................................................... 186 
X. Solutions ...... .......................•......•....."
40,455,"Knowledge Based .................................................... 422 
Additional Review Problems ............................................. 462 
XI. Advanced Topics . ................. ...........•..•.........•...... 628 
Useful Math ........................................................ 62"
41,455,"Hash Table Collision Resolution ........................................... 636 
Rabin-Karp Substring Search ............................................. 636 
AVL Trees ......................................................... 637 
Red-Black Trees ..................................................."
42,460,"XII. Code Library ..... .............................................. 645 
HashMapList<T, E> ................................................... 646 
TreeNode (Binary 
Search Tree) ............................................ 647 
LinkedListNode (Linked List) ......................................."
43,485,"Hints for Data Structures ................................................ 653 
Hints for Concepts and Alg_orithms ......................................... 662 
Hints for Knowledge-Based Questions ....................................... 676 
Hints for Additional Review 
Problems ..................."
44,242,"contribute or view solutions in other programming languages, discuss problems from this book 
with other readers, ask questions, report issues, view this book's errata, and seek additional advice. 
X Cracking the Coding Interview, 6th Edition"
45,490,"Foreword 
Dear Reader, 
Let's get the introductions out of the way.
I am not a recruiter. I am a software engineer. And as such, I know what it's like to be asked to whip up bril­
liant algorithms on the spot and then write flawless code on a whiteboard. I know because I've been asked 
to do the sam"
46,480,"through stacks of resumes to find the engineers who I thought might be able to actually pass these inter­
views. I've evaluated them as they solved-or tried to solve-challenging questions. And I've debated in 
Google's Hiring Committee whether a candidate did well enough to merit an offer. I underst"
47,475,"here to help you solidify your understanding of computer science fundamentals and then learn how to 
apply those fundamentals to crack the coding interview. 
The 6th edition of Cracking the Coding Interview updates the 5th edition with 70% more content: additional 
questions, revised solutions, new "
48,428,"other candidates and discover new resources. 
I'm excited for you and for the skills you are going to develop. Thorough preparation will give you a wide 
range of technical and communication skills. It will be well worth it, no matter where the effort takes you! 
I encourage you to read these introd"
49,485,"might make the difference between a ""hire"" and a ""no hire:' 
And remember-interviews are hard! In my years of interviewing at Google, I saw some interviewers 
ask ""easy"" questions while others ask harder questions. But you know what? Getting the easy questions 
doesn't make it any easier to get the "
50,306,"when you get a tricky question-everyone else probably thought it was hard too. It's okay to not be flaw­
less. 
Study hard, practice-and good luck! 
Gayle L. McDowell 
Founder/CEO, CareerCup.com 
Author of Cracking the PM Interview and Cracking the Tech Career 
CrackingTheCodinglnterview.com J 6th E"
51,510,"Introduction 
Something's Wrong 
We walked out of the hiring meeting frustrated-again. Of the ten candidates we reviewed that day, none 
would receive offers. Were we being too harsh, we wondered? 
I, in particular, was disappointed. We had rejected one of my candidates. A former student. One I had "
52,424,"was sharp. He worked hard. He was a true geek in all the best ways. 
But I had to agree with the rest of the committee: the data wasn't there. Even if my emphatic recommenda­
tion could sway them to reconsider, he would surely get rejected in the later stages of the hiring process. 
There were just "
53,476,"dates could fly through the first question, which was a twist on a well-known problem, but he had trouble 
developing an algorithm. When he came up with one, he failed to consider solutions that optimized for 
other scenarios. Finally, when he began coding, he flew through the code with an initial s"
54,488,"measure, he was far from meeting the ""bar:' Rejected. 
When he asked for feedback over the phone a couple of weeks later, I struggled with what to tell him. Be 
smarter? No, I knew he was brilliant. Be a better coder? No, his skills were on par with some of the best I'd 
seen. 
Like many motivated c"
55,412,"tree, and he could do things in C that no sane programmer should ever want to do. 
I had to tell him the unfortunate truth: those books aren't enough. Academic books prepare you for fancy 
research, and they will probably make you a better software engineer, but they're not sufficient for inter­
vie"
56,446,"either. 
To crack the coding interview, you need to prepare with real interview questions. You must practice on 
real problems and learn their patterns. It's about developing a fresh algorithm, not memorizing existing 
problems. 
Cracking the Coding Interview is the result of my first-hand experienc"
57,508,"dates. It is the result of the thousands of questions contributed by candidates and interviewers. And it's the 
result of seeing so many interview questions from so many firms. Enclosed in this book are 189 of the best 
interview questions, selected from thousands of potential problems. 
My Approach"
58,413,"wise, while many firms will ask so-called ""trivia"" questions (e.g., ""What is a virtual function?""), the skills devel­
oped through practicing these questions are limited to very specific bits of knowledge. The book will briefly 
touch on some of these questions to show you what they're like, but I h"
59,486,"Introduction 
My Passion 
Teaching is my passion. I love helping people understand new concepts and giving them tools to help them 
excel in their passions. 
My first official experience teaching was in college at the University of Pennsylvania, when I became a 
teaching assistant for an undergradua"
60,506,"hands-on skills. 
As an engineer at Google, training and mentoring new engineers were some of the things I enjoyed most. I 
even used my""20% time""to teach two computer science courses at the University of Washington. 
Now, years later, I continue to teach computer science concepts, but this time wit"
61,315,"Cracking the Coding Interview, Cracking the PM Interview, Cracking the Tech Career, and CareerCup 
reflect my passion for teaching. Even now, you can often find me ""hanging out"" at CareerCup.com, helping 
users who stop by for assistance. 
Join us. 
Gayle L. McDowell 
CrackingTheCodinglnterview.com "
62,433,"I 
The Interview Process 
At most of the top tech companies (and many other companies). algorithm and coding problems form the 
largest component of the interview process. Think of these as problem-solving questions. The interviewer 
is looking to evaluate your ability to solve algorithmic problems "
63,475,"and it's difficult to get through several different questions in that time frame. 
You should do your best to talk out loud throughout the problem and explain your thought process. Your 
interviewer might jump in sometimes to help you; let them. It's normal and doesn't really mean that you're 
doing"
64,504,"might be assigned to your performance, but it's not actually a quantitative assessment. There's no chart that 
says how many points you get for different things. It just doesn't work like that. 
Rather, your interviewer will make an assessment of your performance, usually based on the following: 
An"
65,506,"ture the problem well and think through the tradeoffs of different decisions? 
Coding skills: Were you able to successfully translate your algorithm to reasonable code? Was it clean 
and well-organized? Did you think about potential errors? Did you use good style? 
Technical knowledge/ Computer Scie"
66,419,"projects? Have you shown drive, initiative, and other important factors? 
Culture fit/ Communication skills: Do your personality and values fit with the company and team? Did 
you communicate well with your interviewer? 
The weighting of these areas will vary based on the question, interviewer, role"
67,260,".- Why? 
This is one of the most common questions candidates have as they get started with this process. Why do 
things this way? After all, 
1. Lots of great candidates 
don't do well in these sorts of interviews.
4 Cracking the Coding Interview, 
6th Edition"
68,428,"I I The Interview Process
2. You could look up the answer if it did ever come up.
3. You rarely have to use data structures such as binary search trees in the real world. If you did need to,
you could surely learn it.
4. Whiteboard coding is an artificial environment. You would never code on the whi"
69,465,"At the same time, there is reason to do things this way for some-not all-positions. It's not important that 
you agree with this logic, but it is a good idea to understand why these questions are being asked. It helps 
offer a little insight into the interviewer's mindset. 
False negatives are accep"
70,419,"company is out to build a great set of employees. They can accept that they miss out on some good people. 
They'd prefer not to, of course, as it raises their recruiting costs. It is an acceptable tradeoff, though, provided 
they can still hire enough good people. 
They're far more concerned with fa"
71,411,"good. 
Problem-solving skills are valuable. 
If you're able to work through several hard problems (with some help, perhaps), you're probably pretty 
good at developing optimal algorithms. You're smart. 
Smart people tend to do good things, and that's valuable at a company. It's not the only thing th"
72,498,"Basic data structure and algorithm knowledge is useful. 
Many interviewers would argue that basic computer science knowledge is, in fact, useful. Understanding 
trees, graphs, lists, sorting, and other knowledge does come up periodically. When it does, it's really valu­
able. 
Could you learn it as "
73,471,"Other interviewers justify the reliance on data structures and algorithms by arguing that it's a good ""proxy:' 
Even if the skills wouldn't be that hard to learn on their own, they say it's reasonably well-correlated with 
being a good developer. It means that you've either gone through a computer s"
74,443,"your own. Either way, it's a good sign. 
There's another reason why data structure and algorithm knowledge comes up: because it's hard to ask 
problem-solving questions that don't involve them. It turns out that the vast majority of problem-solving 
questions involve some of these basics. When enoug"
75,485,"1 I The Interview Process
Whiteboards let 
you focus on what matters. 
It's absolutely true that you'd struggle with writing perfect code on a whiteboard. Fortunately, your inter­
viewer doesn't expect that. Virtually everyone has some bugs or minor syntactical errors. 
The nice thing about a whiteb"
76,485,"and boilerplate code. You get to focus on the interesting, ""meaty"" parts of the code: the function that the 
question is really all about. 
That's not to say that you should just write pseudocode or that correctness doesn't matter. Most inter­
viewers aren't okay with pseudocode, and fewer errors ar"
77,437,"But it's not for everyone or every company or every situation. 
The above sections are intended to help you understand the thought process of the company. 
My personal thoughts? For the right situation, when done well, it's a reasonable judge of someone's 
problem-solving skills, in that people who "
78,442,"It's also not appropriate for all companies. Some companies should value someone's prior experience more 
or need skills with particular technologies. These sorts of questions don't put much weight on that. 
It also won't measure someone's work ethic or ability to focus. Then again, almost no interv"
79,442,"I'll leave you with this: it is what it is, so let's do the best we can with it. 
� How Questions are Selected 
Candidates frequently ask what the ""recent"" interview questions are at a specific company. Just asking this 
question reveals a fundamental misunderstanding of where questions come from. 
"
80,403,"viewer selects their own questions. 
Since it's somewhat of a ""free for all"" as far as questions, there's nothing that makes a question a ""recent 
Google interview question"" other than the fact that some interviewer who happens to work at Google just 
so happened to ask that question recently. 
The "
81,498,"questions asked at Google generally don't differ from those asked at similar companies (Amazon, Face book, 
etc.). 
There are some broad differences across companies. Some companies focus on algorithms (often with some 
system design worked in), and others really like knowledge-based questions. But "
82,44,"6 Cracking the Coding Interview, 6th Edition"
83,464,"11 The Interview Process 
� It's All Relative 
If there's no grading system, how are you evaluated? How does an interviewer know what to expect of you? 
Good question. The answer actually makes a lot of sense once you understand it. 
Interviewers assess you relative to other candidates on that same "
84,478,"Alex the question, and it takes him 30 minutes to solve it. You ask Bella and she takes 50 minutes. Chris is 
never able to solve it. Dexter takes 15 minutes, but you had to give him some major hints and he probably 
would have taken far longer without them. Ellie takes 10-and comes up with an alter"
85,411,"have just gotten lucky. And maybe Chris got unlucky. You might ask a few more questions just to really 
make sure that it wasn't good or bad luck.) 
Interview questions are much the same way. Your interviewer develops a feel for your performance by 
comparing you to other people. It's not about the "
86,421,"candidates that she's ever asked this question to. 
For this reason, getting a hard question isn't a bad thing. When it's harder for you, it's harder for everyone. It 
doesn't make it any less likely that you'll do well. 
� Frequently Asked Questions 
I didn't hear back immediately after my intervie"
87,449,"is that one of your interviewers hasn't provided their feedback yet. Very, very few companies have a policy 
of not responding to candidates they reject. 
If you haven't heard back from a company within 3 - 5 business days after your interview, check in (politely) 
with your recruiter. 
Can I re-app"
88,182,"won't affect you too much when you re-interview. Lots of people get rejected from Google or Microsoft and 
later get offers from them. 
CrackingTheCodinglnterview.com I 6th Edition 7"
89,488,"II 
Behind the Scenes 
Most companies conduct their interviews in very similar ways. We will offer an overview of how companies 
interview and what they're looking for. This information should guide your interview preparation and your 
reactions during and after the interview. 
Once you are selected"
90,500,"Don't let the name fool you; the ""screening"" interview often involves coding and algorithms questions, and 
the bar can be just as high as it is for in-person interviews. If you're unsure whether or not the interview will 
be technical, ask your recruiting coordinator what position your interviewer "
91,495,"you to write code on paper and read it back over the phone. Some interviewers may even give you ""home­
work""to solve after you hang up the phone or just ask you to email them the code you wrote. 
You typically do one or two screening interviewers before being brought on-site. 
In an on-site intervie"
92,480,"good person to discuss your interests with and to ask about the company culture. Your other interviews will 
be mostly technical and will involve a combination of coding, algorithm, design/architecture, and behav­
ioral/experience questions. 
The distribution of questions between the above topics va"
93,459,"their interview questions. 
After your interview, your interviewers will provide feedback in some form. In some companies, your inter­
viewers meet together to discuss your performance and come to a decision. In other companies, inter­
viewers submit a recommendation to a hiring manager or hiring co"
94,498,"make a decision. 
Most companies get back after about a week with next steps (offer, rejection, further interviews, or just an 
update on the process). Some companies respond much sooner (sometimes same day!) and others take 
much longer. 
If you have waited more than a week, you should follow up wi"
95,411,"11 I Behind the Scenes
other company). Let me repeat that again: not responding indicates nothing about your status. The inten­
tion is that all recruiters should tell candidates once a final decision is made. 
Delays can and do happen. Follow up with your recruiter if you expect a delay, but be res"
96,450,"� The Microsoft Interview 
Microsoft wants smart people. Geeks. People who are passionate about technology. You probably won't be 
tested on the ins and outs of C ++ AP ls, but you will be expected to write code on the board. 
In a typical interview, you'll show up at Microsoft at some time in the m"
97,433,"there to prep you, not to grill you on technical questions. If you get asked some basic technical questions, 
it may be because your recruiter wants to ease you into the interview so that you're less nervous when the 
""real"" interview starts. 
Be nice to your recruiter. Your recruiter can be your bi"
98,415,"During the day, you'll do four or five interviews, often with two different teams. Unlike many companies, 
where you meet your interviewers in a conference room, you'll meet with your Microsoft interviewers in 
their office. This is a great time to look around and get a feel for the team culture. 
D"
99,452,"interview loop. 
When you complete your interviews with a team, you might speak with a hiring manager (often called the 
""as app'; short for ""as appropriate""). If so, that's a great sign! It likely means that you passed the interviews 
with a particular team. It's now down to the hiring manager's de"
100,421,"email asking for a status update. 
If your recruiter isn't very responsive, it's because she's busy, not because you're being silently rejected. 
Definitely Prepare: 
""Why do you want to work for Microsoft?"" 
In this question, Microsoft wants to see that you're passionate about technology. A great a"
101,433,"manages to create a product that is universally excellent. For example, I've been using Visual Studio recently 
to learn game programming, and its APls are excellent:' Note how this shows a passion for technology! 
What's Unique: 
You'll only reach the hiring manager if you've done well, so if you d"
102,142,"ences can vary substantially across Microsoft since different teams look for different things. 
CrackingTheCodinglnterview.com J 6th Edition 9"
103,485,"11 I Behind the Scenes 
� The Amazon Interview 
Amazon's recruiting process typically begins with a phone screen in which a candidate interviews with a 
specific team. A small portion of the time, a candidate may have two or more interviews, which can indicate 
either that one of their interviewers "
104,481,"position, a candidate may only do one phone screen. 
The engineer who interviews you will usually ask you to write simple code via a shared document editor. 
They will also often ask a broad set of questions to explore what areas of technology you're familiar with. 
Next, you fly to Seattle (or whic"
105,415,"whiteboard, and some interviewers will stress other skills. Interviewers are each assigned a specific area to 
probe and may seem very different from each other. They cannot see the other feedback until they have 
submitted their own, and they are discouraged from discussing it until the hiring meet"
106,433,"will interview candidates outside their group in order to balance out the group itself. If one interview seems 
significantly harder and different, that's most likely the bar raiser. This person has both significant experi­
ence with interviews and veto power in the hiring decision. Remember, though"
107,435,"relative to other candidates; it's not evaluated on a simple ""percent correct"" basis. 
Once your interviewers have entered their feedback, they will meet to discuss it. They will be the people 
making the hiring decision. 
While Amazon's recruiters are usually excellent at following up with candidat"
108,436,"Definitely Prepare: 
Amazon cares a lot about scale. Make sure you prepare for scalability questions. You don't need a back­
ground in distributed systems to answer these questions. See our recommendations in the System Design 
and Scalability chapter. 
Additionally, Amazon tends to ask a lot of que"
109,488,"What's Unique: 
The Bar Raiser is brought in from a different team to keep the bar high. You need to impress both this person 
and the hiring manager. 
Amazon tends to experiment more with its hiring process than other companies do. The process described 
here is the typical experience, but due to A"
110,116,"The interview is not terribly different from Microsoft's or Amazon's. 
10 Cracking the Coding Interview, 6th Edition"
111,418,"11 I Behind the Scenes
A Google engineer performs the first phone screen, so expect tough technical questions. These questions 
may involve coding, sometimes via a shared document. Candidates are typically held to the same standard 
and are asked similar questions on phone screens as in on-site inte"
112,441,"Interviewer feedback is kept confidential from the other interviewers, so you can be assured that you enter 
each interview with blank slate. Your lunch interviewer doesn't submit feedback, so this is a great opportu­
nity to ask honest questions. 
Interviewers are typically not given specific focus"
113,504,"Written feedback is submitted to a hiring committee (HC) of engineers and managers to make a hire I 
no-hire recommendation. Feedback is typically broken down into four categories (Analytical Ability, Coding, 
Experience, and Communication) and you are given an overall score from 1.0 to4.0. The HC u"
114,483,"words, a packet with scores of 3.6, 3.1, 3.1 and 2.6 is better than all 3.1 s. 
You do not necessarily need to excel in every interview, and your phone screen performance is usually not 
a strong factor in the final decision. 
If the hiring committee recommends an offer, your packet will go to a com"
115,430,"so many stages and committees. 
Definitely Prepare: 
As a web-based company, Google cares about how to design a scalable system. So, make sure you prepare 
for questions from System Design and Scalability. 
Google puts a strong focus on analytical (algorithm) skills, regardless of experience. You sh"
116,484,"What's Different: 
Your interviewers do not make the hiring decision. Rather, they enter feedback which is passed to a hiring 
committee. The hiring committee recommends a decision which can be-though rarely is-rejected by 
Google executives. 
� The Apple Interview 
Much like the company itself, App"
117,490,"While it's not a prerequisite to be a Mac user, you should at least be familiar with the system. 
The interview process usually begins with a recruiter phone screen to get a basic sense of your skills, 
followed up by a series of technical phone screens with team members. 
Once you're invited on cam"
118,89,"as key people with whom your team works. 
CrackingTheCodinglnterview.com j 6th Edition 11"
119,475,"11 I Behind the Scenes 
You can expect a mix of one-on-one and two-on-one interviews. Be ready to code on a whiteboard and 
make sure all of your thoughts are clearly communicated. Lunch is with your potential future manager and 
appears more casual, but it is still an interview. Each interviewer us"
120,499,"quent interviewers to drill into. 
Towards the end of the day, your interviewers will compare notes. If everyone still feels you're a viable candi­
date, you will have an interview with the director and the VP of the organization to which you're applying. 
While this decision is rather informal, it'"
121,497,"the wiser (until now). 
If you made it to the director and VP interviews, all of your interviewers will gather in a conference room 
to give an official thumbs up or thumbs down. The VP typically won't be present but can still veto the hire 
if they weren't impressed. Your recruiter will usually fol"
122,469,"about it? What would you improve? Offering specific recommendations can show your passion for the job. 
What's Unique: 
Apple does two-on-one interviews often, but don't get stressed out about them-it's the same as a one-on­
one interview! 
Also, Apple employees are huge Apple fans. You should show "
123,486,"be technical and will involve coding, usually an online document editor. 
After the phone interview(s), you might be asked to do a homework assignment that will include a mix of 
coding and algorithms. Pay attention to your coding style here. If you've never worked in an environment 
which had thoro"
124,502,"managers are also involved whenever they are available. All interviewers have gone through comprehen­
sive interview training, and who you interview with has no bearing on your odds of getting an offer. 
Each interviewer is given a ""role"" during the on-site interviews, which helps ensure that there "
125,498,"Would you fit well with the culture and values? What are you excited about? How do you tackle chal­
lenges? Be prepared to talk about your interest in Facebook as well. Facebook wants passionate people. 
You might also be asked some coding questions in this interview. 
Coding and Algorithms (""Ninja"""
126,70,"ming language you want. 
12 Cracking the Coding Interview, 6th Edition"
127,433,"11 I Behind the Scenes
Design/Architecture (""Pirate""): For a backend software engineer, you might be asked system design 
questions. Front-end or other specialties will be asked design questions related to that discipline. You 
should openly discuss different solutions and their tradeoffs. 
You can "
128,501,"usually get a ""pirate"" interview. 
After your interview, interviewers submit written feedback, prior to discussing your performance with each 
other. This ensures that your performance in one interview will not bias another interviewer's feedback. 
Once everyone's feedback is submitted, your intervi"
129,493,"to the hiring committee. 
Definitely Prepare: 
The youngest of the ""elite"" tech companies, Facebook wants developers with an entrepreneurial spirit. In 
your interviews, you should show that you love to build stuff fast. 
They want to know you can hack together an elegant and scalable solution using"
130,475,"in C++, Python, Erlang, and other languages. 
What's Unique: 
Facebook interviews developers for the company ""in general;' not for a specific team. If you are hired, you 
will go through a six-week ""bootcamp"" which will help ramp you up in the massive code base. You'll get 
mentorship from senior de"
131,509,"� The Palantir Interview 
Unlike some companies which do ""pooled"" interviews (where you interview with the company as a whole, 
not with a specific team), Palantir interviews for a specific team. Occasionally, your application might be 
re-routed to another team where there is a better fit. 
The Pal"
132,485,"focus on algorithm questions. 
You might also be sent a HackerRank coding assessment, which will evaluate your ability to write optimal 
algorithms and correct code. Less experienced candidates, such as those in college, are particularly likely 
to get such a test. 
After this, successful candidates"
133,272,"design. 
You may also likely get a demo of Palantir's products. Ask good questions and demonstrate your passion 
for the company. 
After the interview, the interviewers meet to discuss your feedback with the hiring manager. 
CrackingTheCodinglnterview.com I 6th Edition 13"
134,481,"11 I Behind the Scenes 
Definitely Prepare: 
Palantir values hiring brilliant engineers. Many candidates report that Palantir's questions were harder than 
those they saw at Google and other top companies. This doesn't necessarily mean it's harder to get an offer 
(although it certainly can); it jus"
135,500,"on preparing with the hardest algorithm questions. 
Brush up on system design too if you're interviewing for a backend role. This is an important part of the 
process. 
What's Unique: 
A coding challenge is a common part of Palantir's process. Although you'll be at your computer and can 
look up mat"
136,112,"You can also practice coding challenges online at HackerRank.com. 
14 Cracking the Coding Interview, 6th Edition"
137,493,"Ill 
Special Situations 
There are many paths that lead someone to this book. Perhaps you have more experience but have never 
done this sort of interview. Perhaps you're a tester or a PM. Or perhaps you're actually using this book to 
teach yourself how to interview better. Here's a little somethin"
138,462,"That's not entirely true. 
More experienced engineers might see slightly less focus on algorithm questions-but only slightly 
If a company asks algorithm questions to inexperienced candidates, they tend to ask them to experienced 
candidates too. Rightly or wrongly, they feel that the skills demonst"
139,487,"years since these candidates took an algorithms class. They're out of practice. 
Others though hold experienced candidates to a higher standard, reasoning that the more years of experi­
ence allow a candidate to have seen many more types of problems. 
On average, it balances out. 
The exception to t"
140,505,"would only come professionally. Your performance in such interview questions would be evaluated with 
respect to your experience level. However, students and recent graduates are still asked these questions 
and should be prepared to solve them as well as they can. 
Additionally, experienced candida"
141,351,"these questions should show it. 
� Testers and SDETs 
SDETs (software design engineers in test) write code, but to test features instead of build features. As such, 
they have to be great coders and great testers. Double the prep work! 
If you're applying for an SDET role, take the following approac"
142,434,"111 I Special Situations 
Prepare the Core Testing Problems: For example, how would you test a light bulb? A pen? A cash register? 
Microsoft Word? The Testing chapter will give you more background on these problems. 
• Practice the Coding Questions: The number one thing that SDETs get rejected for "
143,457,"to be very strong in coding and algorithms. Make sure that you practice solving all the same coding and
algorithm questions that a regular developer would get.
• Practice Testing the Coding Questions: A very popular format for SDET questions is ""Write code to do X;'
followed up by, ""Okay, now test i"
144,419,"Strong communication skills can also be very important for testers, since your job requires you to work with 
so many different people. Do not neglect the Behavioral Questions section. 
Career Advice 
Finally, a word of career advice: If, like many candidates, you are hoping to apply to an SDET posi"
145,430,"tion to a dev position. Make sure to keep your coding and algorithms skills very sharp if you hope to make 
this move, and try to switch within one to two years. Otherwise, you might find it very difficult to be taken 
seriously in a dev interview. 
Never let your coding skills atrophy. 
� Product ("
146,412,"PMs may be essentially customer evangelists, working in a customer-facing role that borders on marketing. 
Across campus though, other PMs may spend much of their day coding. The latter type of PMs would likely 
be tested on coding, since this is an important part of their job function. 
Generally s"
147,429,"following areas: 
• Handling Ambiguity: This is typically not the most critical area for an interview, but you should be aware
that interviewers do look for skill here. Interviewers want to see that, when faced with an ambiguous
situation, you don't get overwhelmed and stall. They want to see you ta"
148,443,"way. This typically will not be tested directly (though it can be), but it may be one of many things the
interviewer is looking for in a problem.
Customer Focus (Attitude): Interviewers want to see that your attitude is customer-focused. Do you
assume that everyone will use the product just like you"
149,499,"like ""De sign an alarm clock for the blind"" are ripe for examining this aspect. When you hear a question
like this, be sure to ask a lot of questions to understand who the customer is and how they are using the
product. The skills covered in the Testing section are closely related to this.
Customer "
150,347,"the job. Deep technical knowledge of mobile phones is probably not necessary to work on the Android
or Windows Phone teams (although it might still be nice to have), whereas an understanding of security
might be necessary to work on Windows Security. Hopefully, you wouldn't interview with a team tha"
151,430,"111 j Special Situations 
required specific technical skills unless you at least claim to possess the requisite skills. 
, Multi-Level Communication: PMs need to be able to communicate with people at all levels in the 
company, across many positions and ranges of technical skills. Your interviewer w"
152,432,"as, ""Explain TCP/IP to your grandmother:'Your communication skills may also be assessed by how you 
discuss your prior projects. 
, Passion for Technology: Happy employees are productive employees, so a company wants to make sure 
that you'll enjoy the job and be excited about your work. A passion f"
153,453,"are you interested in Microsoft?"" Additionally, your interviewers will look for enthusiasm in how you 
discuss your prior experience and how you discuss the team's challenges. They want to see that you will 
be eager to face the job's challenges. 
, Teamwork/ Leadership: This may be the most importa"
154,476,"commonly, this is assessed with questions like, ""Tell me about a time when a teammate wasn't pulling 
his / her own weight:' Your interviewer is looking to see that you handle conflicts well, that you take 
initiative, that you understand people, and that people like working with you. Your work prep"
155,453,"view. The weighting of each of these areas will roughly match the importance that the area holds in the 
actual job. 
� Dev Lead and Managers 
Strong coding skills are almost always required for dev lead positions and often for management positions 
as well. If you'll be coding on the job, make sure"
156,485,"In addition, prepare to be examined for skills in the following areas: 
Teamwork I Leadership: Anyone in a management-like role needs to be able to both lead and work with 
people. You will be examined implicitly and explicitly in these areas. Explicit evaluation will come in the 
form of asking you"
157,467,"come off as too arrogant or too passive, your interviewer may feel you aren't great as a manager. 
Prioritization: Managers are often faced with tricky issues, such as how to make sure a team meets a 
tough deadline. Your interviewers will want to see that you can prioritize a project appropriately,"
158,501,"and what you can reasonably expect to accomplish. 
Communication: Managers need to communicate with people both above and below them, and poten­
tially with customers and other much less technical people. Interviewers will look to see that you can 
communicate at many levels and that you can do so i"
159,281,"things done:'This means striking the right balance between preparing for a project and actually imple­
menting it. You need to understand how to structure a project and how to motivate people so you can 
accomplish the team's goals. 
CrackingTheCodinglnterview.com I 6th Edition 17"
160,465,"111 I Special Situations 
Ultimately, most of these areas come back to your prior experience and your personality. Be sure to prepare 
very, very thoroughly using the interview preparation grid. 
� Startups 
The application and interview process for startups is highly variable. We can't go through e"
161,404,"deviate from this. 
The Application Process 
Many startups might post job listings, but for the hottest startups, often the best way in is through a personal 
referral. This reference doesn't necessarily need to be a close friend or a coworker. Often just by reaching 
out and expressing your interes"
162,499,"Visas and Work Authorization 
Unfortunately, many smaller startups in the U.S. are not able to sponsor work visas. They hate the system 
as much you do, but you won't be able to convince them to hire you anyway. If you require a visa and wish 
to work at a startup, your best bet is to reach out to a"
163,418,"startups. 
Resume Selection Factors 
Startups tend to want engineers who are not only smart and who can code, but also people who would 
work well in an entrepreneurial environment. Your resume should ideally show initiative. What sort of proj­
ects have you started? 
Being able to ""hit the ground r"
164,459,"language of the company. 
The Interview Process 
In contrast to big companies, which tend to look mostly at your general aptitude with respect to software 
development, startups often look closely at your personality fit, skill set, and prior experience. 
Personality Fit: Personality fit is typicall"
165,502,"Skill Set: Because startups need people who can hit the ground running, they are likely to assess your 
skills with specific programming languages. If you know a language that the startup works with, make 
sure to brush up on the details. 
Experience: Startups are likely to ask you a lot of question"
166,54,"common. 
18 Cracking the Coding Interview, 6th Edition"
167,451,"111 I Special Situations 
� Acquisitions and Acquihires 
During the technical due diligence process for many acquisitions, the acquirer will often interview most or 
all of a startup's employees. Google, Yahoo, Facebook, and many other companies have this as a standard 
part of many acquisitions. 
W"
168,502,"want acquisitions to be an ""easy way"" into the company. And, since the team is a core motivator for the 
acquisition, they figure it makes sense to assess the skills of the team. 
Not all acquisitions are like this, of course. The famous multi-billion dollar acquisitions generally did not 
have to g"
169,467,"However, it is not as simple as""acquihires get interviewed, traditional acquisitions do not:'There is a big gray 
area between acquihires (i.e., talent acquisitions) and product acquisitions. Many startups are acquired for 
the team and ideas behind the technology. The acquirer might discontinue the"
170,506,"similar to what a normal candidate would experience (and, therefore, very similar to what you'll see in this 
book). 
How important are these interviews? 
These interviews can carry enormous importance. They have three different roles: 
• They can make or break acquisitions. They are often the reaso"
171,466,"These interviews are much more than a mere ""screen:' 
Which employees go through the interviews? 
For tech startups, usually all of the engineers go through the interview process, as they are one of the core 
motivators for the acquisition. 
In addition, sales, customer support, product managers, an"
172,460,"closest match for the CEO's current responsibilities. This is not an absolute rule, though. It depends on what 
the CEO's role presently is and what the CEO is interested in. With some of my clients, the CEO has even 
opted to not interview and to leave the company upon the acquisition. 
What happen"
173,112,"perform well, then the acquisition will likely not go through.) 
CrackingTheCodinglnterview.com I 6th Edition 19"
174,467,"111 I Special Situations 
In some cases, employees who performed poorly in interviews will get contract positions for the purpose of 
""knowledge transfer:'These are temporary positions with the expectation that the employee leaves at the 
termination of the contract (often six months), although some"
175,489,"common situations: 
Sometimes a startup labels someone who is not a ""traditional"" software engineer as a software engineer. 
This often happens with data scientists or database engineers. These people may underperform during 
the software engineer interviews, as their actual role involves other skil"
176,452,"In either case, sometimes the employee will be re-interviewed for a more appropriate position. (Other times 
though, the employee is just out of luck.) 
In rare cases, a CEO is able to override the decision for a particularly strong employee whose interview 
performance didn't reflect this. 
Your ""b"
177,506,"which might not perfectly match what their manager evaluates in their employees. 
I've worked with many companies that are surprised at who their strongest and weakest performers are in 
interviews. That junior engineer who still has a lot to learn about professional development might turn out 
to b"
178,496,"Essentially yes, although there is a bit more leeway. 
The big companies tend to take a risk-averse approach to hiring. If someone is on the fence, they often lean 
towards a no-hire. 
In the case of an acquisition, the ""on the fence"" employees can be pulled through by strong performance 
from the r"
179,482,"Or, what if we get their hopes up but it doesn't happen? 
What I've seen with my clients is that the leadership is worried about this more than is necessary. 
Certainly, some employees are upset about the process. They might not be excited about joining one of the 
big companies for any number of re"
180,45,"20 Cracking the Coding Interview, 6th Edition"
181,496,"111 I Special Situations 
What happens to the team after an acquisition? 
Every situation is different. However, most of my clients have been kept together as a team, or possibly 
integrated into an existing team. 
How should you prepare your team for acquisition interviews? 
Interview prep for acqu"
182,477,"interview on their own merits. 
You're all in this together. 
Some startups I've worked with put their ""real"" work on hold and have their teams spend the next two or 
three weeks on interview prep. 
Obviously, that's not a choice all companies can make, but-from the perspective of wanting the acquis"
183,491,"If possible, use all three of these approaches. 
Some people may be less prepared than others. 
Many developers at startups might have only vaguely heard of big O time, binary search tree, breadth-first 
search, and other important concepts. They'll need some extra time to prepare. 
People without c"
184,423,"important). A good first exercise is to implement all the core data structures and algorithms from scratch. 
If the acquisition is important to your company, give these people the time they need to prepare. They'll 
need it. 
Don't wait until the last minute. 
As a startup, you might be used to taki"
185,490,"this with acquisition interviews tend not to fare well. 
Acquisition interviews often come up very suddenly. A company's CEO is chatting with an acquirer (or 
several acquirers) and conversations get increasingly serious. The acquirer mentions the possibility of inter­
views at some point in the fut"
186,451,"of days to prepare. That might not be enough time for your engineers to learn core computer science 
concepts and practice interview questions. 
� For Interviewers 
Since writing the last edition, I've learned that a lot of interviewers are using Cracking the Coding Interview 
to learn how to interv"
187,498,"111 j Special Situations 
Don't actually ask the exact questions in here. 
First, these questions were selected because they're good for interview preparation. Some questions that 
are good for interview preparation are not always good for interviewing. For example, there are some 
brainteasers in t"
188,462,"find them to be bad questions. 
Second, your candidates are reading this book, too. You don't want to ask questions that your candidates 
have already solved. 
You can ask questions similar to these, but don't just pluck questions out of here. Your goal is to test their 
problem-solving skills, not "
189,510,"are too easy, performance gets clustered together. Minor issues can substantially drop someone's perfor­
mance. It's not a reliable indicator. 
Look for questions with multiple hurdles. 
Some questions have ""Aha!"" moments. They rest on a particular insight. If the candidate doesn't get that one 
bit"
190,414,"series of hurdles, insights, or optimizations. Multiple data points beat a single data point. 
Here's a test: if you can give a hint or piece of guidance that makes a substantial difference in a candidate's 
performance, then it's probably not a good interview question. 
Use hard questions, not hard"
191,445,"enough, fewer candidates do well so the statistics look right, but it's not for reasons that indicate much 
about the candidates' skills. 
The knowledge you are expecting candidates to have should be fairly straightforward data structure and 
algorithm knowledge. It's reasonable to expect a computer"
192,483,"If your interview question expects obscure knowledge, ask yourself: is this truly an important skill? Is it so 
important that I would like to either reduce the number of candidates I hire or reduce the amount to which 
I focus on problem-solving or other skills? 
Every new skill or attribute you ev"
193,368,"who could recite the finer points of a two-inch thick algorithms textbook. But all else isn't equal. 
Avoid ""scary"" questions. 
Some questions intimidate candidates because it seems like they involve some specialized knowledge, 
even if they really don't. This often includes questions that involve: "
194,493,"Low-level knowledge (memory allocation, etc.). 
• System design or scalability.
Proprietary systems (Google Maps, etc.).
111 I Special Situations 
For example, one question I sometimes ask is to find all positive integer solutions under 1,000 to a3 + b 3 
= c 3 + d 3 (page 68). 
Many candidates will"
195,510,"When I ask this question, I explicitly say, ""I know this sounds like a math problem. Don't worry. It's not. It's an 
algorithm question:' If they start going down the path of factorization, I stop them and remind them that 
it's not a math question. 
Other questions might involve a bit of probabilit"
196,456,"probability will intimidate candidates. 
Be careful asking questions that sound intimidating. Remember that this is already a really intimidating 
situation for candidates. Adding on a ""scary"" question might just fluster a candidate and cause him to 
underperform. 
If you're going to ask a question "
197,453,"Offer positive reinforcement. 
Some interviewers put so much focus on the ""right"" question that they forget to think about their own 
behavior. 
Many candidates are intimidated by interviewing and try to read into the interviewer's every word. They 
can cling to each thing that might possibly sound "
198,412,"You want candidates to feel good about the experience, about you, and about their performance. You want 
them to feel comfortable. A candidate who is nervous will perform poorly, and it doesn't mean that they 
aren't good. Moreover, a good candidate who has a negative reaction to you or to the compa"
199,481,"Try to be warm and friendly to candidates. This is easier for some people than others, but do your best. 
Even if being warm and friendly doesn't come naturally to you, you can still make a concerted effort to 
sprinkle in positive remarks throughout the interview: 
• ""Right, exactly:'
""Great point:"
200,84,"some positivity into the interview. 
CrackingTheCodinglnterview.com ! 6th Edition 23"
201,425,"Ill \ Special Situations 
Probe deeper on behavioral questions. 
Many candidates are poor at articulating their specific accomplishments. 
You ask them a question about a challenging situation, and they tell you about a difficult situation their 
team faced. As far as you can tell, the candidate did"
202,473,"their team's accomplishments and not boast about themselves. This is especially common for people in 
leadership roles and female candidates. 
Don't assume that a candidate didn't do much in a situation just because you have trouble understanding 
what they did. Call out the situation (nicely!). Ask"
203,431,"into more details about how they thought about the issue and the different steps they took. Ask them why 
they took certain actions. Not describing the details of the actions they took makes them a flawed candi­
date, but not necessarily a flawed employee. 
Being a good interview candidate is its ow"
204,409,"ably not one you want to evaluate. 
Coach your candidates. 
Read through the sections on how candidates can develop good algorithms. Many of these tips are ones 
you can offer to candidates who are struggling. You're not ""teaching to the test"" when you do this; you're 
separating interview skills fr"
205,472,"example). This makes it substantially more difficult to develop a solution, but it doesn't necessarily mean 
that they're not very good problem solvers. If candidates don't write an example themselves, or if they 
inadvertently write a special case, guide them. 
• Some candidates take a long time to"
206,480,"to analyze their code conceptually first, or that a small example would work nearly as well. Guide them.
If they dive into code before they have an optimal solution, pull them back and focus them on the algo­
rithm (if that's what you want to see). It's unfair to say that a candidate never found or "
207,442,"brute force solution and look for areas to optimize.
If they haven't said anything and there is a fairly obvious brute force, remind them that they can start off
with a brute force. Their first solution doesn't have to be perfect.
Even if you think that a candidate's ability in one of these areas is"
208,504,"While this book is here to coach candidates through interviews, one of your goals as an interviewer is to 
remove the effect of not preparing. After all, some candidates have studied for interviews and some candi­
dates haven't, and this probably doesn't reveal much about their skills as an engineer"
209,45,"24 Cracking the Coding Interview, 6th Edition"
210,455,"111 I Special Situations 
Be careful here, though. If you're someone who comes off as intimidating to candidates, this coaching could 
make things worse. It can come off as your telling candidates that they're constantly messing up by creating 
bad examples, not prioritizing testing the right way, a"
211,509,"on talking when they just need a moment to think in silence. 
If your candidate needs this, give your candidate this time to think. Learn to distinguish between ""I'm stuck 
and have no idea what to do;' and ""I'm thinking in silence:' 
It might help you to guide your candidate, and it might help many"
212,497,"evaluating them that they got a bit less guidance than others. 
Know your mode: sanity check, quality, specialist, and proxy. 
At a very, very high level, there are four modes of questions: 
Sanity Check: These are often easy problem-solving or design questions. They assess a minimum 
degree of comp"
213,496,"when you only need a minimum degree of competency. 
Quality Check: These are the more challenging questions, often in problem-solving or design. They 
are designed to be rigorous and really make a candidate think. Use these when algorithmic/problem­
solving skills are of high importance. The biggest"
214,503,"learning. They should be used when for skills a good engineer couldn't quickly learn on the job. These
questions need to be appropriate for true specialists. Unfortunately, I've seen situations where a
company asks a candidate who just completed a 10-week coding bootcamp detailed questions about
Jav"
215,454,"Proxy Knowledge: This is knowledge that is not quite at the specialist level (in fact, you might not even
need it), but that you would expect a candidate at their level to know. For example, it might not be very
important to you if a candidate knows CSS or HTML. But if a candidate has worked in dept"
216,509,"absorbing information core to their job.
When companies get into trouble is when they mix and match these: 
They ask specialist questions to people who aren't specialists. 
They hire for specialist roles when they don't need specialists. 
• They need specialists but are only assessing pretty basic s"
217,256,"minor detail might have separated these.
In fact, having worked with a number of small and large tech companies on their hiring process, I have 
found that most companies are doing one of these things wrong. 
CrackingTheCodinglnterview.com / 6th Edition 25"
218,458,"IV 
Before the Interview 
Acing an interview starts well before the interview itself-years before, in fact. The following timeline 
outlines what you should be thinking about when. 
If you're starting late into this process, don't worry. Do as much ""catching up"" as you can, and then focus on 
prepar"
219,432,"fore, the first step in landing an interview is getting great experience. The further in advance you can think 
about this the better. 
For current students, this may mean the following: 
Take the Big Project Classes: Seek out the classes with big coding projects. This is a great way to get some­
wh"
220,456,"to the real world, the better. 
Get an Internship: Do everything you can to land an internship early in school. It will pave the way for 
even better internships before you graduate. Many of the top tech companies have internship programs 
designed especially for freshman and sophomores. You can als"
221,424,"source project. It doesn't matter too much what it is. The important thing is that you're coding. Not only
will this develop your technical skills and practical experience, your initiative will impress companies.
Professionals, on the other hand, may already have the right experience to switch to th"
222,461,"you're trying to move from a lesser-known company to one of the ""biggies;' or from testing/IT into a dev 
role, the following advice will be useful: 
Shift Work Responsibilities More Towards Coding: Without revealing to your manager that you are thinking 
of leaving, you can discuss your eagerness t"
223,411,"resume bullet or two. It is these coding projects that will, ideally, form the bulk of your resume. 
Use Your Nights and Weekends: If you have some free time, use it to build a mobile app, a web app, or a 
piece of desktop software. Doing such projects is also a great way to get experience with new "
224,147,"your resume; few things are as impressive to an interviewer as a candidate who built something ""just 
26 Cracking the Coding Interview, 6th Edition"
225,484,"IV I Before the Interview 
for fun:· 
All of these boil down to the two big things that companies want to see: that you're smart and that you can 
code. If you can prove that, you can land your interview. 
In addition, you should think in advance about where you want your career to go. If you want t"
226,431,"� Writing a Great Resume 
Resume screeners look for the same things that interviewers do. They want to know that you're smart and 
that you can code. 
That means you should prepare your resume to highlight those two things. Your love of tennis, traveling, or 
magic cards won't do much to show that. "
227,494,"Appropriate Resume Length 
In the US, it is strongly advised to keep a resume to one page if you have less than ten years of experience. 
More experienced candidates can often justify 1.5 - 2 pages otherwise. 
Think twice about a long resume. Shorter resumes are often more impressive. 
Recruiters on"
228,472,"distracts the recruiter from what you'd really like them to see. 
Some people just flat-out refuse to read long resumes. Do you really want to risk having your resume 
tossed for this reason? 
If you are thinking right now that you have too much experience and can't fit it all on one or two pages, 
"
229,417,"understanding how to prioritize content. 
Employment History 
Your resume does not-and should not-include a full history of every role you've ever had. Include only 
the relevant positions-the ones that make you a more impressive candidate. 
Writing Strong Bullets 
For each role, try to discuss your"
230,444,"menting Y which led to z:· Here's an example: 
• ""Reduced object rendering time by 75% by implementing distributed caching, leading to a 10% reduc­
tion in log-in time:·
Here's another example with an alternate wording: 
• ""Increased average match accuracy from 1.2 to 1.5 by implementing a new compa"
231,149,"did it, and what the results were. Ideally, you should try to make the results ""measurable"" somehow. 
CrackingTheCodinglnterview.com j 6th Edition 27"
232,418,"IV I Before the Interview 
Projects 
Developing the projects section on your resume is often the best way to present yourself as more experi­
enced. This is especially true for college students or recent grads. 
The projects should include your 2 - 4 most significant projects. State what the project"
233,453,"the project was an individual or a team project, and whether it was completed for a course or indepen­
dently. These details are not required, so only include them if they make you look better. Independent 
projects are generally preferred over course projects, as it shows initiative. 
Do not add to"
234,500,"cluttering their resume with small, non-impressive projects. 
So what should you build? Honestly, it doesn't matter that much. Some employers really like open source 
projects (it offers experience contributing to a large code base), while others prefer independent projects 
(it's easier to understa"
235,401,"Programming Languages and Software 
Software 
Be conservative about what software you list, and understand what's appropriate for the company. Soft­
ware like Microsoft Office can almost always be cut. Technical software like Visual Studio and Eclipse is 
somewhat more relevant, but many of the top "
236,465,"really that hard to learn Visual Studio? 
Of course, it won't hurt you to list all this software. It just takes up valuable space. You need to evaluate the 
trade-off of that. 
Languages 
Should you list everything you've ever worked with, or shorten the list to just the ones that you're most 
comfo"
237,446,"resume to be ""fair game"" as far as the interview. 
One alternative is to list most of the languages you've used, but add your experience level. This approach 
is shown below: 
Languages: Java (expert}, C ++ (proficient), JavaScript (prior experience). 
Use whatever wording (""expert'; ""fluent'; etc.)"
238,492,"really confusing. If you first learned Java 10 years ago, and have used it occasionally throughout that time, 
how many years of experience is this? 
For this reason, the number of years of experience is a poor metric for resumes. It's better to just describe 
what you mean in plain English. 
Advice"
239,80,"speaker to proofread your resume. 
28 Cracking the Coding Interview, 6th Edition"
240,491,"IV I Before the Interview 
Additionally, for US positions, do not include age, marital status, or nationality. This sort of personal informa­
tion is not appreciated by companies, as it creates a legal liability for them. 
Beware of (Potential) Stigma 
Certain languages have stigmas associated with "
241,486,"just letting you know of it. 
A few stigmas you should be aware of: 
Enterprise Languages: Certain languages have a stigma associated with them, and those are often the 
ones that are used for enterprise development. Visual Basic is a good example of this. If you show your­
self to be an expert with"
242,441,"But still, the kinds of applications that people tend to build with it are not very sophisticated. You would 
be unlikely to see a big name Silicon Valley using VB. 
In fact, the same argument (although less strong) applies to the whole .NET platform. If your primary 
focus is .NET and you're not ap"
243,495,"Being Too Language Focused: When recruiters at some of the top tech companies see resumes that 
list every flavor of Java on their resume, they make negative assumptions about the caliber of candi­
date. There is a belief in many circles that the best software engineers don't define themselves aroun"
244,496,"Note that this does not mean that you should necessarily take this ""language flaunting"" off your resume. 
You need to understand what that company values. Some companies do value this. 
• Certifications: Certifications for software engineers can be anything from a positive, to a neutral, to
a negati"
245,491,"This means that in some cases, you should actually remove this sort of experience from your resume.
Knowing Only One or Two Languages: The more time you've spent coding, the more things you've
built, the more languages you will have tended to work with. The assumption then, when they see a
resume wi"
246,445,"hasn't the candidate learned more things?) or will just feel too tied with a specific technology (poten­
tially not using the best language for the task).
This advice is here not just to help you work on your resume, but also to help you develop the right experi­
ence. If your expertise is in C#.NET"
247,281,"Where possible, try to truly diversify. The languages in the cluster of {Python, Ruby, and JavaScript} are 
somewhat similar to each other. It's better if you can learn languages that are more different, like Python, 
C++, and Java. 
CrackingTheCodinglnterview.com I 6th Edition 29"
248,500,"IV I Before the Interview 
� Preparation Map 
The following map should give you an idea of how to tackle the interview preparation process. One of the 
key takeaways here is that it's not just about interview questions. Do projects and write code, too! 
Students: find intern­
ship and take classes 
"
249,501,"• 
Learn and master 
Big 0. 
Do several mock inter­
views. 
• 
Continue to practice 
interview questions. 
Begin applying to 
companies. 
Build projects outside 
of school/work. 
Build website/ port-
Learn multiple 
programming 
Ian ua es . 
• 
.__ f olio showcasing your ...__ Expand Network. 
exper"
250,454,"• 
Create draft of resume 
...__ and send it out for a 
resume review . 
_____. tures and algorithms _____. 
Form mock interview 
group with friends to 
interview each other . from scratch. 
Do mini-projects to 
...__ solidify understanding 
of ke conce ts . 
Create list to track 
-----. mistakes yo"
251,497,"Re-read intro to CtCi, 
especially Tech & __.. 
Behavioral section. 
Do a final mock 
interview. 
• 
Rehearse stories 
from the interview __.. 
prep grid (pg 32). 
Rehearse each story 
from interview prep .._ 
grid once . 
• 
Continue to practice 
questions & review __.. 
your list of mistakes. 
Rem"
252,502,"Your hard work paid ..__ 
off! 
IV I Before the Interview 
Do another mock Continue to practice 
__.. questions, writing interview. code on paper. 
• 
Phone Interview: 
Locate headset and/or 
video camera . 
Re-read Algorithm __.. Re-read Big O section 
Approaches (pg 67). (pg 38). 
• 
.._ Continue "
253,279,".._ time to eat a good Cocky!). breakfast & be on time. 
__.. Write Thank You note 
to recruiter. 
• 
If no offer, ask when If you haven't heard 
you can re-apply. Don't ..__ from recruiter, check in 
give up hope! after one week. 
CrackingTheCodinglnterview.com I 6th Edition 31"
254,495,"V 
Behavioral Questions 
Behavioral questions are asked to get to know your personality, to understand your resume more deeply, 
and just to ease you into an interview. They are important questions and can be prepared for. 
� Interview Preparation Grid 
Go through each of the projects or components "
255,501,"Enjoyed 
Leadership 
Conflicts 
What You'd Do Differently 
Along the top, as columns, you should list all the major aspects of your resume, including each project, job, 
or activity. Along the side, as rows, you should list the common behavioral questions. 
Study this grid before your interview. Red"
256,475,"it being a distraction. 
In addition, ensure that you have one to three projects that you can talk about in detail. You should be able 
to discuss the technical components in depth. These should be projects where you played a central role. 
What are your weaknesses? 
When asked about your weaknesses"
257,394,"conveys a real, legitimate weakness but emphasizes how you work to overcome it. 
For example: 
I 
32 
""Sometimes, I don't have a very good attention to detail. While that's good because it lets me 
execute quickly, it also means that I sometimes make careless mistakes. Because of that, I make 
sure "
258,480,"V I Behavioral Questions 
What questions should you ask the interviewer? 
Most interviewers will give you a chance to ask them questions. The quality of your questions will be a 
factor, whether subconsciously or consciously, in their decisions. Walk into the interview with some ques­
tions in mind."
259,450,"are valuable to many candidates: 
1. ""What is the ratio of testers to developers to program managers? What is the interaction like? How does
project planning happen on the team?""
2. ""What brought you to this company? What has been most challenging for you?""
These questions will give you a good feel "
260,445,"1. ""I noticed that you use technology X. How do you handle problem Y?""
2. ""Why did the product choose to use the X protocol over the Y protocol? I know it has benefits like A, B,
C, but many companies choose not to use it because of issue o:'
Asking such questions will typically require advance rese"
261,484,"ested in learning and will be a strong contributor to the company. 
1. 'Tm very interested in scalability, and I'd love to learn more about it. What opportunities are there at this
company to learn about this?""
2. ""I'm not familiar with technology X, but it sounds like a very interesting solution. C"
262,445,"master. Select projects that ideally fit the following criteria: 
The project had challenging components (beyond just ""learning a lot""). 
• You played a central role (ideally on the challenging components).
• You can talk at technical depth.
For those projects, and all your projects, be able to talk"
263,136,"You can also think about follow-up questions, like how you would scale the application. 
CrackingTheCodinglnterview.com I 6th Edition 33"
264,411,"V I Behavioral Questions 
� Responding to Behavioral Questions 
Behavioral questions allow your interviewer to get to know you and your prior experience better. Remember 
the following advice when responding to questions. 
Be Specific, Not Arrogant 
Arrogance is a red flag, but you still want to mak"
265,448,"sound good without being arrogant? By being specific! 
Specificity means giving just the facts and letting the interviewer derive an interpretation. For example, 
rather than saying that you ""did all the hard parts,"" you can instead describe the specific bits you did that 
were challenging. 
Limit D"
266,447,"subject or projectto understand it. 
Stay light on details and just state the key points. When possible, try to translate it or at least explain the 
impact. You can always offer the interviewer the opportunity to drill in further. 
I 
""By examining the most common user behavior and applying the Rab"
267,506,"into more details if you'd like:' 
This demonstrates the key points while letting your interviewer ask for more details if he wants to. 
Focus on Yourself, Not Your Team 
Interviews are fundamentally an individual assessment. Unfortunately, when you listen to many candidates 
(especially those in le"
268,500,"date did little. 
Pay attention to your answers. Listen for how much you say ""we"" versus 'T' Assume that every question is 
about your role, and speak to that. 
Give Structured Answers 
There are two common ways to think about structuring responses to a behavioral question: nugget first 
and S.A.R. "
269,340,"will be about. 
For example: 
Interviewer: ""Tell me about a time you had to persuade a group of people to make a big change:' 
Candidate:""Sure, let me tell you about the time when I convinced my school to let undergraduates teach 
their own courses. Initially, my school had a rule where .. :' 
34 Cr"
270,449,"V I Behavioral Questions 
This technique grabs your interviewer's attention and makes it very clear what your story will be about. It 
also helps you be more focused in your communication, since you've made it very clear to yourself what 
the gist of your response is. 
S.A.R. (Situation, Action, Res"
271,510,"and lastly, describing the result. 
Example: ''Tell me about a challenging interaction with a teammate:' 
Situation: On my operating systems project, I was assigned to work with three other people. While two 
were great, the third team member didn't contribute much. He stayed quiet during meetings, "
272,425,"Action: I didn't want to write him off completely yet, so I tried to resolve the situation. I did three things. 
First, I wanted to understand why he was acting like this. Was it laziness? Was he busy with something 
else? I struck up a conversation with him and then asked him open-ended questions a"
273,488,"is one of the most time intensive parts. This showed me that it wasn't laziness; it was that he didn't feel 
like he was good enough to write code. 
Second, now that I understand the cause, I tried to make it clear that he shouldn't fear messing up. I told 
him about some of the bigger mistakes that"
274,495,"sat down together and designed a thorough spec for one of the big component, in much more detail 
than we had before. Once he could see all the pieces, it helped show him that the project wasn't as scary 
as he'd assumed. 
Result: With his confidence raised, he now offered to take on a bunch of the "
275,494,"The situation and the result should be succinct. Your interviewer generally does not need many details to 
understand what happened and, in fact, may be confused by them. 
By using the S.A.R. model with clear situations, actions and results, the interviewer will be able to easily 
identify how you m"
276,298,"Story 1 1 . ... 
2 . ... 
3 ... 
Story 2 
Explore the Action 
In almost all cases, the ""action"" is the most important part of the story. Unfortunately, far too many people 
talk on and on about the situation, but then just breeze through the action. 
CrackingTheCodinglnterview.com j 6th Edition 35"
277,507,"VI Behavioral Questions
Instead, dive into the action. Where possible, break down the action into multiple parts. For example: ""I did 
three things. First, !...""This will encourage sufficient depth. 
Think About What It Says 
Re-read the story on page 35. What personality attributes has the candidat"
278,441,"showed empathy in knowing what would resolve the teammate's insecurity. 
Compassion: Although the teammate was harming the team, the candidate wasn't angry at the team­
mate. His empathy led him to compassion. 
Humility: The candidate was able to admit to his own flaws (not only to the teammate, but"
279,446,"manageable chunks.
You should think about your stories from this perspective. Analyze the actions you took and how you 
reacted. What personality attributes does your reaction demonstrate? 
In many cases, the answer is""none:'That usually means you need to rework how you communicate the story 
to mak"
280,424,"go one step away from that. For example: 
Less Clear Attribute: ""I called up the client and told him what happened:' 
More Clear Attribute (Empathy and Courage): ""I made sure to call the client myself, because I knew 
that he would appreciate hearing it directly from me:' 
If you still can't make th"
281,415,"entirely. 
� So, tell me about yourself ... 
Many interviewers kick off the session by asking you to tell them a bit about yourself, or asking you to walk 
through your resume. This is essentially a ""pitch''. It's your interviewer's first impression of you, so you want 
to be sure to nail this. 
Str"
282,450,"describing their current job and the conclusion discussing their relevant and interesting hobbies outside 
of work (if any). 
1. Current Role [Headline Only]: ""I'm a software engineer at Microworks, where I've been leading the
Android team for the last five years:'
2. College: My background is in co"
283,364,"3. Post College & Onwards: After college, I wanted to get some exposure to larger corporations so I joined
Amazon as a developer. It was a great experience. I learned a ton about large system design and I got to
really drive the launch of a key part of AWS. That actually showed me that I really want"
284,454,"V f Behavioral Questions 
entrepreneurial environment. 
4. Current Role [Details]: One of my old managers from Amazon recruited me out to join her startup,
which was what brought me to Microworks. Here, I did the initial system architecture, which has scaled
pretty well with our rapid growth. I then"
285,411,"5. Outside of Work: Outside of work, I've been participating in some hackathons-mostly doing iOS
development there as a way to learn it more deeply. I'm also active as a moderator on online forums
around Android development.
6. Wrap Up: I'm looking now for something new, and your company caught my e"
286,407,"This structure works well for about 95% of candidates. For candidate with more experience, you might 
condense part of it. Ten years from now, the candidate's initial statements might become just: ""After my 
CS degree from Berkeley, I spent a few years at Amazon and then joined a startup where I led"
287,456,"Often they're just fluff. If your hobby is just generic activities like skiing or playing with your dog, you can 
probably skip it. 
Sometimes though, hobbies can be useful. This often happens when: 
• The hobby is extremely unique (e.g., fire breathing). It may strike up a bit of a conversation and"
288,489,"The hobby demonstrates a positive personality attribute. A hobby like ""remodeling your house yourself""
shows a drive to learn new things, take some risks, and get your hands dirty (literally and figuratively).
It would rarely hurt to mention hobbies, so when in doubt, you might as well. 
Think about"
289,507,"Sprinkle in Shows of Successes 
In the above pitch, the candidate has casually dropped in some highlights of his background. 
He specifically mentioned that he was recruited out of Microworks by his old manager, which shows that 
he was successful at Amazon. 
He also mentions wanting to be in a smal"
290,397,"system. 
He mentions his hobbies, both of which show a drive to learn. 
When you think about your pitch, think about what different aspects of your background say about you. 
Can you can drop in shows of successes (awards, promotions, being recruited out by someone you worked 
with, launches, etc.)?"
291,464,"VI 
BigO 
This is such an important concept that we are dedicating an entire (long!) chapter to it. 
Big O time is the language and metric we use to describe the efficiency of algorithms. Not understanding 
it thoroughly can really hurt you in developing an algorithm. Not only might you be judged ha"
292,411,"slower. 
Master this concept. 
� An Analogy 
Imagine the following scenario: You've got a file on a hard drive and you need to send it to your friend who 
lives across the country. You need to get the file to your friend as fast as possible. How should you send it? 
Most people's first thought would"
293,417,"reasonable, but only half correct. 
If it's a small file, you're certainly right. It would take 5 - 10 hours to get to an airport, hop on a flight, and 
then deliver it to your friend. 
But what if the file were really, really large? Is it possible that it's faster to physically deliver it via plane"
294,431,"much faster to just fly it across the country. If your file is that urgent (and cost isn't an issue), you might just 
want to do that. 
What if there were no flights, and instead you had to drive across the country? Even then, for a really huge 
file, it would be faster to drive. 
� Time Complexity "
295,484,"""algorithm"" runtime as: 
Electronic Transfer: 0( s ), where s is the size of the file. This means that the time to transfer the file 
increases linearly with the size of the file. (Yes, this is a bit of a simplification, but that's okay for these 
purposes.) 
Airplane Transfer: 0( 1) with respect to"
296,465,"VI I Big 0 
No matter how big the constant is and how slow the linear increase is, linear will at some point surpass 
constant. 
... ··· 0(1) .. ·· ---------.----... 
.. ·· 
.. ····· 
There are many more runtimes than this. Some of the most common ones are O(log N), O(N log N), 
O(N), O(N2) and 0( 2"
297,459,"wide and h meters high could be described as O ( wh). If you needed p layers of paint, then you could say 
that the time is O ( whp). 
Big 0, Big Theta, and Big Omega 
If you've never covered big O in an academic setting, you can probably skip this subsection. It might 
confuse you more than it help"
298,499,"Academics use big 0, big 0 (theta), and big O (omega) to describe runtimes. 
O (big 0): In academia, big O describes an upper bound on the time. An algorithm that prints all the 
values in an array could be described as O(N), but it could also be described as O(N2), O(N3), or 0( 2N) 
(or many other "
299,411,"assume no one lives past age 130), then you could say X .$. 130. It would also be correct to say that 
X .$. 1, 000 or X .$. 1,000,000. It's technically true (although not terribly useful). Likewise, a simple 
algorithm to print the values in an array is O(N) as well as O(N3 ) or any runtime bigger "
300,477,"an array is O(N) as well as O(log N) and 0(1). After all, you know that it won't be faster than those 
runtimes. 
· 0 (big theta): In academia, e means both O and 0. That is, an algorithm is 0(N) if it is both O(N) and
0( N). 0 gives a tight bound on runtime.
In industry (and therefore in interviews"
301,369,"array as O(N2 ). Industry would just say this is O(N). 
For this book, we will use big O in the way that industry tends to use it: By always trying to offer the tightest 
description of the runtime. 
Best Case, Worst Case, and Expected Case 
We can actually describe our runtime for an algorithm in t"
302,447,"VI I Big 0 
Let's look at this from the perspective of quick sort. Quick sort picks a random element as a ""pivot"" and then 
swaps values in the array such that the elements less than pivot appear before elements greater than pivot. 
This gives a ""partial sort:'Then it recursively sorts the left and "
303,490,"This is O ( N). (This actually depends slightly on the implementation of quick sort. There are implementa­
tions, though, that will run very quickly on a sorted array.) 
• Worst Case: What if we get really unlucky and the pivot is repeatedly the biggest element in the array?
(Actually, this can easi"
304,456,"array in half and recurse on each half. It just shrinks the subarray by one element. This will degenerate
to anO(N2) runtime.
Expected Case: Usually, though, these wonderful or terrible situations won't happen. Sure, sometimes
the pivot will be very low or very high, but it won't happen over and ove"
305,460,"take essentially any algorithm, special case some input, and then get an O ( 1) time in the best case. 
For many-probably most-algorithms, the worst case and the expected case are the same. Sometimes 
they're different, though, and we need to describe both of the runtimes. 
What is the relationship "
306,453,"""lower"" and ""exactly right""), but there is no particular relationship between the concepts. 
Best, worst, and expected cases describe the big O (or big theta) time for particular inputs or scenarios. 
Big 0, big omega, and big theta describe the upper, lower, and tight bounds for the runtime. 
� Spa"
307,510,"or space-required by an algorithm. 
Space complexity is a parallel concept to time complexity. If we need to create an array of size n, this will 
require 0( n) space. If we need a two-dimensional array of size nxn, this will require O( n2) space. 
Stack space in recursive calls counts, too. For exa"
308,221,"Each call adds a level to the stack. 
1 sum(4) 
2 -> sum(3) 
3 -> sum(2) 
4 -> sum(l) 
5 -> sum(0) 
Each of these calls is added to the call stack and takes up actual memory. 
40 Cracking the Coding Interview, 6th Edition"
309,473,"VI I Big 0 
However, just because you have n calls total doesn't mean it takes O(n) space. Consider the below func­
tion, which adds adjacent elements between O and n: 
1 int pairSumSequence(int n) {/* Ex 2.*/ 
2 int sum = 0; 
3 for (inti= 0; i < n; i++) { 
4 sum+= pairSum(i, i + 1); 
5 } 
6 return "
310,505,"stack, so you only need O ( 1) space. 
� Drop the Constants 
It is very possible for O(N) code to run faster than 0( 1) code for specific inputs. Big O just describes the 
rate of increase. 
For this reason, we drop the constants in runtime. An algorithm that one might have described as 0(2N) 
is ac"
311,478,"Consider the below code: 
Min and Max 1 
1 int min = Integer.MAX_VALUE; 
2 int max = Integer.MIN_VALUE; 
3 for (int x : array) { 
4 if (x < min) min x; 
5 if (x > max) max = x; 
6 } 
MinandMax2 
1 int min = Integer.MAX_VALUE; 
2 int max = Integer.MIN_VALUE; 
3 for (int x : array) { 
4 if (x < min) m"
312,422,"solution has two lines of code per for loop rather than one. 
If you're going to count the number of instructions, then you'd have to go to the assembly level and take 
into account that multiplication requires more instructions than addition, how the compiler would opti­
mize something, and all sor"
313,165,"express how the runtime scales. We just need to accept that it doesn't mean that O(N) is always better than 
O(N2 ). 
CrackingTheCodinglnterview.com \ 6th Edition 41"
314,469,"VI I Big 0 
� Drop the Non-Dominant Terms
What do you do about an expression such as O 
( N2 + N)? That second N isn't exactly a constant. But it's 
not especially important. 
We already said that we drop constants. Therefore, 0( N2 + N 2) would be O ( N2 ). If we don't care about that 
latter N2 te"
315,494,"• O(N + log N) becomesO(N).
0(5*2N + 1000N100 ) becomes0(2N).
We might still have a sum in a runtime. For example, the expression0(82 + A) cannot be reduced (without
some special knowledge of A and B). 
The following graph depicts the rate of increase for some of the common big O times . 
E 0 
O(log"
316,298,"! ) too, such as O( xx) or 0( 2x * x ! ) . 
� Multi-Part Algorithms: Add vs. Multiply 
Suppose you have an algorithm that has two steps. When do you multiply the runtimes and when do you 
add them? 
This is a common source of confusion for candidates. 
42 Cracking the Coding Interview, 6th Edition"
317,508,"Add the Runtimes: 0 ( A + B) 
1 for (int a : arrA) { 
2 print(a); 
3 } 
4 
5 for (int b : arrB) { 
6 print(b); 
7 } 
Multiply the Runtimes: 0 (A* B) 
1 for (int a : arrA) { 
2 for (int b: arrB) { 
3 print(a + "","" + b); 
4 } 
5 } 
VI I Big 0 
In the example on the left, we do A chunks of work then B "
318,431,"work isO(A * B). 
In other words: 
If your algorithm is in the form ""do this, then, when you're all done, do that""then you add the runtimes. 
If your algorithm is in the form ""do this for each time you do that""then you multiply the runtimes. 
It's very easy to mess this up in an interview, so be car"
319,495,"flexibility in size. You won't run out of space in the Arraylist since its capacity will grow as you insert 
elements. 
An Arraylist is implemented with an array. When the array hits capacity, the Arraylist class will create a 
new array with double the capacity and copy all the elements over to the"
320,491,"You will have to create a new array of size 2N and then copy N elements over. This insertion will take O ( N) 
time. 
However, we also know that this doesn't happen very often. The vast majority of the time insertion will be 
inO(l) time. 
We need a concept that takes both into account. This is what"
321,444,"long that the cost is ""amortized:' 
In this case, what is the amortized time? 
As we insert elements, we double the capacity when the size of the array is a power of 2. So after X elements, 
we double the capacity at array sizes 1, 2, 4, 8, 16, ... , X. That doubling takes, respectively, 1, 2, 4, 8,"
322,303,"until it gets to X. If you read right to left, it starts with X and halves until it gets to 1. 
What then is the sum of X + X + X + X + ... + 1 ?This is roughly 2X.
Therefore, X insertions take 0( 2X) time. The amortized time for each insertion is 0( 1). 
CrackingTheCodinglnterview.com \ 6th Edition"
323,504,"VI I Big 0 
� Log N Runtimes 
We commonly see O(log N) in runtimes. Where does this come from? 
Let's look at binary search as an example. In binary search, we are looking for an example x in an N-element 
sorted array. We first compare x to the midpoint of the array. If x == middle, then we return."
324,504,"compare 9 to 11 -> smaller. 
search 9 within {1, 5, 8, 9, 11} 
compare 9 to 8 -> bigger 
search 9 within {9, 11} 
compare 9 to 9 
return 
We start off with an N-element array to search. Then, after a single step, we're down to Yi elements. One 
more step, and we're down to % elements. We stop when w"
325,466,"becomes 1. 
N = 16 
N 8 /* divide by 2 */ 
N 4 /* divide by 2 *I
N 2 /* divide by 2 */ 
N 1 I* divide by 2 */ 
We could look at this in reverse (going from 1 to 16 instead of 16 to 1 ). How many times we can multiply 1 
by 2 until we get N? 
N 1 
N 2 
N 4 
N 8 
N 16 
/* multiply by 2 */ 
/* multiply"
326,454,"2• = 16 -> log2l6 = 4 
log2N = k -> 2 k = N 
This is a good takeaway for you to have. When you see a problem where the number of elements in the 
problem space gets halved each time, that will likely be a 0( log N) runtime. 
This is the same reason why finding an element in a balanced binary search "
327,351,"each time. 
I 
What's the base of the log?That's an excellent question!The short answer is that it doesn't matter 
for the purposes of big 0. The longer explanation can be found at ""Bases of Logs"" on page 630. 
� Recursive Runtimes 
Here's a tricky one. What's the runtime of this code? 
1 int f(int "
328,512,"2 if (n <= 1) {
3 return 1;
4 } 
5 return f(n - 1) + f(n - 1);
6 } 
VII Big 0 
A lot of people will, for some reason, see the two calls to f and jump to 0( N2). This is completely incorrect.
Rather than making assumptions, let's derive the runtime by walking through the code. Suppose we call
f ( 4)."
329,447,"f(4)
-----
f(3)
f(2) / �(22 
./ � / ""'-
f(l) f(l) f(l) f(l)
How many calls are in this tree? (Don't count!)
The tree will have depth N. Each node (i.e., function call) has two children. Therefore, each level will have
twice as many calls as the one above it. The number of nodes on each level is:
0 2"
330,439,"4 16 2 * previous level = 2 * 23 24 24
Therefore, there will be 2° + 21 + 2 2 + 2 3 + 2 4 + . • . + 2 N (which is 2N•1 - 1) nodes. (See ""Sum of
Powers of 2"" on page 630.)
Try to remember this pattern. When you have a recursive function that makes multiple calls, the runtime will
often (but not alway"
331,464,"call branches. In this case, this gives us O ( 2N). 
I 
As you may recall, the base of a log doesn't matter for big O since logs of different bases are
only different by a constant factor. However, this does not apply to exponents. The base of an
exponent does matter. Compare 2"" and 8"". If you expan"
332,467,"not a constant factor!
The space complexity of this algorithm will be O(N). Although we have 0(2N) nodes in the tree total, only
O(N) exist at any given time. Therefore, we would only need to have O(N) memory available.
� Examples and Exercises 
Big O time is a difficult concept at first. However, o"
333,106,"We'll start off easy and get progressively more difficult.
CrackingTheCodinglnterview.com I 6th Edition 45"
334,492,"VI I Big 0 
Example 1 
What is the runtime of the below code? 
1 void foo(int[] array) { 
2 int sum = 0; 
3 int product = 1; 
4 for (inti= 0; i < array.length; i++) { 
5 sum + = array[i); 
6 } 
7 for (int i= 0; i < array.length; i++) { 
8 product*= array[i]; 
9 } 
10 System.out.println(sum + "", "" + "
335,491,"1 void printPairs (int[] array) { 
2 for (int i= 0; i < array.length; i++) { 
3 for (int j = 0; j < array.length; j++) { 
4 System.out.println(array[i] + "","" + array[j]); 
5 } 
6 } 
7 } 
The inner for loop has O ( N) iterations and it is called N times. Therefore, the runtime is O ( N2 ). 
Another w"
336,441,"Example3 
This is very similar code to the above example, but now the inner for loop starts at i + 1. 
1 void printUnorderedPairs (int[] array) { 
2 for (int i= 0; i < array.length; i++) { 
3 for (int j = i + 1; j < array.length; j++) { 
4 System.out.println(array[i] + "","" + array[j]); 
5 } 
6 } 
7 "
337,364,"deeply understand it. You can't rely on just memorizing common runtimes. Deep comprehen­
sion is important. 
Counting the Iterations 
The first time through j runs for N-1 steps. The second time, it's N-2 steps. Then N-3 steps. And so on. 
Therefore, the number of steps total is: 
(N-1) + (N-2) + (N"
338,483,"= 1 + 2 + 3 + ... + N-1 
= sum of 1 throug h N-1 
VI I Big 0 
N(N-1) 
f h h ,, 6 ) h . ·11The sum of 1 through N-1 is -2- (see""Sum o Integers 1 t roug N on page 30, so t e runtime w1 
beO(N2). 
What It Means 
Alternatively, we can figure out the runtime by thinking about what the code ""means:' It it"
339,472,"code goes through roughly Nx pairs so it does O(N2) work.
Visualizing 
What It Does 
The code iterates through the following ( i, j) pairs when N = 8: 
(0, 1) (0, 2) (0, 3) (0, 4) (0, 5) (0, 6) (0, 7) 
(1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, '7) 
(2, 3) (2, 4) (2, 5) (2, 6) (2, 7) 
(3, 4) (3, 5) (3, "
340,458,"Average Work 
We know that the outer loop runs N times. How much work does the inner loop do? It varies across itera­
tions, but we can think about the average iteration. 
What is the average value of 1, 2, 3, 4, 5, 6, 7, 8, 9, 10? The average value will be in the 
middle, so it will be roughly 5. ("
341,449,"Therefore, since the inner loop does Yi work on average and it is run N times, the total work is N/i which 
is O(N2 ). 
Example4 
This is similar to the above, but now we have two different arrays. 
1 void printUnorderedPairs(int[] arrayA, int[] arrayB) { 
2 for (inti= 0; 
i < arrayA.length; i++) { "
342,284,"6 } 
7 } 
8 } 
9 } 
We can break up this analysis. The if-statement within j's for loop is 0( 1) time since it's just a sequence of 
constant-time statements. 
We now have this: 
1 void printUnorderedPairs(int[] arrayA, int[] arrayB) { 
CrackingTheCodinglnterview.com I 6th Edition 47"
343,498,"VI I Big 0 
2 for (int i= 0; i < arrayA.length; i++) { 
3 for (int j = 0; j < arrayB.length; j++) { 
4 /* 0(1) work*/ 
5 } 
6 } 
7 } 
For each element of array A, the inner for loop goes through b iterations, where b = arrayB. length. 
lfa = arrayA.length,then the runtime isO(ab). 
If you said O( N2"
344,506,"Examples 
What about this strange bit of code? 
1 void printUnorderedPairs(int[] arrayA, int[] arrayB) { 
2 for (int i= 0; i < arrayA.length; i++) { 
3 for (int j = 0; j < arrayB.length; j++) { 
4 for (int k = 0; k < 100000; k++) { 
5 System.out.println(arrayA[i] + "","" + arrayB[j]); 
6 } 
7 } 
8 } 
"
345,485,"1 void reverse( int[] array) { 
2 for (inti= 0; i < array.length/ 2; i++) { 
3 int other= array.length - i - 1; 
4 int temp= array[i]; 
5 array[i] = array[other]; 
6 array[other] = temp; 
7 } 
8 } 
This algorithm runs in O ( N) time. The fact that it only goes through half of the array (in terms of "
346,218,"• 0(2N)
O(N + log N)
O(N + M)
Let's go through these. 
If P < X, then we know that N is the dominant term so we can drop the 0( P). 
• 0(2N) isO(N) since we drop constants.
48 Cracking the Coding Interview, 6th Edition"
347,476,"VI I Big 0 
• O(N) dominatesO(log N),so we can drop theO(log N).
There is no established relationship between N and M, so we have to keep both variables in there.
Therefore, all but the last one are equivalent to O(N). 
Examples 
Suppose we had an algorithm that took in an array of strings, sorted e"
348,409,"each string, so that's O(N*N log N). We also have to sort this array, so that's an additional O(N log N) 
work.Therefore,the total runtime isO(N2 log N + N log N),which isjust0(N2 log N). 
This is completely incorrect. Did you catch the error? 
The problem is that we used N in two different ways. In"
349,500,"And in another case, it's the length of the array. 
In your interviews, you can prevent this error by either not using the variable ""N"" at all, or by only using it 
when there is no ambiguity as to what N could represent. 
In fact, I wouldn't even use a and b here, or m and n. It's too easy to forge"
350,461,"Let s be the length of the longest string. 
Let a be the length of the array. 
Now we can work through this in parts: 
• Sorting each string is 0( s log s).
• We have to do this for every string (and there are a strings), so that's 0( a* s log s).
Now we have to sort all the strings. There are a str"
351,508,"to compare the strings. Each string comparison takes O(s) time. There are O(a log a) comparisons,
therefore this will take 0( a*s log a) time.
If you add up these two parts, you get 0( a* s ( log a + log s)). 
This is it. There is no way to reduce it further. 
Example!) 
The following simple code su"
352,225,"4 } 
5 return sum(node.left) + node.value + sum(node.right); 
6 } 
Just because it's a binary search tree doesn't mean that there is a log in it! 
We can look at this two ways. 
CrackingTheCodinglnterview.com I 6th Edition 49"
353,501,"VI I Big 0 
What It Means 
The most straightforward way is to think about what this means. This code touches each node in the tree 
once and does a constant time amount of work with each ""touch"" (excluding the recursive calls). 
Therefore, the runtime will be linear in terms of the number of nodes. "
354,426,"Let's try that approach here. 
We said that the runtime of a recursive function with multiple branches is typically O( branchesdepth). 
There are two branches at each call, so we're looking at 0(2depth). 
At this point many people might assume that something went wrong since we have an exponential a"
355,505,"rithm (yikes!). 
The second statement is correct. We do have an exponential time algorithm, but it's not as bad as one might 
think. Consider what variable it's exponential with respect to. 
What is depth? The tree is a balanced binary search tree. Therefore, if there are N total nodes, then depth 
"
356,468,"Let P = 210g N. By the definition of log2, we can write this as log2P = log2N. This means that P N.
Let P = 210g N 
-> logl = log2N 
-> p = N 
->2logN = N
Therefore, the runtime of this code is O( N), where N is the number of nodes. 
Example 10 
The following method checks if a number is prime by ch"
357,462,"it's divisible by something smaller than it. 
For example, while 33 is divisible by 11 (which is greater than the square root of 33), the ""counterpart""to 11 
is 3 (3 * 11 = 33). 33 will have already been eliminated as a prime number by 3. 
What is the time complexity of this function? 
1 boolean isP"
358,500,"VI I Big 0 
8 } 
Many people get this question wrong. If you're careful about your logic, it's fairly easy. 
The work inside the for loop is constant. Therefore, we just need to know how many iterations the for loop 
goes through in the worst case. 
The for loop will start when x = 2 and end when x*"
359,476,"2 for (int x = 2; x <= sqrt(n); x++) { 
3 if (n % X == 0) { 
4 return false; 
5 } 
6 } 
7 return true; 
8 } 
This runs in O( vn) time. 
Example 11 
The following code computes n ! (n factorial). What is its time complexity? 
1 int factorial(int n) { 
2 if (n < 0) { 
3 return -1; 
4 } else if (n 
5 r"
360,412,"Example12 
This code counts all permutations of a string. 
1 void permutation(String str) { 
2 permutation(str, """"); 
3 } 
4 
5 void permutation(String str, String prefix) { 
6 if (str.length() == 0) { 
7 System.out.println(prefix); 
8 } else { 
9 for (int i= 0; i < str.length(); i++) { 
10 String r"
361,312,"11 permutation(rem, prefix + str.charAt(i)); 
12 } 
13 } 
14 } 
This is a (very!) tricky one. We can think about this by looking at how many times permutation gets called 
and how long each call takes. We'll aim for getting as tight of an upper bound as possible. 
CrackingTheCodinglnterview.com I 6t"
362,428,"VI I Big 0 
How many times does permutation get called in its base case? 
If we were to generate a permutation, then we would need to pick characters for each ""slot:' Suppose we 
had 7 characters in the string. In the first slot, we have 7 choices. Once we pick the letter there, we have 6 
choices f"
363,460,"next slot, and so on. 
Therefore, the total number of options is 7 * 6 * 5 * 4 * 3 * 2 * 1, which is also expressed as 7! (7 factorial). 
This tells us that there are n! permutations. Therefore, permutation is called n ! times in its base case 
(when prefix is the full permutation). 
How many times "
364,499,"representing all the calls. There are n ! leaves, as shown above. Each leaf is attached to a path of length n. 
Therefore, we know there will be no more than n * n ! nodes (function calls) in this tree. 
How long does each function call take? 
Executing line 7 takes 0( n) time since each character n"
365,465,"Each node in our call tree therefore corresponds to 0( n) work. 
What is the total runtime? 
Since we are calling permutation 0( n * n ! ) times (as an upper bound), and each one takes 0( n) time, 
the total runtime will not exceed O ( n2 * n ! ) .
Through more complex mathematics, we can derive a t"
366,465,"Example 13 
The following code computes the Nth Fibonacci number. 
1 int fib(int n) { 
2 if (n <= 0) return 0; 
3 else if (n == 1) return 1; 
4 return fib(n - 1) + fib(n - 2); 
5 
} 
We can use the earlier pattern we'd established for recursive calls: O( branches depth). 
There are 2 branches per ca"
367,506,"exponential, but it's actually closer to 0( 1. 6N). The reason that it's not exactly 0( 2N) is that, at 
the bottom of the call stack, there is sometimes only one call. It turns out that a lot of the nodes 
are at the bottom (as is true in most trees), so this single versus double call actually make"
368,100,"you can recognize that it'll actually be less than that. 
Cracking the Coding Interview, 6th Edition"
369,456,"VI I Big 0 
Generally speaking, when you see an algorithm with multiple recursive calls, you're looking at exponential 
runtime. 
Example14 
The following code prints all Fibonacci numbers from Oto n. What is its time complexity? 
1 void allFib(int n) { 
2 for (int i= 0; i < n; i++) { 
3 System.out."
370,499,"10 return fib(n - 1) + fib(n - 2); 
11 } 
Many people will rush to concluding that since fib(n) takes 0(2°) time and it's called n times, then it's 
O(n2°). 
Not so fast. Can you find the error in the logic? 
The error is that the n is changing. Yes, fib ( n) takes 0( 2°) time, but it matters what t"
371,497,"fib(n) -> 2"" steps 
Therefore, the total amount of work is: 
21 + 22 + 23 + 24 + , , , + 2 ° 
As we showed on page 44, this is 2°+1. Therefore, the runtime to compute the first n Fibonacci numbers 
(using this terrible algorithm) is still O ( 2°). 
Example 15 
The following code prints all Fibonacci"
372,396,"is its runtime? 
1 void allFib(int n) { 
2 int[] memo = new int[n + 1]; 
3 for (int i= 0; i < n; i++) { 
4 System.out.println(i + "": ""+ fib(i, memo)); 
5 } 
6 } 
7 
8 int fib(int n, int[] memo) { 
9 if (n <= 0) return 0; 
10 else if (n == 1) return 1; 
11 else if (memo[n] > 0) return memo[n]; 
12 
1"
373,464,"VI I Big 0 
14 return memo[n]; 
15 } 
Let's walk through what this algorithm does. 
fib(l) -> return 1 
fib(2) 
fib(l) -> return 1 
fib(0) -> return 0 
store 1 at memo[2] 
fib(3) 
fib(2) -> lookup memo[2] -> return 1 
fib(l) -> return 1 
store 2 at memo[3] 
fib(4) 
fib(3) -> lookup memo[3] -> return"
374,465,"fib(3) -> lookup memo[3] -> return 2 
store 5 at memo[S] 
At each call to fib(i), we have already computed and stored the values for fib( i-1) and fib(i-2). 
We just look up those values, sum them, store the new result, and return. This takes a constant amount of 
time. 
We're doing a constant amoun"
375,483,"rithms. 
Example 16 
The following function prints the powers of 2 from 1 through n (inclusive). For example, if n is 4, it would 
print 1, 2, and 4. What is its runtime? 
1 int powers0f2(int n) { 
2 if (n < 1) { 
3 return 0; 
4 } else if (n == 1) {
5 System.out.println(l); 
6 return 1; 
7 } else { "
376,141,"What It Does 
Let's walk through a call like powers0f2 ( 50). 
powers0f2(50) 
-> powers0f2(25) 
54 Cracking the Coding Interview, 6th Edition"
377,414,"-> powers0f2(12) 
-> powers0f2(6) 
-> powers0f2(3) 
-> powersOf2(1) 
-> print & return 1 
print & return 2 
print & return 4 
print & return 8 
print & return 16 
print & return 32 
VI I Big 0 
The runtime, then, is the number of times we can divide 50 (or n) by 2 until we get down to the base case "
378,495,"What It Means 
We can also approach the runtime by thinking about what the code is supposed to be doing. It's supposed 
to be computing the powers of 2 from 1 through n. 
Each call to powers0f2 results in exactly one number being printed and returned (excluding what happens 
in the recursive calls)."
379,454,"the function is called (which will be its runtime) must equal the number of powers of 2 between 1 and n. 
There are log N powers of 2 between 1 and n. Therefore, the runtime is 0( log n ). 
Rate of Increase 
A final way to approach the runtime is to think about how the runtime changes as n gets bigg"
380,442,"number of calls to powersOfTwo increase? It will increase by 1 each time n doubles in size. 
So, each time n doubles, the number of calls to powersOfTwo increases by 1. Therefore, the number of 
calls to powersOfTwo is the number of times you can double 1 until you get n. It is x in the equation 2x "
381,358,"Additional Problems 
log n. 
Vl.1 The following code computes the product of a and b. What is its runtime? 
int product(int a, int b) { 
} 
int sum = 0; 
for (int i= 0; i < b; i++) { 
sum += a; 
} 
return sum; 
Vl.2 The following code computes ab. What is its runtime? 
int power(int a, int b) { 
if "
382,493,"VI I Big 0 
return 0; II error 
} else if (b == 0) { 
return 1; 
} else { 
return a* power(a, b - 1); 
} 
} 
Vl.3 The following code computes a % b. What is its runtime? 
int mod(int a, int b) { 
} 
if (b <= 0) { 
return -1; 
} 
int div = a I b; 
return a - div * b; 
Vl.4 The following code performs"
383,475,"while (sum <= a) { 
sum += b; 
count++; 
} 
return count; 
} 
VI.S The following code computes the [integer] square root of a number. If the number is not a
perfect square (there is no integer square root) , then it returns -1. It does this by successive 
guessing. If n is 100, it first guesses SO. "
384,446,"} 
int sqrt_helper(int n, int min, int max) { 
if (max < min) return -1; II no square root 
int guess = (min + max) I 2·, 
if (guess *guess == n) { II found it!
return guess; 
} else if (guess * guess < n) { II too low 
return sqrt_helper(n, guess + 1, max); II try higher 
} else { II too high 
retu"
385,352,"a perfect square (there is no integer square root), then it returns -1. It does this by trying 
increasingly large numbers until it finds the right value (or is too high). What is its runtime? 
int sqrt(int n) { 
for (int guess = 1; guess * guess <= n; guess++) { 
if (guess * guess == n) { 
return g"
386,462,"} 
} 
} 
return -1; 
VI I Big 0 
Vl.7 If a binary search tree is not balanced, how long might it take (worst case) to find an element 
in it? 
Vl.8 You are looking for a specific value in a binary tree, but the tree is not a binary search tree. 
What is the time complexity of this? 
Vl.9 The appendT"
387,485,"function that repeatedly calls appendToNew. How long does copying an array take? 
int[] copyArray(int[] array) { 
} 
int[] copy= new int[0]; 
for (int value : array) { 
copy= appendToNew(copy, value); 
} 
return copy; 
int[] appendToNew(int[] array, int value) { 
// copy all elements over to new arr"
388,500,"bigger[bigger.length - 1] 
return bigger; 
value; 
Vl.10 The following code sums the digits in a number. What is its big O time? 
int sumDigits(int n) { 
int sum = 0; 
while (n > 0) { 
sum += n % 10; 
n /= 10; 
} 
return sum; 
} 
Vl.11 The following code prints all strings of length k where the char"
389,287,"int numChars = 26; 
void printSortedStrings(int remaining) { 
printSortedStrings(remaining, """"); 
} 
void printSortedStrings(int remaining, String prefix) { 
if (remaining== 0) { 
if (isinOrder(prefix)) { 
System.out.println(prefix); 
} 
CrackingTheCodinglnterview.com I 6th Edition 57t."
390,496,"VI I Big 0 
} 
} else { 
} 
for (int i= 0; i < numchars; i++) { 
char c = ithletter(i); 
printSortedStrings(remaining - 1, prefix + c); 
} 
boolean isinOrder(String s) { 
} 
for (int i= 1; i < s.length(); i++) { 
int prev ithLetter(s.charAt(i - 1)); 
int curr = ithLetter(s.charAt(i)); 
if (prev > cu"
391,449,"arrays. It assumes that neither array has duplicates. It computes the intersection by sorting 
one array (array b) and then iterating through array a checking (via binary search) if each 
value is in b. What is its runtime? 
int intersection(int[] a, int[] b) { 
mergesort(b); 
} 
Solutions 
int inte"
392,438,"1. O( b). The for loop just iterates through b.
2. 0 ( b). The recursive code iterates through b calls, since it subtracts one at each level.
3. 0 ( 1). It does a constant amount of work.
4. 0( X ). The variable count will eventually equal X. The while loop iterates count times. Therefore, it
iterat"
393,193,"runtime isO(log n).
6. O(sqrt(n) ). This is just a straightforward loop that stops when guess*guess > n (or, in other
words, when guess > sqrt(n)).
58 Cracking the Coding Interview, 6th Edition"
394,493,"VI I Big 0 
7. O(n), where n is the number of nodes in the tree. The max time to find an element is the depth tree. The
tree could be a straight list downwards and have depth n.
8. O(n ). Without any ordering property on the nodes, we might have to search through all the nodes.
9. O ( n2 ), where n "
395,439,"through n, which is O ( n2).
10.0( log n). The runtime will be the number of digits in the number. A number with d digits can have a 
value up to 10d. If n = 10d, then d = log n. Therefore, the runtime is 0( log n). 
11.0( kck), where k is the length of the string and c is the number of characters i"
396,247,"O(k) time. 
12.0(b log b + a log b).First,we have to sort arrayb,which takesO(b log b) time.Then,for each 
element in a, we do binary search in 0( log b) time. The second part takes O(a log b) time. 
CrackingTheCodinglnterview.com I 6th Edition 59"
397,459,"VII 
Technical Questions 
Technical questions form the basis for how many of the top tech companies interview. Many candidates are 
intimidated by the difficulty of these questions, but there are logical ways to approach them. 
� How to Prepare 
Many candidates just read through problems and solutio"
398,499,"For each problem in this book (and any other problem you might encounter), do the following: 
7. Try to solve the problem on your own. Hints are provided at the back of this book, but push yourself to
develop a solution with as little help as possible. Many questions are designed to be tough-that's "
399,435,"tion, and quick debugging. Coding on paper does not. Get used to this-and to how slow it is to write
and edit code-by coding on paper.
3. Test your code-on paper. This means testing the general cases, base cases, error cases, and so on. You'll
need to do this during your interview, so it's best to p"
400,447,"the errors you make so that you can keep these in mind during the actual interview.
In addition, try to do as many mock interviews as possible. You and a friend can take turns giving each other 
mock interviews. Though your friend may not be an expert interviewer, he or she may still be able to walk"
401,452,"interviewer. 
� What You Need To Know 
The sorts of data structure and algorithm questions that many companies focus on are not knowledge 
tests. However, they do assume a baseline of knowledge. 
Core Data Structures, Algorithms, and Concepts 
Most interviewers won't ask about specific algorithms fo"
402,147,"You're usually only expected to know the basics. Here's a list of the absolute, must-have knowledge: 
60 Cracking the Coding Interview, 6th Edition"
403,425,"VII I Technical Questions 
Linked Lists Breadth-First Search Bit Manipulation 
Trees, Tries, & Graphs Depth-First Search Memory (Stack vs. Heap) 
Stacks & Queues Binary Search Recursion 
Heaps Merge Sort Dynamic Programming 
Vectors I Arraylists Quick Sort Big O Time & Space 
Hash Tables 
For each o"
404,455,"the space and time complexity. 
Practicing implementing the data structures and algorithm (on paper, and then on a computer) is also a 
great exercise. It will help you learn how the internals of the data structures work, which is important for 
many interviews. 
I
Did you miss that paragraph above?"
405,501,"In particular, hash tables are an extremely important topic. Make sure you are very comfortable with this 
data structure. 
Powers of 2 Table 
The table below is useful for many questions involving scalability or any sort of memory limitation. Memo­
rizing this table isn't strictly required, but it "
406,496,"30 1,073,741,824 1 billion 1 GB 
32 4,294,967,296 4GB 
40 l,099,511,627,776 1 trillion 1TB 
For example, you could use this table to quickly compute that a bit vector mapping every 32-bit integer to 
a boolean value could fit in memory on a typical machine. There are 232 such integers. Because each "
407,160,"If you are doing a phone screen with a web-based company, it may be useful to have this table in front of 
you. 
CrackingTheCodinglnterview.com I 6th Edition 61"
408,512,"VII I Technical Questions 
� Walking Through a Problem 
The below map/flowchart walks you through how to solve a problem. Use this in your practice. You can 
download this handout and more at CrackingTheCodinglnterview.com. 
A Problem-Solving Flowchart 
Listen - - - - - -•
Pay very dose attention to"
409,488,"like you would for a detailed code review.
2. Unusual or non-standard code.
3. Hot spots, like arithmetic and null nodes.
4. Small test cases. It's much faster than a big
test case and just as effective.
5. Special 
cases and edge cases.
And when you find bugs, fix them carefully! 
Implement 
Your g"
410,493,"62 Cracking the Coding Interview, 6th Edition 
Example 
Most examples are too small or are special 
cases. Debug your example. Is there any 
way it's a special case? Is it big enough? 
Brute Force • 
- -
Get a brute-force solution as soon as 
possible. Don't worry about developing 
an efficient algo"
411,498,"optimization or try some of these ideas: 
• Look for any unused info. You usually
need all the information in a problem.
> Solve it manually on an example, then
reverse engineer your thought process.
How did you solve it?
� Solve it""incorrectly"" and then think about 
why the algorithm fails. Can you"
412,96,"through your approach in detail. Make sure 
you understand each detail before you start 
coding."
413,464,"VII I Technical Questions 
We'll go through this flowchart in more detail. 
What to Expect 
Interviews are supposed to be difficult. If you don't get every-or any-answer immediately, that's okay! 
That's the normal experience, and it's not bad. 
Listen for guidance from the interviewer. The intervie"
414,509,"question, what the interviewer is looking for, and the interviewer's own personality. 
When you're given a problem (or when you're practicing), work your way through it using the approach 
below. 
1. Listen Carefully
You've likely heard this advice before, but I'm saying something a bit more than th"
415,489,"about anything you're unsure about. 
But I'm saying something more than that. 
Listen carefully to the problem, and be sure that you've mentally recorded any unique information in the 
problem. 
For example, suppose 
a question starts with one of the following lines. It's reasonable to assume that t"
416,493,"probably different than the optimal algorithm for the unsorted situation.
""Design an algorithm to be run repeatedly on a server that ... ""
The server/to-be-run-repeatedly situation is different from the run-once situation. Perhaps this means
that you cache data? Or perhaps it justifies some reasonab"
417,471,"the algorithm. 
Many candidates will 
hear the problem correctly. But ten minutes into developing an algorithm, some of 
the key details of the problem have been forgotten. Now they are in a situation where they actually can't 
solve the problem optimally. 
Your first algorithm doesn't need to use t"
418,310,"You might even find it useful to write the pertinent information on the whiteboard. 
2. Draw an Example 
An example can dramatically improve your ability to solve an interview question, and yet so many candi­
dates just try to solve the question in their heads. 
CrackingTheCodinglnterview.com I 6th "
419,511,"VII I Technical Questions 
When you hear a question, get out of your chair, go to the whiteboard, and draw an example. 
There's an art to drawing an example though. You want a good example. 
Very typically, a candidate might draw something like this for an example of a binary search tree: 
This is a"
420,442,"something about how to approach the problem? Third, it's actually a special case. It's not just a balanced 
tree, but it's also a beautiful, perfect tree where every node other than the leaves has two children. Special 
cases can be very deceiving. 
Instead, you want to create an example that is: 
S"
421,416,"Sufficiently large. Most examples are too small, by about 50%. 
Not a special case. Be careful. It's very easy to inadvertently draw a special case. If there's any way your 
example is a special case (even if you think it probably won't be a big deal), you should fix it. 
Try to make the best exampl"
422,455,"fix it. 
3. State a Brute Force 
Once you have an example done (actually, you can switch the order of steps 2 and 3 in some problems), 
state a brute force. It's okay and expected that your initial algorithm won't be very optimal. 
Some candidates don't state the brute force because they think it's "
423,498,"viewer to think that you're struggling to see even the easy solution. 
It's okay that this initial solution is terrible. Explain what the space and time complexity is, and then dive 
into improvements. 
Despite being possibly slow, a brute force algorithm is valuable to discuss. It's a starting poin"
424,488,"are: 
1. Look for any unused information. Did your interviewer tell you that the array was sorted? How can you
leverage that information?
2. Use a fresh example. Sometimes, just seeing a different example will unclog your mind or help you see
a pattern in the problem.
3. Solve it""incorrectly:' Just "
425,45,"64 Cracking the Coding Interview, 6th Edition"
426,451,"VII \ Technical Questions 
random value from a set such that all values are equally likely, an incorrect solution might be one that 
returns a semi-random value: Any value could be returned, but some are more likely than others. You 
can then think about why that solution isn't perfectly random. Can"
427,455,"the runtime.
5. Precompute information. Is there a way that you can reorganiz:e the data (sorting, etc.) or compute some
values upfront that will help save time in the long run?
6. Use a hash table. Hash tables are widely used in interview questions and should be at the top of your
mind.
7. Think ab"
428,465,"5. Walk Through
After you've nailed down an optimal algorithm, don't just dive into coding. Take a moment to solidify your 
understanding of the algorithm. 
Whiteboard coding is slow-very slow. So is testing your code and fixing it. As a result, you need to make 
sure that you get it as close to ""pe"
429,441,"when they change. 
I 
What about pseudocode? You can write pseudocode if you'd like. Be careful about what you 
write. Basic steps (""(1) Search array. (2) Find biggest. (3) Insert in heap:') or brief logic (""if p < 
q, move p. else move q"") can be valuable. But when your pseudocode starts having for"
430,450,"faster to just write the code. 
If you don't understand exactly what you're about to write, you'll struggle to code it. It will take you longer 
to finish the code, and you're more likely to make major errors. 
6. Implement 
Now that you have an optimal algorithm and you know exactly what you're goi"
431,434,"each line of code is written an awkward slant). It makes your code look messy and can be very confusing 
when working in a whitespace-sensitive language, like Python. 
Remember that you only have a short amount of code to demonstrate that you're a great developer. Every­
thing counts. Write beautifu"
432,277,"uses a matrix initialized to { { 1, 2, 3}, { 4, 5, 6}, ... } , don't waste your time writing this 
initialization code. Just pretend you have a function initlncrementalMatrix(int size). Fill in 
the details later if you need to. 
CrackingTheCodinglnterview.com I 6th Edition 6S"
433,404,"VII I Technical Questions 
Error checks. Some interviewers care a lot about this, while others don't. A good compromise here is to 
add a todo and then just explain out loud what you'd like to test. 
Use other classes/structs where appropriate. If you need to return a list of start and end points fr"
434,498,"StartEndPair (or possibly Range) objects. You don't necessarily have to fill in the details for the class. 
Just pretend it exists and deal with the details later if you have time. 
, Good variable names. Code that uses single-letter variables everywhere is difficult to read. That's not to 
say that"
435,482,"i = startOfChild ( array), there might be a better name for this variable, such as startChild. 
Long variable names can also be slow to write though. A good compromise that most interviewers will 
be okay with is to abbreviate it after the first usage. You can use startChild the first time, and then"
436,477,"Focus on writing beautiful code, whatever that means to you. 
If you see something you can refactor later on, then explain this to your interviewer and decide whether or 
not it's worth the time to do so. Usually it is, but not always. 
If you get confused (which is common), go back to your example "
437,480,"view without testing it either. 
There are smart and not-so-smart ways to test your code though. 
What many candidates do is take their earlier example and test it against their code. That might discover 
bugs, but it'll take a really long time to do so. Hand testing is very slow. If you really did "
438,509,"the end of your code. 
Instead, try this approach: 
1. Start with a ""conceptual""test. A conceptual test means just reading and analyzing what each line of code
does. Think about it like you're explaining the lines of code for a code reviewer. Does the code do what
you think it should do?
2. Weird lo"
439,474,"wrong.
3. Hot spots. You've coded long enough to know what things are likely to cause problems. Base cases
in recursive code. Integer division. Null nodes in binary trees. The start and end of iteration through a
linked list. Double check that stuff.
4. Small test cases. This is the first time we us"
440,213,"the same bugs, but it will be much faster to do so.
5. Special cases. Test your code against null or single element values, the extreme cases, and other special
cases.
66 Cracking the Coding Interview, 6th Edition"
441,460,"VII I Technical Questions 
When you find bugs (and you probably will), you should of course fix them. But don't just make the first 
correction you think of. Instead, carefully analyze why the bug occurred and ensure that your fix is the best 
one. 
� Optimize & Solve Technique #1: Look for BUD 
Thi"
442,492,".B.ottlenecks 
• _!J_nnecessary work
• J2uplicated work
These are three of the most common things that an algorithm can ""waste""time doing. You can walk through 
your brute force looking for these things. When you find one of them, you can then focus on getting rid of it. 
If it's still not optimal, "
443,506,"this occurs: 
• You have one-time work that slows down your algorithm. For example, suppose you have a two-step
algorithm where you first sort the array and then you find elements with a particular property. The first
step is O(N log N) and the second step isO(N). Perhaps you could reduce the second"
444,447,"You have a chunk of work that's done repeatedly, like searching. Perhaps you can reduce that from O( N) 
to O(log N) or even 0(1 ). That will greatly speed up your overall runtime. 
Optimizing a bottleneck can make a big difference in your overall runtime. 
I 
Example: Given an array of distinct int"
445,496,"k = 2,there are four pairs with difference2: (1, 3), (3, 5), (5, 7), (7, 9). 
A brute force algorithm is to go through the array, starting from the first element, and then search through 
the remaining elements (which will form the other side of the pair). For each pair, compute the difference. 
If "
446,471,"focus on optimizing. 
How can we more quickly find the right ""other side""? Well, we actually know the other side of ( x, ? ) . It's 
x + k or x - k. If we sorted the array, we could find the other side for each of the N elements in O( log 
N) time by doing a binary search.
We now have a two-step alg"
447,206,"We just have to get rid of the first step entirely and operate on an unsorted array. How can we find things 
quickly in an unsorted array? With a hash table. 
CrackingTheCodinglnterview.com I 6th Edition 67"
448,506,"VII I Technical Questions 
Throw everything in the array into the hash table. Then, to look up if x + k or x - k exist in the array, we 
just look it up in the hash table. We can do this in O(N) time. 
Unnecessary Work 
I 
Example: Print all positive integer solutions to the equation a3 + b 3 
and d"
449,496,"3 for b from 1 to n 
4 for c from 1 to n 
S ford from 1 to n 
6 if a3 + b 3 == c3 + d3 
7 print a, b, c, d 
c3 + d 3 where a, b, c, 
This algorithm iterates through all possible values of a, b, c, and d and checks if that combination happens 
to work. 
It's unnecessary to continue checking for other"
450,508,"3 for b from 1 to n 
4 for c from 1 to n 
S ford from 1 to n 
G if a3 + b 3 == c3 + d3 
7 print a, b, c, d 
8 break// break out of d's loop 
This won't make a meaningful change to the runtime-our algorithm is still O(N4)-but it's still a good, 
quick fix to make. 
Is there anything else that is unne"
451,419,"3 
• 
1 n = 1000 
2 for a from 1 to n 
3 for b from 1 to n 
4 for c from 1 to n 
5 d = pow(a3 + b 3 - c3, 1/3) // Will round to int 
6 if a3 + b 3 == c3 + d3 / / Validate that the value works 
7 print a, b, c, d 
The if statement on line 6 is important. Line 5 will always find a value for d, but we "
452,330,"Duplicated Work 
Using the same problem and brute force algorithm as above, let's look for duplicated work this time. 
The algorithm operates by essentially iterating through all (a, b) pairs and then searching all ( c, d) 
pairs to find if there are any matches to that (a, b) pair. 
68 Cracking the"
453,468,"VII I Technical Questions 
Why do we keep on computing all ( c, d) pairs for each (a, b) pair?We should just create the list of ( c, 
d) pairs once. Then, when we have an (a, b) pair, find the matches within the ( c, d) list. We can quickly
locate the matches by inserting each ( c, d) pair into a ha"
454,489,"2 for c from 1 to n 
3 ford from 1 to n 
4 result = c 3 + d' 
5 append (c, d) to list at value map[result] 
6 for a from 1 to n 
7 for b from 1 to n 
8 result = a' + b 3 
9 list= map.get(result) 
10 for each pair in list 
11 print a, b, pair 
Actually, once we have the map of all the ( c, d) pairs, "
455,418,"2 for c from 1 to n 
3 ford from 1 to n 
4 result = c 3 + d3 
5 append (c, d) to list at value map[result] 
6 
7 for each result, list in map 
8 for each pairl in list 
9 for each pair2 in list 
10 print pairl, pair2 
This will take our runtime to O(N2). 
� Optimize & Solve Technique #2: DIY (Do It "
456,434,"you probably didn't jump to, ""Ah ha! We'll compare the target element to the midpoint and then recurse on 
the appropriate half' 
And yet, you could give someone who has no knowledge of computer science an alphabetized pile of 
student papers and they'll likely implement something like binary search"
457,423,"random paper in the middle(ish), compare the name to ""Peter Smith'; and then continue this process on the 
remainder of the papers. Although they have no knowledge of binary search, they intuitively ""get it:' 
Our brains are funny like this. Throw the phrase ""Design an algorithm"" in there and people"
458,445,"parallel (e.g., a pile of papers)-and their intuition gives them a very nice algorithm. 
I've seen this come up countless times with candidates. Their computer algorithm is extraordinarily slow, 
but when asked to solve the same problem manually, they immediately do something quite fast. (And it's 
"
459,222,"you put yourself through extra work?) 
Therefore, when you get a question, try just working it through intuitively on a real example. Often a bigger 
example will be easier. 
CrackingTheCodinglnterview.com J 6th Edition 69"
460,444,"VII I Technical Questions 
I 
Example: Given a smaller strings and a bigger string b, design an algorithm to find all permuta­
tions of the shorter string within the longer one. Print the location of each permutation. 
Think for a moment about how you'd solve this problem. Note permutations are rear"
461,493,"other characters). 
If you're like most candidates, you probably thought of something like: Generate all permutations of s and 
then look for each in b. Since there are S! permutations, this will take O ( S ! * B) time, where S is the length 
of s and B is the length of b. 
This works, but it's an e"
462,469,"more permutations. Ouch! 
Approached a different way, you could develop a decent algorithm fairly easily. Give yourself a big example, 
like this one: 
s: abbc 
b: cbabadcbbabbcbabaabc cbabc 
Where are the permutations of s within b? Don't worry about how you're doing it. Just find them. Even a 12 
"
463,510,"b: cbabadcbbabbcbabaabccbabc 
Did you find these? How? 
Few people-even those who earlier came up with the 0(5 ! * B) algorithm-actually generate all the 
permutations of abbc to locate those permutations in b. Almost everyone takes one of two (very similar) 
approaches: 
1. Walk through b and look "
464,510,"are a permutation of s.
Depending on the exact implementation of the ""is this a permutation"" part, you'll probably get a runtime of 
eitherO(B * S),O(B *Slog S),orO(B * 52).None of these are the most optimal algorithm(there 
is an 0( B) algorithm), but it's a lot better than what we had before. 
Try"
465,406,"your own approach. 
Be particularly aware of any""optimizations""you intuitively or automatically made. For example, when you 
were doing this problem, you might have just skipped right over the sliding window with ""d"" in it since 
""d"" isn't in abbc. That's an optimization your brain made, and it's so"
466,480,"VII I Technical Questions 
� Optimize & Solve Technique #3: Simplify and Generalize 
With Simplify and Generalize, we implement a multi-step approach. First we simplify or tweak some 
constraint, such as the data type. Then, we solve this new simplified version of the problem. Finally, once we 
have"
467,458,"sentence. How would you figure out if a ransom note (represented as a string) can be formed 
from a given magazine (string)? 
To simplify the problem, we can modify it so that we are cutting characters out of a magazine instead of 
whole words. 
We can solve the simplified ransom note problem with c"
468,471,"character in the ransom note appears, and then we go through the magazine to see if we have all of those 
characters. 
When we generalize the algorithm, we do a very similar thing. This time, rather than creating an array with 
character counts, we create a hash table that maps from a word to its fr"
469,460,"from there. When we get to more complex/interesting cases (often n = 3 or n = 4), we try to build those 
using the prior solutions. 
I 
Example: Design an algorithm to print all permutations of a string. For simplicity, assume all char­
acters are unique. 
Consider a test string abcdefg. 
Case ""a"" -"
470,454,"Well, the additional letter is ""c,"" so we can just stick c in at every possible point. That is: 
P(""abc"") 
P(""abc"") 
P(""abc"") 
P(""abc"") 
insert ""c"" into all locations of all strings in P(""ab"") 
insert ""c"" into all locations of all strings in {""ab"",""ba""} 
merge({""cab"", """"acb"", ""abc""}, {""cba"", abca"", "
471,399,"tations of a string s1 ••• sn by ""chopping off"" the last character and generating all permutations of s1 •••
sn_1. Once we have the list of all permutations of s1 ••• sn_1, we iterate through this list. For each string in it, 
we insert Sn into every location of the string. 
Base Case and Build algo"
472,451,"VII I Technical Questions 
� Optimize & Solve Technique #5: Data Structure Brainstorm 
This approach is certainly hacky, but it often works. We can simply run through a list of data structures and 
try to apply each one. This approach is useful because solving a problem may be trivial once it occurs"
473,478,"you keep track of the median? 
Our data structure brainstorm might look like the following: 
Linked list? Probably not. Linked lists tend not to do very well with accessing and sorting numbers. 
• Array? Maybe, but you already have an array. Could you somehow keep the elements sorted? That's
probabl"
474,490,"tree is perfectly balanced, the top might be the median. But, be careful-if there's an even number of
elements, the median is actually the average of the middle two elements. The middle two elements can't
both be at the top. This is probably a workable algorithm, but let's come back to it.
Heap? A h"
475,456,"elements. The bigger half is kept in a min heap, such that the smallest element in the bigger half is at
the root. The smaller half is kept in a max heap, such that the biggest element of the smaller half is at the
root. Now, with these data structures, you have the potential median elements at the "
476,477,"heap and pushing it onto the other. 
Note that the more problems you do, the more developed your instinct on which data structure to apply 
will be. You will also develop a more finely tuned instinct as to which of these approaches is the most useful. 
� Best Conceivable Runtime (BCR) 
Considering t"
477,505,"having. You can easily prove that there is no way you could beat the BCR. 
For example, suppose you want to compute the number of elements that two arrays (of length A and B) 
have in common. You immediately know that you can't do that in better than O ( A + B) time because you 
have to ""touch"" each"
478,500,"0 ( N2) time because there are N2 pairs to print. 
Be careful though! Suppose your interviewer asks you to find all pairs with sum k within an array (assuming 
all distinct elements). Some candidates who have not fully mastered the concept of BCR will say that the 
BCR is O(N2 ) because you have to "
479,509,"I 
VII I Technical Questions 
What's the relationship between the Best Conceivable Runtime and Best Case Runtime? Nothing 
at all! The Best Conceivable Runtime is for a problem and is largely a function of the inputs and 
outputs. It has no particular connection to a specific algorithm. In fact, if "
480,422,"value). 
Note that the best conceivable runtime is not necessarily achievable, It says only that you can't do better
than it. 
An Example of How to Use BCR 
Question: Given two sorted arrays, find the number of elements in common. The arrays are the same length 
and each has all distinct elements. 
"
481,463,"A: 13 27 35 40 49 55 59 
B: 17 35 39 40 55 58 60 
A brute force algorithm for this problem is to start with each element in A and search for it in B. This takes 
O ( N2) time since for each of N elements in A, we need to do an O ( N) search in B. 
The BCR is O ( N), because we know we will have to l"
482,486,"if we never looked at the last value in B, then that 60 could be a 59.) 
Let's think about where we are right now. We have an O(N2) algorithm and we want to do better than 
that-potentially, but not necessarily, as fast as O(N ). 
Brute Force: O(N2) 
Optimal Algorithm: ? 
BCR: O(N) 
What is between "
483,421,"runtime doesn't come up a whole lot. 
I 
Try to remember this for your interview because it throws a lot of people off. Runtime is not a 
multiple choice question. Yes, it's very common to have a runtime that's O(log N), O(N), O(N 
log N), 0( N2 ) or 0( 2N). But you shouldn't assume that something h"
484,441,"so you want to take a guess-those are the times when you're most likely to have a non-obvious 
and less common runtime. Maybe the runtime is 0( N2K), where N is the size of the array and K is 
the number of pairs. Derive, don't guess. 
Most likely, we're driving towards an O(N) algorithm or an O(N l"
485,230,"mean reducing that second O(N) in the equation to 0(1) or 0( log N). 
I 
This is one way that BCR can be useful. We can use the runtimes to get a ""hint"" for what we need 
to reduce. 
CrackingTheCodinglnterview.com / 6th Edition 73"
486,454,"Vil / Technical Questions
That second 0( N) comes from searching. The array is sorted. Can we search in a sorted array in faster than 
O(N) time? 
Why, yes. We can use binary search to find an element in a sorted array in 0( log N) time. 
We now have an improved algorithm: 0 ( N log N). 
Brute Force"
487,436,"In general, we cannot search an array-even a sorted array-in better than 0( log N) time. This is not the 
general case though. We're doing this search over and over again. 
The BCR is telling us that we will never, ever have an algorithm that's faster than O ( N). Therefore, any work 
we do in 0( N)"
488,508,"One of the tips there suggests precomputing or doing upfront work. Any upfront work we do in O(N) time 
is a freebie. It won't impact our runtime. 
I 
This is another place where BCR can be useful. Any work you do that's less than or equal to the 
BCR is ""free;' in the sense that it won't impact you"
489,501,"""free:' 
In this case, we can just throw everything in B into a hash table. This will take O ( N) time. Then, we just go 
through A and look up each element in the hash table. This look up (or search) is 0(1), so our runtime is 
O(N). 
Suppose our interviewer hits us with a question that makes us cr"
490,499,"I 
This is another place where BCR is useful. It tells us that we're ""done"" in terms of optimizing the 
runtime, and we should therefore turn our efforts to the space complexity. 
In fact, even without the interviewer prompting us, we should have a question mark with respect to our 
algorithm. We wo"
491,394,"Let's turn back to our example. 
A: 13 27 35 40 49 55 59 
B: 17 35 39 40 55 58 60 
We're now looking for an algorithm that: 
• Operates in 0(1) space (probably). We already have an O(N) space algorithm with optimal runtime. If
we want to use less additional space, that probably means no additional s"
492,462,"VII I Technical Questions
• Operates in o ( N) time (probably). We'll probably want to at least match the current best runtime, and
we know we can't beat it.
• Uses the fact that the arrays are sorted.
Our best algorithm that doesn't use extra space was the binary search one. Let's think about optim"
493,456,"2. Do a binary search in B for A [ 1] = 27. Not found.
3. Do a binary search in B for A[ 2] 35. Found at B[l].
4. Do a binary search in B for A[ 3] 40. Found at B [ 5].
5. Do a binary search in B for A[ 4] 49. Not found.
6. 
Think about BUD. The bottleneck is the searching. Is there anything unneces"
494,498,"certainly won't be before 35. 
Each binary search should start where the last one left off. 
In fact, we don't need to do a binary search at all now. We can just do a linear search. As long as the linear 
search in Bi s just picking up where the last one left off, we know that we're going to be oper"
495,451,"3. Do a linear search in B for A[ 2] 35. Start at B[l] 35. Stop atB[l] 35. Found.
4. Do a linear search in B for A[ 3] 40. Start at B [ 2] 39. Stop at B[3] 40. Found.
5. Do a linear search in B for A[ 4] 49.Start atB[3] 40. Stop at B[ 4] = 55. Found.
6 .. .. 
This algorithm is very similar to mergin"
496,506,"I 
This is another way we can use BCR. If you ever reach the BCR and have 0( 1) additional space, 
then you know that you can't optimize the big O time or space. 
Best Conceivable Runtime is not a ""real"" algorithm concept, in that you won't find it in algorithm textbooks. 
But I have found it person"
497,130,"it. Once you do, figuring out the BCR of a problem should take literally seconds. 
CrackingTheCodinglnterview.com I 6th Edition 75"
498,510,"VII I Technical Questions 
� Handling Incorrect Answers 
One of the most pervasive-and dangerous-rumors is that candidates need to get every question right. 
That's not quite true. 
First, responses to interview questions shouldn't be thought of as ""correct"" or ""incorrect:' When I evaluate 
how some"
499,409,"how much help they needed, and how clean was their code. There is a range of factors. 
Second, your performance is evaluated in comparison to other candidates. For example, if you solve a ques­
tion optimally in 15 minutes, and someone else solves an easier question in five minutes, did that person "
500,453,"to get optimal solutions really quickly. But if the questions are hard, then a number of mistakes are expected. 
Third, many-possibly most-questions are too difficult to expect even a strong candidate to immediately 
spit out the optimal algorithm. The questions I tend to ask would take strong candi"
501,494,"of interviews. Everyone else, including the hundreds who got offers, made mistakes. 
� When You've Heard a Question Before 
If you've heard a question before, admit this to your interviewer. Your interviewer is asking you these ques­
tions in order to evaluate your problem-solving skills. If you alr"
502,419,"(And, conversely, you'll get big honesty points if you do reveal this.) 
� The ""Perfect"" Language for Interviews 
At many of the top companies, interviewers aren't picky about languages. They're more interested in how 
well you solve the problems than whether you know a specific language. 
Other com"
503,422,"in a particular language. 
If you're given a choice of languages, then you should probably pick whatever language you're most 
comfortable with. 
That said, if you have several good languages, you should keep in mind the following. 
Prevalence 
It's not required, but it is ideal for your interviewer"
504,294,"Language Readability 
Even if your interviewer doesn't know your programming language, they should hopefully be able to basi­
cally understand it. Some languages are more naturally readable than others, due to their similarity to other 
languages. 
76 Cracking the Coding Interview, 6th Edition"
505,502,"VII I Technical Questions 
For example, Java is fairly easy for people to understand, even if they haven't worked in it. Most people have 
worked in something with Java-like syntax, such as C and C++. 
However, languages such as Scala or Objective C have fairly different syntax. 
Potential Problems "
506,408,"Verbosity 
Some languages are more verbose than others. Java for example is a fairly verbose language as compared 
with Python. Just compare the following code snippets. 
Python: 
1 diet {""left"": 1, ""right"": 2, ""top"": 3, ""bottom"": 4}; 
Java: 
l HashMap<String, Integer> diet new Has hMap<String, Inte"
507,509,"4 diet. put (""top"", 3); 
5 dict.put(""bottom"", 4); 
However, some of the verbosity of Java can be reduced by abbreviating code. I could imagine a candidate 
on a whiteboard writing something like this: 
1 HM<S, I> diet= new HM<S, I>(). 
2 diet. put(""left"", 1); 
3 ""right"", 2 
4 ""top"", 3 
5 ""bottom"", 4"
508,451,"return multiple values from a function. In Java, the same action would require a new class. This can be 
handy for certain problems. 
Similar to the above though, this can be mitigated by just abbreviating code or presuming methods that 
you don't actually have. For example, if one language provides"
509,460,"that needs such a function). You could just assume that the other language has a similar method. 
� What Good Coding Looks Like 
""1 "" -,, .• i,; - •· 
You probably know by now that employers want to see that you write ""good, clean"" code. But what does this 
really mean, and how is this demonstrated "
510,264,"· Efficient: The code should operate as efficiently as possible in terms of both time and space. This ""effi­
ciency"" includes both the asymptotic (big 0) efficiency and the practical, real-life efficiency. That is, a
CrackingTheCodinglnterview.com I 6th Edition 77"
511,469,"VII I Technical Questions 
constant factor might get dropped when you compute the big O time, but in real life, it can very much 
matter. 
• Simple: If you can do something in 10 lines instead of 100, you should. Code should be as quick as
possible for a developer to write.
Readable: A different dev"
512,480,"understandable way. That means that your fancy code that does a bunch of complex bit shifting is not
necessarily good code.
Maintainable: Code should be reasonably adaptable to changes during the life cycle of a product and
should be easy to maintain by other developers, as well as the initial devel"
513,455,"of efficiency to make code more maintainable, and vice versa. 
You should think about these elements as you code during an interview. The following aspects of code are 
more specific ways to demonstrate the earlier list. 
Use Data Structures Generously 
Suppose you were asked to write a function to "
514,460,"number). That is, the expression is a sequence of terms, where each term is simply a constant times an 
exponent. The interviewer also adds that she doesn't want you to have to do string parsing, so you can use 
whatever data structure you'd like to hold the expressions. 
There are a number of diffe"
515,447,"corresponds to the coefficient of the xk term in the expression. This structure is problematic because it 
could not support expressions with negative or non-integer exponents. It would also require an array of 
1000 elements to store just the expression x1000• 
1 int[] sum(double[] expr1, double[] "
516,407,"and exponents. Under this approach, the terms of the expression are stored in any order, but ""matched"" 
such that the ith term of the expression is represented by coefficients [ i] * x exponents[il. 
Under this implementation, if coefficients [ p] = k and exponents [ p] = m, then the pth term is 
kx"
517,353,"to keep track of two arrays for just one expression. Expressions could have ""undefined"" values if the arrays 
were of different lengths. And returning an expression is annoying because you need to return two arrays. 
1 ??? sum(double[] coeffsl, double[] expon1, double[] coeffs2, double[] expon2) { 
"
518,494,"VII I Technical Questions 
Good Implementation 
A good implementation for this problem is to design your own data structure for the expression. 
1 class ExprTerm { 
2 double coefficient; 
3 double exponent; 
4 } 
5 
6 ExprTerm[] sum(ExprTerm[] exprl, ExprTerm[] expr2) { 
7 
8 } 
Some might (and have"
519,498,"and don' t just slop something together in the fastest way possible. 
Appropriate Code Reuse 
Suppose you were asked to write a function to check if the value of a binary number (passed as a string) 
equals the hexadecimal representation of a string. 
An elegant implementation of this problem levera"
520,477,"4 if (nl < 0 I I n2 < 0) { 
5 return false; 
6 } 
7 return nl == n2; 
8 } 
9 
10 int convertFromBase(String number, int base) { 
11 if (base< 2 I I (base> 10 && base!= 16)) return -1; 
12 int value = 0; 
13 for (int i= number.length() - 1; i >= 0; i--) { 
14 int digit = digit ToValue(number.charAt(i"
521,494,"20 } 
21 return value; 
22 } 
23 
24 int digi tToValue(char c) { ... } 
We could have implemented separate code to convert a binary· number and a hexadecimal code, but 
this just makes our code harder to write and harder to maintain. Instead, we reuse code by writing one 
convertFromBase method and "
522,105,"keep the code more maintainable, readable, and testable. 
CrackingTheCodinglnterview.com I 6th Edition 79"
523,499,"VII \ Technical Questions 
Imagine you are writing code to swap the minimum and maximum element in an integer array. You could 
implement it all in one method like this: 
l void swapMinMax(int[] array) { 
2 int minindex = 0; 
3 
4 
5 
G 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 } 
for (int i="
524,506,"if (array[i] > array[maxindex]) { 
maxindex = i; 
} 
} 
int temp= array[minindex]; 
array[minindex] array[maxindex]; 
array[maxindex] = temp; 
Or, you could implement in a more modular way by separating the relatively isolated chunks of code into 
their own methods. 
1 void swapMinMaxBetter(int[] ar"
525,499,"8 int getMaxindex(int[] array) { ... } 
9 void swap(int[] array, int m, int n) { ... } 
While the non-modular code isn't particularly awful, the nice thing about the modular code is that it's easily 
testable because each component can be verified separately. As code gets more complex, it becomes 
i"
526,486,"Flexible and Robust 
Just because your interviewer only asks you to write code to check if a normal tic-tac-toe board has a 
winner, doesn't mean you must assume that it's a 3x3 board. Why not write the code in a more general way 
that implements it for an NxN board? 
Writing flexible, general-purpo"
527,469,"we should. 
Of course, there is a limit. If the solution is much more complex for the general case, and it seems unneces­
sary at this point in time, it may be better just to implement the simple, expected case. 
Error Checking 
One sign of a careful coder is that she doesn't make assumptions about "
528,510,"VII I Technical Questions 
For example, recall the earlier code to convert a number from its base i (e.g., base 2 or base 16) representa­
tion to an int. 
1 int convertToBase(String number, int base) { 
2 if (base < 2 I I (base > 10 && base != 16)) return -1; 
3 int value = 0; 
4 for (int i= number."
529,421,"10 value += digit * Math.pow(base, exp); 
11 } 
12 return value; 
13 } 
In line 2, we check to see that base is valid (we assume that bases greater than 10, other than base 16, have 
no standard representation in string form). In line 6, we do another error check: making sure that each digit 
falls "
530,421,"Of course, writing these error checks can be tedious and can waste precious time in an interview. The 
important thing is to point out that you would write the checks. If the error checks are much more than a 
quick if-statement, it may be best to leave some space where the error checks would go and"
531,494,"� Don't Give Up! 
I know interview questions can be overwhelming, but that's part of what the interviewer is testing. Do you 
rise to a challenge, or do you shrink back in fear? It's important that you step up and eagerly meet a tricky 
problem head-on. After all, remember that interviews are suppos"
532,409,"VIII 
The Offer and Beyond 
Just when you thought you could sit back and relax after your interviews, now you're faced with the post­
interview stress: Should you accept the offer? Is it the right one? How do you decline an offer? What about 
deadlines? We'll handle a few of these issues here and go"
533,505,"and how to negotiate it. 
� Handling Offers and Rejection 
Whether you're accepting an offer, declining an offer, or responding to a rejection, it matters what you do. 
Offer Deadlines and Extensions 
When companies extend an offer, there's almost always a deadline attached to it. Usually these dead"
534,424,"Declining an Offer 
Even if you aren't interested in working for this company right now, you might be interested in working for it 
in a few years. (Or, your contacts might one day move to a more exciting company.) It's in your best interest 
to decline the offer on good terms and keep a line of com"
535,460,"declining a big company for a startup, you could explain that you feel a startup is the right choice for you 
at this time. The big company can't suddenly ""become"" a startup, so they can't argue about your reasoning. 
Handling Rejection 
Getting rejected is unfortunate, but it doesn't mean that you'"
536,434,"Fortunately, most companies understand that these interviews aren't perfect and many good engineers get 
rejected. For this reason, companies are often eager to re-interview previously rejected candidate. Some 
companies will even reach out to old candidates or expedite their application because of "
537,189,"recruiter for his time, explain that you're disappointed but that you understand their position, and ask when 
you can reapply to the company. 
82 Cracking the Coding Interview, 6th Edition"
538,509,"VIII I The Offer and Beyond 
You can also ask for feedback from the recruiter. In most cases, the big tech companies won't offer feed­
back, but there are some companies that will. It doesn't hurt to ask a question like, ""Is there anything you'd 
suggest I work on for next time?"" 
� Evaluating the O"
539,438,"company is the right fit for you? We'll go through a few things you should consider in evaluating an offer. 
The Financial Package 
Perhaps the biggest mistake that candidates make in evaluating an offer is looking too much at their salary. 
Candidates often look so much at this one number that they"
540,504,"• Signing Bonus, Relocation, and Other One Time Perks: Many companies offer a signing bonus and/or relo­
cation. When comparing offers, it's wise to amortize this cash over three years (or however long you
expect to stay).
• Cost of Living Difference: Taxes and other cost of living differences can m"
541,449,"recruiter might reveal the average annual bonus, but if not, check with friends at the company.
• Stock Options and Grants: Equity compensation can form another big part of your annual compensation.
Like signing bonuses, stock compensation between companies can be compared by amortizing it over
thre"
542,496,"a difference to your long term finances than the salary. Think very carefully about how much emphasis you 
really want to put on money right now. 
Career Development 
As thrilled as you may be to receive this offer, odds are, in a few years, you'll start thinking about inter­
viewing again. Therefor"
543,510,"How good does the company's name look on my resume? 
How much will I learn? Will I learn relevant things? 
What is the promotion plan? How do the careers of developers progress? 
If I want to move into management, does this company offer a realistic plan? 
Is the company or team growing? 
If I do wa"
544,202,"pick from in your city, your career options will be more restricted. Fewer options means that you're less likely 
to discover really great opportunities. 
CrackingTheCodinglnterview.com j 6th Edition 83"
545,461,"VIII I The Offer and Beyond 
Company Stability 
All else being equal, of course stability is a good thing. No one wants to b� fired or laid off. 
However, all else isn't actually equal. The more stable companies are also often growing more slowly. 
How much emphasis you should put on company stabili"
546,452,"better to take the rapidly growing company, even if it's unstable? If you have work visa restrictions or just 
aren't confident in your ability to find something new, stability might be more important. 
The Happiness Factor 
Last but not least, you should of course consider how happy you will be. An"
547,475,"However, for most engineers, there are more important factor, such as who you work with. 
Manager and Teammates: When people say that they love, or hate, their job, it's often because of their 
teammates and their manager. Have you met them? Did you enjoy talking with them? 
• Company Culture: Cultu"
548,407,"• Hours: Ask future teammates about how long they typically work, and figure out if that meshes with your
lifestyle. Remember, though, that hours before major deadlines are typically much longer.
Additionally, note that if you are given the opportunity to switch teams easily (like you are at Google "
549,489,"� Negotiation 
Years ago, I signed up for a negotiations class. On the first day, the instructor asked us to imagine a scenario 
where we wanted to buy a car. Dealership A sells the car for a fixed $20,000-no negotiating. Dealership B 
allows us to negotiate. How much would the car have to be (after"
550,462,"to pay $750 just to avoid having to negotiate for an hour or so. Not surprisingly, in a class poll, most of these 
students also said they didn't negotiate their job offer. They just accepted whatever the company gave 
them. 
Many of us can probably sympathize with this position. Negotiation isn't f"
551,417,"7. Just Do It. Yes, I know it's scary; (almost) no one likes negotiating. But it's so, so worth it. Recruiters will not
revoke an offer because you negotiated, so you have little to lose. This is especially true if the offer is from
a larger company. You probably won't be negotiating with your futur"
552,274,"may not join the company otherwise. If you have alternative options, that will make their concern much
more real.
3. Have a Specific ""Ask"": It's more effective to ask for an additional $7000 in salary than to just ask for""more:'
84 Cracking the Coding Interview, 6th Edition"
553,484,"VIII I The Offer and Beyond 
After all, if you just ask for more, the recruiter could throw in another $1000 and technically have satis­
fied your wishes. 
4. Overshoot: In negotiations, people usually don't agree to whatever you demand. It's a back and forth
conversation. Ask for a bit more than yo"
554,492,"boosting your salary too much could mean that they're paying you more than your peers. Consider
asking for more equity or a bigger signing bonus. Alternatively, you may be able to ask for your reloca­
tion benefits in cash, instead of having the company pay directly for the moving fees. This is a gr"
555,438,"they're right; it is better to negotiate over the phone. However, if you don't feel comfortable on a phone
negotiation, do it via email. It's more important that you attempt to negotiate than that you do it via a
specific medium.
Additionally, if you're negotiating with a big company, you should kno"
556,462,"particularly well-defined system for th is. You can negotiate within the salary range for your level, but going 
beyond that requires bumping up a level. If you're looking for a big bump, you'll need to convince the 
recruiter and your future team that your experience matches this higher level-a dif"
557,418,"join a company, you need to start thinking about your career path. Where will you go from here, and how 
will you get there? 
Set a Timeline 
It's a common story: you join a company, and you're psyched. Everything is great. Five years later, you're still 
there. And it's then that you realize that t"
558,484,"resume. Why didn't you just leave after two years? 
When you're enjoying your job, it's very easy to get wrapped up in it and not realize that your career is not 
advancing. This is why you should outline your career path before starting a new job. Where do you want 
to be in ten years? And what are"
559,450,"By outlining your path in advance and checking in on it regularly, you can avoid falling into this compla­
cency trap. 
Build Strong Relationships 
When you want to move on to something new, your network will be critical. After all, applying online is 
tricky; a personal referral is much better, and"
560,210,"touch with them. Just a friendly note a few weeks after their departure will help to bridge that connection 
from a work acquaintance to a personal acquaintance. 
CrackingTheCodinglnterview.com I 6th Edition 85"
561,412,"VIII I The Offer and Beyond 
This same approach applies to your personal life. Your friends, and your friends of friends, are valuable 
connections. Be open to helping others, and they'll be more likely to help you. 
Ask for What You Want 
While some managers may really try to grow your career, othe"
562,446,"Be (reasonably) frank about your goals with your manager. If you want to take on more back-end coding 
projects, say so. If you'd like to explore more leadership opportunities, discuss how you might be able to 
do so. 
You need to be your best advocate, so that you can achieve goals according to you"
563,314,"your interview skills fresh, and also keep you in tune with what sorts of opportunities (and salaries) are out 
there. 
If you get an offer, you don't have to take it. It will still build a connection with that company in case you 
want to join at a later date. 
86 Cracking the Coding Interview, 6th"
564,491,"1 
Arrays and Strings 
H
opefully, all readers of this book are familiar with arrays and st�ings, so we won't .bore you with such
details. Instead, we'll focus on some of the more common techniques and issues with these data struc­
tures. 
Please note that array questions and string questions are of"
565,489,"� Hash Tables 
A hash table is a data structure that 
maps keys to values for highly efficient lookup. There are a number of 
ways of implementing this. Here, we will describe a simple but common implementation. 
In this simple implementation, we use an array of linked lists and a hash code function"
566,431,"Note that two different keys
could have the same hash code, as there may be an infinite number of keys and a finite number of ints.
2. Then, map the hash code to an index in the array. This could be done with something like hash (key)
% array_length. Two different hash codes 
could, of course, map t"
567,469,"linked list because of collisions: you could have two different keys with the same hash code, or two different
hash codes that map to the same index.
To retrieve the value pair by its key, you repeat this process. Compute the hash code from the key, and then 
compute the index from the hash code. Th"
568,245,"However, we generally assume a good implementation that keeps collisions to a minimum, in 
which case 
the lookup time is 0( 1). 
""aa""---..897 
""qs""---..897--- ..... 1 
""pl""�63 
88 Cracking the Coding Interview, 6th Edition 
4 
hi abc 
aa qs 
pl"
569,477,"Chapter 1 I Arrays and Strings 
Alternatively, we can implement the hash table with a balanced binary search tree. This gives us an O( log N) 
lookup time. The advantage of this is potentially using less space, since we no longer allocate a large array. We 
can also iterate through the keys in order"
570,464,"grow as you append items. In other languages, like Java, arrays are fixed length. The size is defined when 
you create the array. 
When you need an array-like data structure that offers dynamic resizing, you would usually use an Arraylist. 
An Arraylist is an array that resizes itself as needed whil"
571,499,"rarely that its amortized insertion time is still O ( 1). 
1 Arraylist<String> merge(String[] words, String[] more) { 
2 Arraylist<String> sentence= new Arraylist<String>(); 
3 for (String w: words) sentence.add(w); 
4 for (String w: more) sentence.add(w); 
5 return sentence; 
6 } 
This is an essent"
572,465,"as the ""resizing factor"" (which is 2 in Java) can vary. 
Why is the amortized insertion runtime 0(1)? 
Suppose you have an array of size N. We can work backwards to compute how many elements we copied 
at each capacity increase. Observe that when we increase the array to K elements, the array was pr"
573,465,"previous capacity increase: n/4 elements to copy 
previous capacity increase: n/8 elements to copy 
previous capacity increase: n/16 elements to copy 
second capacity increase 2 elements to copy 
first capacity increase 1 element to copy 
Therefore, the total number of copies to insert N elements is"
574,465,"walk to the store. You walk 0.5 kilometers, and then 0.25 kilometers, and then 0.125 kilometers, 
and so on. You will never exceed one kilometer (although you'll get very close to it). 
Therefore, inserting N elements takes O(N) work total. Each insertion is 0(1) on average, even though 
some insert"
575,160,"be? For simplicity, assume that the strings are all the same length (call this x) and that there are n strings. 
CrackingTheCodinglnterview.com I 6th Edition 89"
576,505,"Chapter 1 I Arrays and Strings 
1 String joinWords(String[] words) { 
2 String sentence = """"; 
3 for (String w: words) { 
4 sentence = sentence + w; 
5 } 
6 return sentence; 
7 } 
On each concatenation, a new copy of the string is created, and the two strings are copied over, character 
by character"
577,434,"This reduces toO(xn2). 
I 
Why is itO(xn2)?Because1 + 2 + ... + ne quals n(n+1)/2,orO(n2 ). 
StringBuilder can help you avoid.this problem. StringBuilder simply creates a resizable array of all 
the strings, copying them back to a string only when necessary. 
1 String joinWords(String[] words) { 
2 "
578,505,"4 sentence.append(w); 
5 } 
6 return sentence.toString(); 
7 } 
A good exercise to practice strings, arrays, and general data structures is to implement your own version of 
StringBuilder, HashTable and Array List. 
Additional Reading: Hash Table Collision Resolution (pg 636), Rabin-Karp Substring S"
579,510,"Hints: #44, #7 7 7, #732 
1.2 Check Permutation: Given two strings, write a method to decide if one is a permutation of the 
other. 
Hints: #7, #84, #722, #737 
_pg 193 
1.3 URLify: Write a method to replace all spaces in a string with '%20'. You may assume that the string 
has sufficient space at t"
580,165,"perform this operation in place.) 
EXAMPLE 
Input: ""Mr John Smith "", 13 
Output: ""Mr%20John%20Smith"" 
Hints: #53, # 118
90 Cracking the Coding Interview, 6th Edition"
581,458,"Chapter 1 I Arrays and Strings 
1.4 Palindrome Permutation: Given a string, write a function to check if it is a permutation of a palin­
drome. A palindrome is a word or phrase that is the same forwards and backwards. A permutation 
is a rearrangement of letters. The palindrome does not need to be l"
582,464,"Hints: #106, #121, #134, #136 
One Away: There are three types of edits that can be performed on strings: insert a character, 
remove a character, or replace a character. Given two strings, write a function to check if they are 
one edit (or zero edits) away. 
EXAMPLE 
pale, ple -> true 
pales, pale"
583,505,"of repeated characters. For example, the string aabcccccaaa would become a2blc5a3. If the 
""compressed"" string would not become smaller than the original string, your method should return 
the original string. You can assume the string has only uppercase and lowercase letters (a - z). 
Hints:#92, #1"
584,468,"Hints: #51, # 100 
1.8 Zero Matrix: Write an algorithm such that if an element in an MxN matrix is 0, its entire row and 
column are set to 0. 
Hints:#17, #74, #702 
1.9 String Rotation:Assumeyou have a method isSubstringwhich checks if one word is a substring 
of another. Given two strings, sl and "
585,320,"Hints: #34, #88, # 7 04 
206 
Additional Questions: Object-Oriented Design (#7.12). Recursion (#8.3), Sorting and Searching (#10.9), C++ 
(#12.11 ), Moderate Problems (#16.8, #16.17, #16.22), Hard Problems (#17.4, #17.7, #17.13, #17.22, #17.26). 
Hints start on page 653. 
CrackingTheCodinglnterview."
586,426,"2 
Linked Lists 
A
linked list is a data structure that represents a sequence of nodes. In a singly linked list, each node
points to the next node in the linked list. A doubly linked list gives each node pointers to both the next 
node and the previous node. 
The following diagram depicts a doubly l"
587,504,"particular ""index"" within the list. 
This means that if you'd like to find the Kth element in the list, you will need to iterate through K elements. 
The benefit of a linked list is that you can add and remove items from the beginning of the list in constant 
time. For specific applications, this ca"
588,423,"4 
5 
6 
7 
8 
9 
public Node(int d) { 
data= d; 
} 
10 
void appendToTail(int d) { 
Node end= new Node(d); 
Node n = this; 11 
12 
13 
14 
15 
16 
17 } 
while (n.next != null) { 
n = n.next; 
} 
n.next = 
end;
In this implementation, we don't have a Linked List data structure. We access the linked "
589,285,"When you implement the linked list this way, you need to be 
a bit careful. What if multiple objects need a reference to the linked list, and then the head of the linked list 
changes? Some objects might still be pointing to the old head. 
92 Cracking the Coding Interview, 6th Edition"
590,421,"Chapter 2 I Linked Lists 
We could, if we chose, implement a Linked List class that wraps the Node class. This would essentially 
just have a single member variable: the head Node. This would largely resolve the earlier issue. 
Remember that when you're discussing a linked list in an interview, you "
591,417,"� Deleting a Node from a Singly Linked List 
Deleting a node from a linked list is fairly straightforward. Given a node n, we find the previous node prev 
and set prev. next equal to n. next. If the list is doubly linked, we must also update n. next to set 
n. next. prev equal to n. prev. The import"
592,497,"and (2) to update the head or tail pointer as necessary.
Additionally, if you implement this code in C, C++ or another language that requires the developer to do 
memory management, you should consider if the removed node should be deallocated. 
1 Node deleteNode(Node head, int d) { 
2 Node n = head"
593,475,"11 return head; /* head didn't change*/
12 } 
13 n = n.next; 
14 } 
15 return head; 
16 } 
� The ""Runner""Technique 
The ""runner"" (or second pointer) technique is used in many linked list problems. The runner technique 
means that you iterate through the linked list with two pointers simultaneously, "
594,407,"one node that the ""slow"" node iterates through. 
For example, suppose you had a linked list a1 ->a2 -> ••• ->an ->b1 ->b2 -> ••• ->bn and you wanted to 
rearrange it into a1 ->b1 ->a2 ->b2 -> ••• ->an ->bn. You do not know the length of the linked list (but you 
do know that the length is an even nu"
595,476,"makes. When pl hits the end of the linked list, p2 will be at the midpoint. Then, move pl back to the front 
and begin ""weaving""the elements. On each iteration, p2 selects an element and inserts it after pl. 
� Recursive Problems 
A number of linked list problems rely on recursion. If you're having "
596,74,"chapter is devoted to it. 
CrackingTheCodinglnterview.com J 6th Edition 93"
597,509,"Chapter 2 I Linked Lists 
However, you should remember that recursive algorithms take at least O ( n) space, where n is the depth 
of the recursive call. All recursive algorithms can be implemented iteratively, although they may be much 
more complex. 
Interview Questions 
2.1 R�mov� Dups! Write cod"
598,473,"................................................... pg208 
2.2 Return Kth to Last: Implement an algorithm to find the kth to last element of a singly linked list. 
Hints:#8, #25, #41, #67, #126
2.3 Delete Middle Node: Implement an algorithm to delete a node in the middle (i.e., any node but 
the fir"
599,434,"EXAMPLE 
lnput:the node c from the linked lista->b->c->d->e->f 
Result: nothing is returned, but the new linked list looks like a->b->d->e->f 
Hints:#72 
•--
---""•·•m.�---··� ••••••••••••••••••••• ••··�·-''""•-�mm••·*'9
2.4 Partition: Write code to partition a linked list around a value x, such 
that"
600,358,"to be after the elements less than x (see below). The partition element x can appear anywhere in the 
""right partition""; it does not need to appear between the left and right partitions. 
EXAMPLE 
Input: 
Output: 
3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1 [partition= 5] 
3 -> 1 -> 2 -> 10 -> 5 -> 5 -> 8 
Hin"
601,504,"Chapter 2 I Linked Lists 
2.5 Sum Lists: You have two numbers represented by a linked list, where each node contains a single 
digit. The digits are stored in reverse order, such that the 1 's digit is at the head of the list. Write a 
function that adds the two numbers and returns the sum as a link"
602,454,"EXAMPLE 
lnput:(6 -> 1 -> 7) + (2 -> 9 -> 5).That is,617 + 295. 
Output: 9 -> 1 -> 2. That is, 912. 
Hints: #7, #30, #71, #95, #109 
2.6 Palindrome: Implement a function to check if a linked list is a palindrome. 
Hints:#5, #13, #29, #61, #101 
2.7 Intersection: Given two (singly) linked lists, dete"
603,488,"node of the first linked list is the exact same node (by reference) as the jth node of the second 
linked list, then they are intersecting. 
Hints:#20, #45, #55, #65, #76, #93, #111, #120, #129 
2.8 Loop Detection: Given a circular linked list, implement an algorithm that returns the node at the 
be"
604,390,"as to make a loop in the linked list. 
EXAMPLE 
Input: A -> B -> C -> D -> E -> C [the same C as earlier] 
Output: C 
Hints: #50, #69, #83, #90 
Additional Questions: Trees and Graphs (#4.3), Object-Oriented Design (#7.12), System Design and Scal­
ability (#9.5), Moderate Problems (#16.25), Hard Pro"
605,455,"3 
Stacks and Queues 
Q
uestions on stacks and queues will be much easier to handle if you are comfortable with the ins and 
outs of the data structure. The problems can be quite tricky, though. While some problems may be 
slight modifications on the original data structure, others have much more co"
606,461,"be favorable to store data in a stack rather than in an array. 
A stack uses LIFO (last-in first-out) ordering. That is, as in a stack of dinner plates, the most recent item 
added to the stack is the first item to be removed.
It uses the following operations: 
pop ( 
) : Remove the top item from th"
607,505,"is Empty (): Return true if and only if the stack is empty. 
Unlike an array, a stack does not offer constant-time access to the i th item. However, it does allow constant­
time adds and removes, as it doesn't require shifting elements around. 
We have provided simple sample code to implement a stac"
608,333,"2 private static class StackNode<T> { 
3 private T data; 
4 private StackNode<T> next; 
5 
6 public StackNode(T data) { 
7 this.data = data; 
8 } 
9 } 
16 
11 private StackNode<T> top; 
12 
13 public T pop() { 
14 if (top == null) throw new EmptystackException(); 
15 T item = top.data; 
96 Cracking "
609,480,"15 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
} 
top= top.next; 
return item; 
public void push(T item) { 
} 
StackNode<T> t = new StackNode<T>(item); 
t.next = top;
top= t;
public T peek() { 
Chapter 3 I Stacks and Queues 
27 
28 
if (top== null) throw new EmptyStackExc eption(); 
return top.data; 
2"
610,474,"temporary data onto a stack as you recurse, but then remove them as you backtrack (for example, because 
the recursive check failed). A stack offers an intuitive way to do this. 
A stack can also be used to implement a recursive algorithm iteratively. (This is a good exercise! Take a 
simple recursi"
611,484,"removed from the data structure in the same order that they are added. 
It uses the operations: 
add ( i tern): Add an item to the end of the list. 
remove (): Remove the first item in the list. 
peek ( ) : Return the top of the queue. 
is Empty(): Return true if and only if the queue is empty. 
A q"
612,328,"1 public class MyQueue<T> { 
2 private static class QueueNode<T> { 
3 private T data; 
4 private QueueNode<T> next; 
5 
6 public QueueNode(T data) {
7 this.data = data; 
8 } 
9 } 
10 
11 private QueueNode<T> first; 
12 private QueueNode<T> last; 
13 
14 public void add(T item) { 
CrackingTheCodingln"
613,476,"Chapter 3 I Stacks and Queues 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 } 
} 
QueueNode<T> t = new QueueNode<T>(item); 
if (last != null) { 
last.next= t; 
} 
last = t; 
if (first== null) { 
first= last; 
} 
public T remove() "
614,500,"last = null; 
} 
return data; 
public T peek() { 
} 
if (first== null) throw new NoSuchElementException(); 
return first.data; 
public boolean isEmpty() { 
return first== null; 
} 
It is especially easy to mess up the updating of the first and last nodes in a queue. Be sure to double check 
this. 
O"
615,495,"Each time we process a node, we add its adjacent nodes to the back of the queue. This allows us to process 
nodes in the order in which they are viewed. 
Interview Questions 
3.1 Three in One: Describe how you could use a single array to implement three stacks. 
Hints: #2, #72, #38, #58 
3.2 Stack M"
616,66,"Hints:#27, #59, #78 
98 Cracking the Coding Interview, 6th Edition"
617,508,"Chapter 3 I Stacks and Queues 
3.3 Stack of Plates: Imagine a (literal) stack of plates. If the stack gets too high, it might topple. 
Therefore, in real life, we would likely start a new stack when the previous stack exceeds some 
threshold. Implement a data structure SetOfStacks that mimics this. "
618,492,"(that is, pop () should return the same values as it would if there were just a single stack). 
FOLLOW UP 
Implement a function popAt ( int index) which performs a pop operation on a specific sub-stack. 
Hints:#64, #87 
pg233 
3.4 Queue via Stacks: Implement a MyQueue class which implements a queue "
619,412,"an additional temporary stack, but you may not copy the elements into any other data structure 
(such as an array). The stack supports the following operations: push, pop, peek, and is Empty. 
Hints:# 15, #32, #43 
.... ........................... .............................................. P9 23"
620,486,"out"" basis. People must adopt either the ""oldest"" (based on arrival time) of all animals at the shelter, 
or they can select whether they would prefer a dog or a cat (and will receive the oldest animal of 
that type). They cannot select which specific animal they would like. Create the data structur"
621,250,"Hints: #22, #56, #63 
........... .................. ... ................ pg 239 
Additional Questions: Linked Lists (#2.6), Moderate Problems (#16.26), Hard Problems (#17.9). 
Hints start on page 653. 
CrackingTheCodinglnterview.com I 6th Edition 99"
622,420,"4 
Trees and Graphs 
M
any interviewees find tree and graph problems to be some of the trickiest. Searching a tree is more 
complicated than searching in a linearly organized data structure such as an array or linked list. Addi­
tionally, the worst case and average case time may vary wildly, and we "
623,433,"Because most people are more familiar with trees than graphs (and they're a bit simpler), we'll discuss trees 
first. This is a bit out of order though, as a tree is actually a type of graph. 
I
Note: Some of the terms in this chapter can vary slightly across different textbooks and other 
sources. "
624,433,"with your interviewer. 
� Types of Trees 
A nice way to understand a tree is with a recursive explanation. A tree is a data structure composed of 
nodes. 
Each tree has a root node. (Actually, this isn't strictly necessary in graph theory, but it's usually how we 
use trees in programming, and espec"
625,469,"Each child node has zero or more child nodes, and so on. 
The tree cannot contain cycles. The nodes may or may not be in a particular order, they could have any data 
type as values, and they may or may not have links back to their parent nodes. 
A very simple class definition for Node is: 
1 class "
626,192,"do not use a Tree class. You can if you feel it makes your code simpler or better, but it rarely does. 
1 class Tree { 
2 public Node root; 
3 } 
100 Cracking the Coding Interview, 6th Edition"
627,508,"Chapter 4 I Trees and Graphs 
Tree and graph questions are rife with ambiguous details and incorrect assumptions. Be sure to watch out 
for the following issues and seek clarification when necessary. 
Trees vs. Binary Trees 
A binary tree is a tree in which each node has up to two children. Not all "
628,432,"using a tree to represent a bunch of phone numbers. In this case, you might use a 10-ary tree, with each 
node having up to 10 children (one for each digit). 
A node is called a ""leaf"" node if it has no children. 
Binary Tree vs. Binary Search Tree 
A binary search tree is a binary tree in which eve"
629,417,"I
The definition of a binary search tree can vary slightly with respect to equality. Under some defi­
nitions, the tree cannot have duplicate values. In others, the duplicate values will be on the right 
or can be on either side. All are valid definitions, but you should clarify this with your inter"
630,476,"following tree on the left below is a binary search tree. The tree on the right is not, since 12 is to the left of 8. 
A binary search tree. Not a binary search tree. 
When given a tree question, many candidates assume the interviewer means a binary search tree. Be sure 
to ask. A binary search tree"
631,330,"Balanced vs. Unbalanced 
While many trees are balanced, not all are. Ask your interviewer for clarification here. Note that balancing a 
tree does not mean the left and right subtrees are exactly the same size (like you see under ""perfect binary 
trees"" in the following diagram). 
CrackingTheCodingl"
632,445,"Chapter 4 I Trees and Graphs 
One way to think about it is that a ""balanced"" tree really means something more like ""not terribly imbal­
anced:' It's balanced enough to ensure 0( log n) times for insert and find, but it's not necessarily as 
balanced as it could be. 
Two common types of balanced tree"
633,486,"Complete Binary Trees 
A complete binary tree is a binary tree in which every level of the tree is fully filled, except for perhaps the 
last level. To the extent that the last level is filled, it is filled left to right. 
not a complete binary tree a complete binary tree 
Full Binary Trees 
A full "
634,429,"Perfect Binary Trees 
A perfect binary tree is one that is both full and complete. All leaf nodes will be at the same level, and this 
level has the maximum number of nodes. 
Note that perfect trees are rare in interviews and in real life, as a perfect tree must have exactly 2k - 1 nodes 
(where k i"
635,508,"Chapter 4 I Trees and Graphs 
� Binary Tree Traversal 
Prior to your interview, you should be comfortable implementing in-order, post-order, and pre-order 
traversal. The most common of these is in-order traversal. 
In-Order Traversal 
In-order traversal means to ""visit"" (often, print) the left bran"
636,443,"4 visit(node); 
5 inOrderTraversal(node.right); 
6 } 
7 } 
When performed on a binary search tree, it visits the nodes in ascending order (hence the name ""in-order""). 
Pre-Order Traversal 
Pre-order traversal visits the current node before its child nodes (hence the name ""pre-order""). 
1 void preOrd"
637,506,"5 preOrderTraversal(node.right); 
6 } 
7 } 
In a pre-order traversal, the root is always the first node visited. 
Post-Order Traversal 
Post-order traversal visits the current node after its child nodes (hence the name ""post-order""). 
1 void postOrderTraversal(TreeNode node) { 
2 if (node!= null) { "
638,455,"� Binary Heaps (Min-Heaps and Max-Heaps) 
We'll just discuss min-heaps here. Max-heaps are essentially equivalent, but the elements are in descending 
order rather than ascending order. 
A min-heap is a complete binary tree (that is, totally filled other than the rightmost elements on the last 
leve"
639,498,"Chapter 4 I Trees and Graphs 
We have two key operations on a min-heap: insert and extract_min. 
Insert 
When we insert into a min-heap, we always start by inserting the element at the bottom. We insert at the 
rightmost spot so as to maintain the complete tree property. 
Then, we ""fix""the tree by s"
640,407,"Step 1: Insert 2 Step 2: Swap 2 and 7 Step 3: Swap 2 and 4 
This takes O( log n) time, where n is the number of nodes in the heap. 
Extract Minimum Element 
Finding the minimum element of a min-heap is easy: it's always at the top. The trickier part is how to remove 
it. (In fact, this isn't that tr"
641,478,"rightmost element). Then, we bubble down this element, swapping it with one of its children until the min­
heap property is restored. 
Do we swap it with the left child or the right child? That depends on their values. There's no inherent 
ordering between the left and right element, but you'll need"
642,127,".·· ·· , 
This algorithm will also take 0( log n) time. 
104 Cracking the Coding Interview, 6th Edition 
Step 3: Swap 32 and 80"
643,468,"Chapter 4 I Trees and Graphs 
� Tries (Prefix Trees) 
A trie (sometimes called a prefix tree) is a funny data structure. It comes up a lot in interview questions, but 
algorithm textbooks don't spend much time on this data structure. 
A trie is a variant of an n-ary tree in which characters are stor"
644,466,"fact that there is a * node under MANY indicates that MANY is a complete word. The existence of the MA path 
indicates there are words that start with MA. 
The actual implementation of these * nodes might be a special type of child (such as a 
TerminatingTrieNode, which inherits from TrieNode). Or, "
645,435,"ALPHABET _SIZE if a boolean flag is used instead of a* node). 
Very commonly, a trie is used to store the entire (English) language for quick prefix lookups. While a hash 
table can quickly look up whether a string is a valid word, it cannot tell us if a string is a prefix of any valid 
words. A tri"
646,501,"string. This is actually the same runtime as a hash table will take. Although we often refer to hash 
table lookups as being 0(1) time, this isn't entirely true. A hash table must read through all the 
characters in the input, which takes O ( K) time in the case of a word lookup. 
Many problems invo"
647,477,"pass around a reference to the current node in the tree. This will allow us to just check if Y is a child of MAN, 
rather than starting from the root each time. 
� Graphs 
A tree is actually a type of graph, but not all graphs are trees. Simply put, a tree is a connected graph without 
cycles. 
A gr"
648,49,CrackingTheCodinglnterview.com / 6th Edition 1 OS
649,450,"Chapter 4 I Trees and Graphs 
one-way street, undirected edges are like a two-way street. 
• The graph might consist of multiple isolated subgraphs. If there is a path between every pair of vertices,
it is called a ""connected graph:'
The graph can also have cycles (or not). An ""acyclic graph"" is one"
650,470,"Adjacency List 
This is the most common way to represent a graph. Every vertex (or node) stores a list of adjacent vertices. 
In an undirected graph, an edge like (a, b) would be stored twice: once in a's adjacent vertices and once 
in b's adjacent vertices. 
A simple class definition for a graph no"
651,433,"6 public String name; 
7 public Node[] children; 
8 } 
The Graph class is used because, unlike in a tree, you can't necessarily reach all the nodes from a single node. 
You don't necessarily need any additional classes to represent a graph. An array (or a hash table) of lists 
(arrays, arraylists, l"
652,406,"0: 1 
1: 2
2: 0, 3 
3: 2 
4: 6 
5: 4 
6: 5 
This is a bit more compact, but it isn't quite as clean. We tend to use node classes unless there's a compelling 
reason not to. 
Adjacency Matrices 
An adjacency matrix is an NxN boolean matrix (where N is the number of nodes), where a true value at 
matr"
653,169,"1 s.) 
In an undirected graph, an adjacency matrix will be symmetric. In a directed graph, it will not (necessarily) 
be. 
106 Cracking the Coding Interview, 6th Edition"
654,460,"� 
� 
Chapter 4 I Trees and Graphs 
0 0 
0 0 
0 0 0 
0 0 
The same graph algorithms that are used on adjacency lists (breadth-first search, etc.) can be performed 
with adjacency matrices, but they may be somewhat less efficient. In the adjacency list representation, you 
can easily iterate through "
655,461,"� Graph Search 
The two most common ways to search a graph are depth-first search and breadth-first search. 
In depth-first search (DFS), we start at the root (or another arbitrarily selected node) and explore each 
branch completely before moving on to the next branch. That is, we go deep first (he"
656,415,"neighbor before going on to any of their children. That is, we go wide (hence breadth-first search) before 
we go deep. 
See the below depiction of a graph and its depth-first and breadth-first search (assuming neighbors are 
iterated in numerical order). 
Graph Depth-First Search Breadth-First Sear"
657,497,"4 Node 2 4 Node 5 
5 Node 4 5 Node 3 
6 Node 5 6 Node 2 
Breadth-first search and depth-first search tend to be used in different scenarios. DFS is often preferred if we 
want to visit every node in the graph. Both will work just fine, but depth-first search is a bit simpler. 
However, if we want to"
658,430,"ships between Ash and Vanessa. 
In depth-first search, we could take a path like Ash -> Brian -> Car let on -> Davis -> Eric 
-> Farah -> Gayle -> Harry -> Isabella -> John·-> Kari ... and thenfind ourselves very 
far away. We could go through most of the world without realizing that, in fact, Vanes"
659,349,"In breadth-first search, we would stay close to Ash for as long as possible. We might iterate through many 
of Ash's friends, but we wouldn't go to his more distant connections until absolutely necessary. lfVanessa 
is Ash's friend, or his friend-of-a-friend, we'll find this out relatively quickly. "
660,434,"Chapter 4 / Trees and Graphs 
Depth-First Search (DFS) 
In DFS, we visit a node a and then iterate through each of a's neighbors. When visiting a node b that is a 
neighbor of a, we visit all of b's neighbors before going on to a's other neighbors. That is, a exhaustively 
searches b's branch before"
661,510,"implementing this algorithm for a graph, we must check if the node has been visited. If we don't, we risk 
getting stuck in an infinite loop. 
The pseudocode below implements DFS. 
1 void search(Node root) { 
2 if (root== null) return; 
3 visit(root); 
4 root.visited= true; 
5 for each (Node n in ro"
662,499,"familiar with it. The main tripping point is the (false) assumption that BFS is recursive. It's not. Instead, it 
uses a queue. 
In BFS, node a visits each of a's neighbors before visiting any of their neighbors. You can think of this as 
searching level by level out from a. An iterative solution in"
663,508,"5 
6 while (!queue.isEmpty()) { 
7 Node r = queue.dequeue(); // Remove from the front of the queue 
8 visit(r); 
9 foreach (Node n in r.adjacent) { 
10 if (n.marked == false) { 
11 n. marked = true;
12 queue.enqueue(n);
13 } 
14 } 
15 } 
16 } 
If you are asked to implement BFS, the key thing to reme"
664,183,"by essentially running two simultaneous breadth-first searches, one from each node. When their searches 
collide, we have found a path. 
108 Cracking the Coding Interview, 6th Edition"
665,492,"Breadth-First Search 
Single search from s tot that 
collides after four levels. 
Chapter 4 I Trees and Graphs 
Bidirectional Search 
Two searches (one from s and one from t) that 
collide after four levels total (two levels each). 
To see why this is faster, consider a graph where every node has at"
666,403,"second level, we would search up to k nodes for each of those first k nodes, so k2 nodes total (thus far). 
We would do this d times, so that's 0( kd) nodes. 
In bidirectional search, we have two searches that collide after approximately � levels (the midpoint 
of the path). The search from s visits"
667,433,"2 kdl2, or 0( kd/2), nodes total.
This might seem like a minor difference, but it's not. It's huge. Recall that ( kd12) * ( kd12) = kd. The bidirec­
tional search is actually faster by a factor of kd12.
Put another way: if our system could only support searching ""friend of friend"" paths in breadth-f"
668,505,"as long. 
Additional Reading: Topological Sort (pg 632), Dijkstra's Algorithm (pg 633), AVL Trees (pg 637), Red­
BlackTrees (pg 639). 
Interview Questions 
4.1 Route Between Nodes: Given a directed graph, design an algorithm to find out whether there is a 
route between two nodes. 
Hints:#127 
-·-·-"
669,463,"Hints: #79, #73, #7 76 
____ pg242 
4.3 List of Depths: Given a binary tree, design an algorithm which creates a linked list of all the nodes 
at each depth (e.g., if you have a tree with depth D, you'll have D linked lists). 
Hints: #107, #123, #135 
················································"
670,443,"Chapter 4 I Trees and Graphs 
4.4 Check Balanced: Implement a function to check if a binary tree is balanced. For the purposes of 
this question, a balanced tree is defined to be a tree such that the heights of the two subtrees of any 
node never differ by more than one. 
Hints:#27, #33, #49, #705, "
671,469,"Hints: #35, #57, #86, #113, #128 
... ... . pg 
4.6 Successor: Write an algorithm to find the ""next"" node (i.e., in-order successor) of a given node in a 
binary search tree. You may assume that each node has a link to its parent. 
Hints: #79, #91 
.. pg 248 
4.7 Build Order: You are given a list of"
672,411,"must be built before the project is. Find a build order that will allow the projects to be built. If there 
is no valid build order, return an error. 
EXAMPLE 
Input: 
projects: a, b, c, d, e, f 
dependen cies: (a, d), (f, b), (b, d), (f, a), (d, c) 
Output: f, e, a, b, d, c 
Hints: #26, #47, #60, #"
673,510,"of two nodes in a binary tree. Avoid storing additional nodes in a data structure. NOTE: This is not 
necessarily a binary search tree. 
Hints: #70, #76, #28, #36, #46, #70, #80, #96 
...... ...................... ......... .......................... p9 257 
4.9 BST Sequences: A binary search tree w"
674,163,"arrays that could have led to this tree. 
EXAMPLE 
Input: 
Output: {2, 1, 3}, {2, 3, 1} 
Hints: #39, #48, #66, #82 
11 0 Cracking the Coding Interview, 6th Edition"
675,499,"Chapter 4 I Trees and Graphs 
4.1 O Check Subtree: Tl and T2 are two very large binary trees, with Tl much bigger than T2. Create an 
algorithm to determine if T2 is a subtree of Tl. 
A tree T2 is a subtree of Tl if there exists a node n in Tl such that the subtree of n is identical to T2. 
That is,"
676,510,"insert, find, and delete, has a method getRandomNod e() which returns a random node 
from the tree. All nodes should be equally likely to be chosen. Design and implement an algorithm 
for getRandomNode, and explain how you would implement the rest of the methods. 
Hints: #42, #54, #62, #75, #89, #99"
677,483,"given value. The path does not need to start or end at the root or a leaf, but it must go downwards 
(traveling only from parent nodes to child nodes). 
Hints:#6, #14, #52, #68, #77, #87, #94, #103, #108, #115 
Additional Questions: Recursion (#8.10), System Design and Scalability (#9.2, #9.3), Sort"
678,472,"5 
Bit Manipulation 
B
it manipulation is used in a variety of problems. Sometimes, the question explicitly calls for bit manipu­
lation. Other times, it's simply a useful technique to optimize your code. You should be comfortable 
doing bit manipulation by hand, as well as with code. Be careful; it"
679,437,"solved manually or with ""tricks"" (described below). For simplicity, assume that these are four-bit numbers. 
If you get confused, work them through as a base 1 O number. You can then apply the same process to a 
binary number. Remember that /\ indicates an XOR, and= is a NOT (negation). 
0110 + 0010"
680,507,"1000 0110 1101 /\ 0101 1011 & (=0 « 2) 
Solutions: line 1 (1000, 1111, 1100); line 2 (0101, 1001, 1100); line 3 (0011, 0011, 1111 ); line 4 (0010, 1000, 1000). 
The tricks in Column 3 are as follows: 
1. 0110 + 0110 is equivalent to 0110 * 2, which is equivalent to shifting 0110 left by 1.
2. 0100 e"
681,406,"Therefore, the solution to a A( =a) will be a sequence of 1 s.
4. =0 is a sequence of 1 s, so =0 < < 2 is 1 s followed by two Os. AN Ding that with another value will clear
the last two bits of the value.
If you didn't see these tricks immediately, think about them logically. 
� Bit Facts and Tricks"
682,263,"about why each of these is true. We use ""1 s"" and ""Os"" to indicate a sequence of 1 s or Os, respectively. 
X A 0s = X X & 0s
X A 
ls = -x X 
X I\ X = 0 X 
112 Cracking the Coding Interview, 6th Edition 
& ls 
& X 
= 
= 
= 
0 X I 0s = X 
X X I ls = ls 
X X I X = X"
683,434,"Chapter 5 I Bit Manipulation 
To understand these expressions, recall that these operations occur bit-by-bit, with what's happening on 
one bit never impacting the other bits. This means that if one of the above statements is true for a single bit, 
then it's true for a sequence of bits. 
� Two's Co"
684,440,"as itself while a negative number is represented as the two's complement of its absolute value (with a 1 in its 
sign bit to indicate that a negative value). The two's complement of an N-bit number (where N is the number 
of bits used for the number, excluding the sign bit) is the complement of the "
685,476,"bits for the value. We want the complement with respect to 23, which is 8. The complement of 3 (the abso­
lute value of -3) with respect to 8 is 5. 5 in binary is 101. Therefore, -3 in binary as a 4-bit number is 1101, 
with the first bit being the sign bit. 
In other words, the binary representatio"
686,487,"in binary. Flip the bits to get 100, add 1 to get 101, then prepend the sign bit (1) to get 1101. 
In a four-bit integer, this would look like the following. 
7 � 111 -1 1111 
6 � 110 -2 1110 
5 � 101 -3 1101 
4 � 100 -4 1100 
3 � 011 -5 1 011 
2 � 010 -6 1 010 
1 � 001 -7 1 001 
0 � 000 
Observe th"
687,482,"� Arithmetic vs. Logical Right Shift 
There are two types of right shift operators. The arithmetic right shift essentially divides by two. The logical 
right shift does what we would visually see 
as shifting the bits. This is best seen on a negative number. 
In a logical right shift, we shift the b"
688,122,"below. The sign bit is indicated with a gray background. 
1 = -75 
0 =90 
CrackingTheCodinglnterview.com I 6th Edition 113"
689,483,"Chapter 5 I Bit Manipulation 
In an arithmetic right shift, we shift values to the right but fill in the new bits with the value of the sign bit. 
This has the effect of (roughly) dividing by two. It is indicated by a > > operator. 
1 =-75 
0 =-38 
What do you think these functions would do on param"
690,497,"3 x >>= 1; // Arith metic shift by 1 
4 } 
5 return x; 
6 } 
7 
8 int repeatedLogic alShift( int x, int count) { 
9 for (inti= 0; i < count; i++) { 
10 x >>>= 1; // Logical shift by 1 
11 } 
12 return x; 
13 } 
With the logical shift, we would get 0 because we are shifting a zero into the most signi"
691,419,"� Common Bit Tasks: Getting and Setting 
The following operations are very important to know, but do not simply memorize them. Memorizing leads 
to mistakes that are impossible to recover from. Rather, understand how to implement these methods, so 
that you can implement these, and other, bit proble"
692,505,"num, we clear all bits other than the bit at bit i. Finally, we compare that to 0. If that new value is not zero, 
then bit i must have a 1. Otherwise, bit i is a 0. 
1 boolean getBit(int num, inti) { 
2 return (( num & (1 « i)) != 0); 
3 } 
Set Bit 
Set Bit shifts 1 over by i bits, creating a value"
693,108,"1 int setBit(int num, inti) { 
2 return num I (1 « i); 
3 } 
114 Cracking th e Coding Interview, 6th Edition"
694,494,"Chapter 5 I Bit Manipulation 
Clear Bit 
This method operates in almost the reverse of setBi t. First, we create a number like 11101111 by creating 
the reverse of it (00010000) and negating it. Then, we perform an AND with num. This will clear the ith bit 
and leave the remainder unchanged. 
1 int "
695,507,"< < i). Then, we subtract 1 from it, giving us a sequence of 0s followed by i ls. We then AND our number 
with this mask to leave just the last i bits. 
1 int clearBit sMSBthroughI(int num, inti) { 
2 int mask = (1 << i) - 1; 
3 return num & mask; 
4 } 
To clear all bits from i through 0 (inclusive)"
696,508,"1 int clearBit sithrough0(int num, int i) { 
2 int mask = (-1 << (i + 1)); 
3 return num & mask; 
4 } 
Update Bit 
To set the ith bit to a valuev, we first clear the bit at position i by using a mask that looks like 11101111. 
Then, we shift the intended value, v, left by i bits. This will create a "
697,441,"otherwise. 
1 int updateBit(int num, int i, boolean bitisl) { 
2 int value = bitisl? 1: 0; 
3 int mask = =(1 << i); 
4 return (num & mask) I (value << i); 
5 } 
Interview Questions 
5.1 Insertion: You are given two 32-bit numbers, N and M, and two bit positions, i and 
j. Write a method to insert M "
698,329,"M = 10011, you can assume that there are at least 5 bits between j and i. You would not, for
example, have j = 3 and i = 2, because M could not fully fit between bit 3 and bit 2.
EXAMPLE 
Input: N 10000000000, M 
Output: N = 10001001100 
Hints: #137, #769, #215 
10011, i 2, j 6 
CrackingTheCodinglnt"
699,508,"Chapter 5 I Bit Manipulation 
5.2 Binary to String: Given a real number between O and 1 (e.g., 0.72) that is passed in as a double, print 
the binary representation. If the number cannot be represented accurately in binary with at most 32 
characters, print ""ERROR:' 
Hints: #743, #767, #7 73, #269, "
700,495,"EXAMPLE 
Input: 1775 
Output: 8 
(or: 11011101111) 
Hints: #759, #226, #374, #352 
5.4 Next Number: Given a positive integer, print the next smallest and the next largest number that 
have the same number of 1 bits in their binary representation. 
Hints: #747, #7 75, #242, #372, #339, #358, #375, #3"
701,453,"5.6 Conversion: Write a function to determine the number of bits you would need to flip to convert 
integer A to integer B. 
EXAMPLE 
Input: 29 (or: 11101), 15 (or: 01111) 
Output: 2 
Hints: #336, #369 
pg286 
5.7 Pairwise Swap: Write a program to swap odd and even bits in an integer with as few ins"
702,508,"Hints: #745, #248, #328, #355 
. ........ ... pg 286 
5.8 Draw Line: A monochrome screen is stored as a single array of bytes, allowing eight consecutive 
pixels to be stored in one byte. The screen has width w, where w is divisible by 8 (that is, no byte will 
be split across rows). The height of t"
703,443,"The method signature should look something like: 
drawline(byte[] screen, int width, int xl, int x2, int y) 
Hints: #366, #387, #384, #397 
Additional Questions: Arrays and Strings (#1.1, #1.4, #1.8), Math and Logic Puzzles (#6.1 O), Recursion (#8.4, 
#8.14), Sorting and Searching (#10.7, #10.8), C+"
704,452,"6 
Math and Logic Puzzles 
S
o-called""puzzles"" (or brain teasers) are some of the most hotly debated questions, and many companies
have policies banning them. Unfortunately, even when these questions are banned, you still may find 
yourself being asked one of them. Why? Because no one can agree on a"
705,496,"ably won't rely on a trick of wording, and it can almost always be logically deduced. Many have their foun­
dations in mathematics or computer science, and almost all have solutions that can be logically deduced. 
We'll go through some common approaches for tackling these questions, as well as some "
706,491,"84 = 22 * 31 * 5° * 71 * 11° * 13° * 17° * ...
Note that many of these primes have an exponent of zero. 
Divisibility 
The prime number law stated above means that, in order for a number x to divide a number y (written 
x\y, or mod (y, x) = 0), all primes in x's prime factorization must be in y's pr"
707,491,"gcd ( x, y) = 2min(j0, k0) * 3min(jl, kl) * 5min(j2, k2) *
The least common multiple of x and y will be: 
1cm ( x, y) = 2max(j0, k0) * 3max(jl, kl) * 5max(j2, k2) * .. .
As a fun exercise, stop for a moment and think what would happen if you did gcd * 1cm: 
gcd * 1cm = 2min(j0, k0) * 2max(j0, k0) * "
708,496,"Chapter 6 I Math and Logic Puzzles 
= xy 
Checking for Primality 
This question is so common that we feel the need to specifically cover it. The naive way is to simply iterate 
from 2 through n-1, checking for divisibility on each iteration. 
1 boolean primeNaive(int n) { 
2 if(n<2){ 
3 return false"
709,463,"1 boolean primeSlightlyBetter(int n) { 
2 if (n < 2) { 
3 return false; 
4 } 
5 int sqrt= (int) Math.sqrt(n); 
6 for (int i= 2; i <= sqrt; i++) { 
7 if (n % i == 0) return false; 
8 } 
9 return true; 
10 } 
The /n is sufficient because, for every number a which divides n evenly, there is a complemen"
710,427,"primality, since we would have already checked with b. 
Of course, in reality, all we really need to do is to check if n is divisible by a prime number. This is where the 
Sieve of Eratosthenes comes in. 
Generating a List of Primes: The Sieve of Eratosthenes 
The Sieve of Eratosthenes is a highly e"
711,507,"all non-prime numbers are divisible by a prime number. 
We start with a list of all the numbers up through some value max. First, we cross off all numbers divisible by 
2. Then, we look for the next prime (the next non-crossed off number) and cross off all numbers divisible by 
it. By crossing off a"
712,271,"1 boolean[] sieveOfEratosthenes(int max) { 
2 boolean[] flags= new boolean[max + 1]; 
3 int count= 0; 
4 
s 
6 
7 
init(flags); // Set all flags to true other than 0 and 1 
int prime = 2; 
8 while (prime<= Math.sqrt(max)) { 
118 Cracking the Coding Interview, 6th Edition"
713,493,"Chapter 6 I Math and Logic Puzzles 
9 /* Cross off remaining multiples of prime */ 
10 crossOff(flags, prime); 
11 
12 /* Find next value which is true */ 
13 prime = getNextPrime(flags, prime); 
14 } 
15 
16 return flags; 
17 } 
18 
19 void crossOff(boolean[] flags, int prime) { 
20 /* Cross off re"
714,508,"22 * already been crossed off in a prior iteration. */
23 for (int i= prime * prime; i 
< flags.length; i += prime) {
24 flags[i] = false; 
25 } 
26 } 
27 
28 int getNextPrime(boolean[] flags, int prime) { 
29 int next = prime + 1; 
30 while (next< flags.length && !flags[next]) { 
31 next++; 
32 } 
"
715,428,"� Probability 
Probability can be a complex topic, but it's based in a few basic laws that can be logically derived. 
Let's look at a Venn diagram to visualize two events A and B. The areas of the two circles represent their rela­
tive probability, and the overlapping area is the event {A and B}. 
P"
716,462,"intersection between A and B? If you knew the odds of landing in A, and you also knew the percent of A 
that's also in B (that is, the odds of being in B given that you were in A), then you could express the prob­
ability as: 
P(A and B) = P(B given A) P(A) 
For example, imagine we were picking a nu"
717,171,"50%, and the odds of a number between 1 and 5 being even is 40%. So, the odds of doing both are: 
P(x is even and x <= 5) 
CrackingTheCodinglnterview.com j 6th Edition 119"
718,443,"Chapter 6 I Math and Logic Puzzles 
P(x is even given x <= 5) P(x <= 5) 
(2/5) * (1/2) 
1/5 
Observe that since P(A and B) = P(B given A) P(A)
the probability of A given B in terms of the reverse: 
P(A given B) = P(B given A) P(A) / P(B)
The above equation is called Bayes'Theorem. 
Probability of A "
719,469,"landing in each individually, and you also knew the odds of landing in their intersection, then you could 
express the probability as: 
P(A or B) = P(A) + P(B) - P(A and B)
Logically, this makes sense. If we simply added their sizes, we would have double-counted their intersec­
tion. We need to subt"
720,426,"picking an even number or a number between 1 and 5? We have a 50% probability of picking an even 
number and a 50% probability of picking a number between 1 and 5. The odds of doing both are 20%. So 
the odds are: 
P(x is even or x <=5) 
P(x is even)+ P(x <= 5) - P(x is even and x <= 5) 
= X+X-Ys 
="
721,476,"Independence 
If A and B are independent (that is, one happening tells you nothing about the other happening), then P (A 
and B) = P(A) P(B).This rule simply comes from recognizing that P(B given A) = P(B), since A 
indicates nothing about B. 
Mutual Exclusivity 
If A and B are mutually exclusive (t"
722,424,"B) equation.
Many people, strangely, mix up the concepts of independence and mutual exclusivity. They are entirely 
different. In fact, two events cannot be both independent and mutually exclusive (provided both have 
probabilities greater than 0). Why? Because mutual exclusivity means that if one h"
723,172,"event. Thus, as long as two events have non-zero probabilities, they will never be both mutually exclusive 
and independent. 
120 Cracking the Coding Interview, 6th Edition"
724,430,"Chapter 6 I Math and Logic Puzzles 
If one or both events have a probability of zero (that is, it is impossible), then the events are both indepen­
dent and mutually exclusive. This is provable through a simple application of the definitions (that is, the 
formulas) of independence and mutual exclus"
725,434,"a problem; they don't expect you to immediately know the answer. Start talking, and show the interviewer 
how you approach a problem. 
� Develop Rules and Patterns 
In many cases, you will find it useful to write down ""rules"" or patterns that you discover while solving the 
problem. And yes, you rea"
726,502,"problem. Let's demonstrate this approach with an example. 
You have two ropes, and each takes exactly one hour to burn. How would you use them to time exactly 15 
minutes? Note that the ropes are of uneven densities, so half the rope length-wise does not necessarily take 
half an hour to burn. 
I
Ti"
727,455,"solution. 
From the statement of the problem, we immediately know that we can time one hour. We can also time 
two hours, by lighting one rope, waiting until it is burnt, and then lighting the second. We can generalize 
this into a rule. 
Rule 1: Given a rope that takes x minutes to burn and another"
728,404,"other than the ends) won't do us much good. The flames would expand in both directions, and we have no 
idea how long it would take to burn. 
However, we can light a rope at both ends. The two flames would meet after 30 minutes. 
Rule 2: Given a rope that takes x minutes to burn, we can time Yi minu"
729,498,"minutes of burning time from the second rope, by lighting rope 1 on both ends and rope 2 on just one end. 
Rule 3: If rope 1 takes x minutes to burn and rope 2 takes y minutes, we can turn rope 2 into a rope that takes 
(y-x) minutes or (y- '.Yi) minutes.
Now, let's piece all of these together. We c"
730,259,"From start to end, our approach is as follows: 
1. Light rope 1 at both ends and rope 2 at one end.
2. When the two flames on Rope 1 meet, 30 minutes will have passed. Rope 2 has 30 minutes left of burn­
time.
Cracking TheCodinglnterview.com / 6th Edition 121"
731,502,"Chapter 6 I Math and Logic Puzzles 
3. At that point, light Rope 2 at the other end.
4. In exactly fifteen minutes, Rope 2 will be completely burnt.
Note how solving this problem is made easier by listing out what you've learned and what ""rules"" you've 
discovered. 
� Worst Case Shifting 
Many brain"
732,480,"case. That is, if an early decision results in a skewing of the worst case, we can sometimes change the deci­
sion to balance out the worst case. This will be clearest when explained with an example. 
The ""nine balls"" question is a classic interview question. You have nine balls. Eight are of the sa"
733,509,"heavier. Find the heavy ball in just two uses of the scale. 
A first approach is to divide the balls in sets of four, with the ninth ball sitting off to the side. The heavy ball 
is in the heavier set. If they are the same weight, then we know that the ninth ball is the heavy one. Repli­
cating this"
734,453,"others take three. If we penalize the ninth ball by putting more balls off to the side, we can lighten the load 
on the others. This is an example of""worst case balancing:' 
If we divide the balls into sets of three items each, we will know after just one weighing which set has the 
heavy one. We ca"
735,479,"will point us to a set of X balls with the heavy ball. 
For the final set of three balls, we simply repeat this: put one ball off to the side and weigh two. Pick the 
heavier of the two. Or, if the balls are the same weight, pick the third one. 
� Algorithm Approaches 
If you're stuck, consider appl"
736,457,"Base Case and Build and Do It Yourself (DIY) can be especially useful. 
Additional Reading: Useful Math (pg 629). 
Interview Questions 
6.1 The Heavy Pill: You have 20 bottles of pills. 19 bottles have 1.0 gram pills, but one has pills of weight 
1.1 grams. Given a scale that provides an exact measu"
737,110,"122 Cracking the Coding Interview, 6th Edition 
........................................................... P9"
738,391,"Chapter 6 I Math and Logic Puzzles 
6.2 Basketball: You have a basketball hoop and someone says that you can play one of two games. 
Game 1: You get one shot to make the hoop. 
Game 2: You get three shots and you have to make two of three shots. 
If p is the probability of making a particular shot, "
739,423,"or the other? 
Hints:#787, #239, #284, #323 
--- ----------------------------------------------------- ------------- ---------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------"
740,438,"6.3 Dominos: There is an 8x8 chessboard in which two diagonally opposite corners have been cut off. 
You are given 31 dominos, and a single domino can cover exactly two squares. Can you use the 31 
dominos to cover the entire board? Prove your answer (by providing an example or showing why 
it's imp"
741,451,"collision (between any two or all of them) if they start walking on the sides of the triangle? Assume 
that each ant randomly picks a direction, with either direction being equally likely to be chosen, and 
that they walk at the same speed. 
Similarly, find the probability of collision with n ants o"
742,456,"no measuring cups). How would you come up with exactly four quarts of water? Note that the jugs 
are oddly shaped, such that filling up exactly ""half"" of the jug would be impossible. 
Hints:#149, #379, #400 
_________ __,_,_._._ ....... --·······-·-----
6.6 Blue-Eyed Island: A bunch of people are li"
743,465,"8:00 pm every evening. Each person can see everyone else's eye color, but they do not know their 
own (nor is anyone allowed to tell them). Additionally, they do not know how many people have 
blue eyes, although they do know that at least one person does. How many days will it take the 
blue-eyed p"
744,500,"6.7 The Apocalypse: In the new post-apocalyptic world, the world queen is desperately concerned 
about the birth rate. Therefore, she decrees that all families should ensure that they have one girl or 
else they face massive fines. If all families abide by this policy-that is, they have continue to "
745,175,"pregnancy is equal.) Solve this out logically and then write a computer simulation of it. 
Hints:#154, #760, #171, #788, #201 
CrackingTheCodinglnterview.com I 6th Edition 123"
746,453,"Chapter 6 I Math and Logic Puzzles 
6.8 The Egg Drop Problem: There is a building of 100 floors. If an egg drops from the Nth floor or 
above, it will break. If it's dropped from any floor below, it will not break. You're given two eggs. Find 
N, while minimizing the number of drops for the worst ca"
747,490,"Next, he closes every second locker. Then, on his third pass, he toggles every third locker (closes it if 
it is open or opens it if it is closed). This process continues for 100 passes, such that on each pass i, 
the man toggles every ith locker. After his 100th pass in the hallway, in which he tog"
748,470,"can be used to detect poison. A single drop of poison will turn the test strip positive permanently. 
You can put any number of drops on a test strip at once and you can reuse a test strip as many times 
as you'd like (as long as the results are negative). However, you can only run tests once per da"
749,279,"as possible? 
FOLLOW UP 
Write code to simulate your approach. 
Hlnts:#146, #163, #183, #191, #205, #221, #230, #241, #249 
Additional Problems: Moderate Problems (#16.5), Hard Problems (#17.19) 
Hints start on page 662. 
124 Cracking the Coding Interview, 6th Edition 
___ pg298"
750,485,"7 
Object-Oriented Design 
O
bject-oriented design questions require a candidate to sketch out the classes and methods to imple­
ment technical problems or real-life objects. These problems give-or at least are believed to give­
an interviewer insight into your coding style. 
These questions are not"
751,497,"of question may raise serious red flags. 
� How to Approach 
Regardless of whether the object is a physical item or a technical task, object-oriented design questions can 
be tackled in similar ways. The following approach will work well for many problems. 
Step 1: Handle Ambiguity 
Object-oriented "
752,468,"understanding what she is expected to create wastes the company's time and money, and may create much 
more serious issues. 
When being asked an object-oriented design question, you should inquire who is going to use it and how
they are going to use it. Depending on the question, you may even want t"
753,422,"straightforward enough, right? Not quite. 
Your coffee maker might be an industrial machine designed to be used in a massive restaurant servicing 
hundreds of customers per hour and making ten different kinds of coffee products. Or it might be a very 
simple machine, designed to be used by the elder"
754,402,"cantly impact your design. 
Step 2: Define the Core Objects 
Now that we understand what we're designing, we should consider what the ""core objects"" in a system 
are. For example, suppose we are asked to do the object-oriented design for a restaurant. Our core objects 
might be things like Table, Gu"
755,479,"Chapter 7 I Object-Oriented Design 
Step 3: Analyze Relationships 
Having more or less decided on our core objects, we now want to analyze the relationships between the 
objects. Which objects are members of which other objects? Do any objects inherit from any others? Are 
relationships many-to-many"
756,446,"Server and Host inherit from Employee. 
Each Table has one Party, but each Party may have multiple Tables. 
There is one Host for the Restaurant. 
Be very careful here-you can often make incorrect assumptions. For example, a single Table may have 
multiple Parties (as is common in the trendy""communa"
757,507,"Step 4: Investigate Actions 
At this point, you should have the basic outline of your object-oriented design. What remains is to consider 
the key actions that the objects will take and how they relate to each other. You may find that you have 
forgotten some objects, and you will need to update you"
758,505,"is added to the end of the list. When a Party leaves, the Table is freed and assigned to a new Party in 
the list. 
� Design Patterns 
Because interviewers are trying to test your capabilities and not your knowledge, design patterns are 
mostly beyond the scope of an interview. However, the Singleto"
759,477,"ware engineering skills is to pick up a book that focuses on this area specifically. 
Be careful you don't fall into a trap of constantly trying to find the ""right"" design pattern for a particular 
problem. You should create the design that works for that problem. In some cases it might be an estab­"
760,473,"the application. It can be useful in cases where you have a ""global"" object with exactly one instance. For 
example, we may want to implement Restaurant such that it has exactly one instance of Restaurant. 
1 public class Restaurant { 
2 private static Restaurant _instance = null; 
3 protected Resta"
761,471,"Chapter 7 I Object-Oriented Design 
8 return _instance; 
9 } 
10 } 
It should be noted that many people dislike the Singleton design pattern, even calling it an ""anti-pattern:' 
One reason for this is that it can interfere with unit testing. 
Factory Method 
The Factory Method offers an interface fo"
762,509,"providing an implementation for the Factory method. Or, you could have the Creator class be a concrete 
class that provides an implementation for the Factory method. In this case, the Factory method would take 
a parameter representing which class to instantiate. 
1 public class CardGame { 
2 public"
763,456,"6 return new BlackJackGame(); 
7 } 
8 return null; 
9 } 
10 } 
Interview Questions 
7.1 Deck of Cards: Design the data structures for a generic deck of cards. Explain how you would 
subclass the data structures to implement blackjack. 
Hints:#753, #275 
7.2 Call Center: Imagine you have a call cente"
764,444,"respondent can't handle the call, he or she must escalate the call to a manager. If the manager is not 
free or not able to handle it, then the call should be escalated to a director. Design the classes and 
data structures for this problem. Implement a method dispatchCall() which assigns a call to "
765,334,"Hints:#798 
----·······--· 
7.4 Parking Lot: Design a parking lot using object-oriented principles. 
Hints:#258 
.... - -·---·--······-· ···· ---
7.5 Online Book Reader: Design the data structures for an online book reader system. 
Hints:#344 
............ _pg::no 
........... P9 318 
CrackingTheCod"
766,509,"Chapter 7 I Object-Oriented Design 
7.6 Jigsaw: Implement an NxN jigsaw puzzle. Design the data structures and explain an algorithm to 
solve the puzzle. You can assume that you have a fitsWith method which, when passed two 
puzzle edges, returns true if the two edges belong together. 
Hints:# 192, "
767,430,"Hints: #213, #245, #271 
7.8 Othello: Othello is played as follows: Each Othello piece is white on one side and black on the other. 
When a piece is surrounded by its opponents on both the left and right sides, or both the top and 
bottom, it is said to be captured and its color is flipped. On your "
768,464,"assigned to the person with the most pieces. Implement the object-oriented design for Othello. 
Hints:#179, #228 
7.9 Circular Array: Implement a CircularArray class that supports an array-like data structure which 
can be efficiently rotated. If possible, the class should use a generic type (also c"
769,434,"Chapter 7 I Object-Oriented Design 
7 .10 Minesweeper: Design and implement a text-based Minesweeper game. Minesweeper is the classic 
single-player computer game where an NxN grid has B mines (or bombs) hidden across the grid. The 
remaining cells are either blank or have a number behind them. The "
770,410,"If it is a number, the number is exposed. If it is a blank cell, this cell and all adjacent blank cells (up to 
and including the surrounding numeric cells) are exposed. The player wins when all non-bomb cells 
are exposed. The player can also flag certain places as potential bombs. This doesn't aff"
771,452,"(Tip for the reader: if you're not familiar with this game, please play a few rounds on line first.) 
This is a fully exposed board with 3 
bombs. This is not shown to the user. 
The player initially sees a board with 
nothing exposed. 
1 1 1 
1 * 1
2 2 2
1 * 1
1 1 1 
1 1 1 
1 * 1 
Clicking on cell "
772,220,"than bombs has been exposed. 
2 2 
7.11 File System: Explain the data structures and algorithms that you would use to design an in-memory 
file system. Illustrate with an example in code where possible. 
Hints:#141, #216"
773,509,"Hints:#141, #216 
................................................................... ......................................................................................................................................................................................................................"
774,150,"sions. 
Hints: #287, #307 
Additional Questions: Threads and Locks (#16.3) 
Hints start on page 662. 
CrackingTheCodinglnterview.com / 6th Edition 129"
775,475,"8 
Recursion and Dynamic Programming 
While there are a large number of recursive problems, many follow similar patterns. A good hint that a
problem is recursive is that it can be built off of subproblems. 
When you hear a problem beginning with the following statements, it's often (though not alway"
776,505,"ment a method to compute all..:; and so on. 
I
Tip: In my experience coaching candidates, people typically have about 50% accuracy in their 
""this sounds like a recursive problem"" instinct. Use that instinct, since that 50% is valuable. But 
don't be afraid to look at the problem in a different way,"
777,476,"� How to Approach 
Recursive solutions, by definition, are built off of solutions to subproblems. Many times, this will mean 
simply to compute f ( n) by adding something, removing something, or otherwise changing the solution 
for f ( n-1). In other cases, you might solve the problem for the first "
778,491,"to develop an algorithm are bottom-up, top-down, and half-and-half. 
Bottom-Up Approach 
The bottom-up approach is often the most intuitive. We start with knowing how to solve the problem 
for a simple case, like a list with only one element. Then we figure out how to solve the problem for two 
elem"
779,333,"Top-Down Approach 
The top-down approach can be more complex since it's less concrete. But sometimes, it's the best way to 
think about the problem. 
In these problems, we think about how we can divide the problem for case N into subproblems. 
Be careful of overlap between the cases. 
13 0 Cracking "
780,508,"Chapter 8 I Recursion and Dynamic Programming 
Half-and-Half Approach 
In addition to top-down and bottom-up approaches, it's often effective to divide the data set in half. 
For example, binary search works with a ""half-and-half"" approach. When we look for an element in a sorted 
array, we first fi"
781,464,"sorted halves. 
� Recursive vs. Iterative Solutions 
Recursive algorithms can be very space inefficient. Each recursive call adds a new layer to the stack, which 
means that if your algorithm recurses to a depth of n, it uses at least O ( n) memory. 
For this reason, it's often better to implement a"
782,486,"into recursive code, ask yourself how hard it would be to implement it iteratively, and discuss the tradeoffs 
with your interviewer. 
� Dynamic Programming & Memoization 
Although people make a big deal about how scary dynamic programming problems are, there's really no 
need to be afraid of them. "
783,457,"subproblems (that is, the repeated calls). You then cache those results for future recursive calls. 
Alternatively, you can study the pattern of the recursive calls and implement something iterative. You still 
""cache"" previous work.
I 
A note on terminology: Some people call top-down dynamic progra"
784,504,"here. We call both dynamic programming. 
One of the simplest examples of dynamic programming is computing the nth Fibonacci number. A good 
way to approach such a problem is often to implement it as a normal recursive solution, and then add the 
caching part. 
Fibonacci Numbers 
Let's walk through a"
785,150,"2 if (i == 0) return 0; 
3 if (i == 1) return 1; 
4 return fibonacci(i - 1) + fibonacci(i - 2); 
5 } 
CrackingTheCodinglnterview.com J 6th Edition 131"
786,487,"Chapter 8 I Recursion and Dynamic Programming 
What is the runtime of this function? Think for a second before you answer. 
If you said O(n) or O(n2) (as many people do). think again. Study the code path that the code takes. 
Drawing the code paths as a tree (that is, the recursion tree) is useful o"
787,491,"fib{2) fib(l) fib(l) fib(0) fib(l) fib(0) 
/ "" fib(l) fib(0) 
Observe that the leaves on the tree are all fib ( 1) and fib ( 0). Those signify the base cases. 
The total number of nodes in the tree will represent the runtime, since each call only does 0(1) work 
outside of its recursive calls. There"
788,475,"figure out the runtime of a recursive algorithm. 
How many nodes are in the tree? Until we get down to the base cases (leaves), each node has two children. 
Each node branches out twice. 
The root node has two children. Each of those children has two children (so four children total in the""grand­
ch"
789,509,"I 
Actually, it's slightly better than O ( 2""). If you look at the subtree, you might notice that (excluding 
the leaf nodes and those immediately above it) the right subtree of any node is always smaller 
than the left subtree. If they were the same size, we'd have an O ( 2"") runtime. But since the"
790,509,"and Big Omega"" on page 39). Either way, we still have an exponential runtime. 
Indeed, if we implemented this on a computer, we'd see the number of seconds increase exponentially. 
60 ·+············································· · ··································································"
791,418,"Chapter 8 I Recursion and Dynamic Programming 
Top-Down Dynamic Programming (or Memoization) 
Study the recursion tree. Where do you see identical nodes? 
There are lots of identical nodes. For example, fib ( 3) appears twice and fib(2) appears three times. Why 
should we recompute these from scratc"
792,472,"possible values we can throw at fib. Each time we compute fib(i ), we should just cache this result and 
use it later. 
This is exactly what memoization is. 
With just a small modification, we can tweak this function to run in 0( n) time. We simply cache the results 
offibonacci(i) between calls. 
1"
793,466,"6 if (i == 0 I I i == 1) return i; 
7 
8 if (memo[i] == 0) { 
9 memo[i] = fibonacci(i - 1, memo)+ fibonacci(i - 2, memo); 
10 } 
11 return memo[i]; 
12 } 
While the first recursive function may take over a minute to generate the 50th Fibonacci number on a 
typical computer, the dynamic programming m"
794,472,"Now, if we draw the recursion tree, it looks something like this (the black boxes represent cached calls that 
returned immediately): 
------
fib(S) 
�
fib(42........_ � 
fib(3) � 
/ ""' 
fib(2) fib(l) 
/ "" 
fib(l) fib(0) 
How many nodes are in this tree now? We might notice that the tree now just sh"
795,350,"tree. This gives us a runtime of O( n). 
Often it can be useful to picture the recursion tree as something like this: 
------
fib(S) -----
fib( 4 � fib(3) 
� fib(2) � �(1) 
/ "" 
fib(l) fib(0) 
This is not actually how the recursion occurred. However, by expanding the further up nodes rather than the"
796,464,"Chapter 8 I Recursion and Dynamic Programming 
lower nodes, you have a tree that grows wide before it grows deep. (It's like doing this breadth-first rather 
than depth-first.) Sometimes this makes it easier to compute the number of nodes in the tree. All you're 
really doing is changing which nodes"
797,487,"Bottom-Up Dynamic Programming 
We can also take this approach and implement it with bottom-up dynamic programming. Think about 
doing the same things as the recursive memoized approach, but in reverse. 
First, we compute fib ( 1) and fib ( 0), which are already known from the base cases. Then we use"
798,505,"2 if (n == 0) return 0; 
3 else if (n == 1) return 1; 
4 
5 int[] memo new int[n]; 
6 memo[0] = 0; 
7 memo[l] = 1; 
8 for (int i= 2; i < n; i++) { 
9 memo[i] = memo[i - 1] + memo[i - 2]; 
10 } 
11 return memo[n - 1] + memo[n - 2]; 
12 } 
If you really think about how this works, you only use memo[ i"
799,450,"2 if (n == 0) return 0; 
3 int a = 0; 
4 int b = 1; 
.5 for (int i = 2; i < n; i++) { 
6 a + b; int C = 
7 
8 
9 } 
a 
b 
b· ,= c; 
10 return a+ b; 
11 } 
This is basically storing the results from the last two Fibonacci values into a and b. At each iteration, we 
compute the next value ( c = a + b)"
800,492,"will make more difficult problems much easier. Going through the problems in this chapter, many of which 
use dynamic programming, will help solidify your understanding. 
Additional Reading: Proof by Induction (pg 631). 
Interview Questions 
8.1 Triple Step: A child is running up a staircase with n "
801,98,"stairs. 
Hints: #152, #178, #217, #237, #262, #359 
134 Cracking the Coding Interview, 6th Edition"
802,412,"Chapter 8 I Recursion and Dynamic Programming 
8.2 Robot in a Grid: Imagine a robot sitting on the upper left corner of grid with r rows and c columns. 
The robot can only move in two directions, right and down, but certain cells are ""off limits"" such that 
the robot cannot step on them. Design an a"
803,350,"the bottom right. 
Hints: #331, #360, #388 
�Prl 344 
8.3 Magic Index: A magic index in an array A [ 0 ••• n -1] is defined to be an index such that A[ i] = 
i. Given a sorted array of distinct integers, write a method to find a magic index, if one exists, in
array A.
FOLLOW UP
What if the values ar"
804,448,"Hints:#770, #204, #240, #286, #340
. ................................................................................................................................................................... .............................. . .................................................................."
805,415,"Hints: #273, #290, #338, #354, #373 
348 
8.5 Recursive Multiply: Write a recursive function to multiply two positive integers without using the 
*operator.You can use addition, subtraction, and bit shifting, but you should minimize the number
of those operations.
Hints: #166, #203, #227, #234, #246"
806,499,"different sizes which can slide onto any tower. The puzzle starts with disks sorted in ascending order 
of size from top to bottom (i.e., each disk sits on top of an even larger one). You have the following 
constraints: 
(1) Only one disk can be moved at a time.
(2) A disk is slid off the top of on"
807,464,"Hints: #744, #224, #250, #272, #318 
8.7 Permutations without Dups: Write a method to compute all permutations of a string of unique 
characters. 
Hints:#150, #185, #200, #267, #278, #309, #335, #356 
8.8 Permutations with Dups: Write a method to compute all permutations of a string whose charac­
te"
808,417,"Chapter 8 I Recursion and Dynamic Programming 
8.9 Parens: Implement an algorithm to print all valid (e.g., properly opened and closed) combinations 
of n pairs of parentheses. 
EXAMPLE 
Input: 3 
Output: ( ( () ) ) , ( () () ) , ( () ) () , () ( () ) , () () () 
Hints: #138, #174, #787, #209, #243,"
809,426,"That is, given a screen (represented by a two-dimensional array of colors), a point, and a new color, 
fill in the surrounding area until the color changes from the original color. 
Hints: #364, #382 
8.11 Coins: Given an infinite number of quarters (25 cents), dimes (10 cents), nickels (5 cents), a"
810,419,"Hints: #300, #324, #343, #380, #394 
8.12 Eight Queens: Write an algorithm to print all ways of arranging eight queens on an 8x8 chess board 
so that none of them share the same row, column, or diagonal. In this case, ""diagonal"" means all 
diagonals, not just the two that bisect the board. 
Hints: #"
811,443,"cannot be rotated and can only be stacked on top of one another if each box in the stack is strictly 
larger than the box above it in width, height, and depth. Implement a method to compute the 
height of the tallest possible stack. The height of a stack is the sum of the heights of each box. 
Hints"
812,425,"(AND), I (OR), and /\ (XOR), and a desired boolean result value result, implement a function to 
count the number of ways of parenthesizing the expression such that it evaluates to result. 
EXAMPLE 
countEval(""l/\01011"", false) -> 2 
countEval(""0&0&0&1/\ll0"", true) -> 10 
Hints: #748, #168, #197, #3"
813,318,"#4.4, #4.5, #4.8, #4.10, #4.11, #4.12), Math and Logic Puzzles (#6.6), Sorting and Searching (#10.5, #10.9, 
#10.10), C++ (#12.8), Moderate Problems (#16.11), Hard Problems (#17.4, #17.6, #17.8, #17.12, #17.13, 
#17.15, #17.16, #17.24, #17.25). 
Hints start on page 662. 
136 Cracking the Coding Inte"
814,443,"9 
System Design and Scalability 
D
espite how intimidating they seem, scalabili�y questions can be among the ea:iest questions. Ther_e
are no ""gotchas;' no tricks, and no fancy algorithms-at least not usually. What tnps up many people 1s 
that they believe there's something ""magic"" to these problem"
815,449,"were asked by your manager to design some system, what would you do? 
That's why you should approach it just like this. Tackle the problem by doing it just like you would at work. 
Ask questions. Engage the interviewer. Discuss the tradeoffs. 
We will touch on some key concepts in this chapter, but "
816,423,"about the process you take. There are good solutions and bad solutions. There is no perfect solution. 
� Handling the Questions 
• Communicate: A key goal of sys�em design questions is to evaluate your ability to communicate. Stay
engaged with the interviewer. Ask them questions. Be open about the i"
817,495,"Use the whiteboard: Using a whiteboard helps your interviewer follow your proposed design. Get up to
the whiteboard in the very beginning and use it to draw a picture of what you're proposing.
Acknowledge interviewer concerns: Your interviewer will likely jump in with concerns. Don't brush
them off;"
818,444,"example, if your system produces analytics / statistics for a dataset, it matters whether those analytics
must be totally up to date.
• State your assumptions explicitly: When you do make assumptions, state them. This allows your inter­
viewer to correct you if you're mistaken, and shows that you at"
819,409,"designing a web crawler, you might need to estimate how much space it will take to store all the URLs.
You can estimate this with other data you know.
Drive: As the candidate, you should stay in the driver's seat. This doesn't mean you don't talk to your
interviewer; in fact you must talk to your in"
820,462,"Chapter 9 I System Design and Scalability 
tion. Ask questions. Be open about tradeoffs. Continue to go deeper. Continue to make improvements. 
These questions are largely about the process rather than the ultimate design. 
� Design: Step-By-Step 
If your manager asked you to design a system such as"
821,454,"you do it. This is the way you should handle it in an interview. 
Step 1: Scope the Problem 
You can't design a system if you don't know what you're designing. Scoping the problem is important 
because you want to ensure that you're building what the interviewer wants and because this might be 
some"
822,485,"implement. Will people be able to specify their own short URLs? Or will it all be auto-generated? Will you 
need to keep track of any stats on the clicks? Should the URLs stay alive forever, or do they have a timeout? 
These are questions that must be answered before going further. 
Make a list here"
823,471,"Retrieving the URL associated with a TinyURL.
User accounts and link management.
Step 2: Make Reasonable Assumptions 
It's okay to make some assumptions (when necessary), but they should be reasonable. For example, it 
would not be reasonable to assume that your system only needs to process 100 user"
824,401,"tion can help you calculate how much data your system might need to store. 
Some assumptions might take some ""product sense"" (which is not a bad thing). For example, is it okay for 
the data to be stale by a max of ten minutes? That all depends. If it takes 1 O minutes for a just-entered URL 
to wor"
825,474,"the statistics are ten minutes out of date, that might be okay. Talk to your interviewer about these sorts of 
assumptions. 
Step 3: Draw the Major Components 
Get up out of that chair and go to the whiteboard. Draw a diagram of the major components. You might 
have something like a frontend server "
826,207,"analytics. Draw a picture of what this system might look like. 
Walk through your system from end-to-end to provide a flow. A user enters a new URL. Then what? 
138 Cracking the Coding Interview, 6th Edition"
827,476,"Chapter 9 I System Design and Scalability 
It may help here to ignore major scalability challenges and just pretend that the simple, obvious approaches 
will be okay. You'll handle the big issues in Step 4. 
Step 4: Identify the Key Issues 
Once you have a basic design in mind, focus on the key issu"
828,493,"be infrequently accessed, others can suddenly peak. This might happen if a URL is posted on Reddit or 
another popular forum. You don't necessarily want to constantly hit the database. 
Your interviewer might provide some guidance here. If so, take this guidance and use it. 
Step 5: Redesign for the"
829,497,"Stay up at the whiteboard here and update your diagram as your design changes. 
Be open about any limitations in your design. Your interviewer will likely be aware of them, so it's important 
to communicate that you're aware of them, too. 
� Algorithms that Scale: Step-By-Step 
In some cases, you're"
830,500,"the ""real""focus of a broader design question. 
In these cases, try the following approach. 
Step 1 : Ask Questions 
As in the earlier approach, ask questions to make sure you really understand the question. There might 
be details the interviewer left out (intentionally or unintentionally). You can'"
831,426,"the problem? The answer to this question will provide the general outline for your solution. 
Step 3: Get Real 
Now go back to the original problem. How much data can you fit on one machine, and what problems will 
occur when you split up the data? Common problems include figuring out how to logical"
832,293,"Step 4: Solve Problems 
Finally, think about how to solve the issues you identified in Step 2. Remember that the solution for each 
issue might be to actually remove the issue entirely, or it might be to simply mitigate the issue. Usually, you 
CrackingTheCodinglnterview.com I 6th Edition 139"
833,472,"Chapter 9 I System Design and Scalability 
can continue using (with modifications) the approach you outlined in Step 1, but occasionally you will need 
to fundamentally alter the approach. 
Note that an iterative approach is typically useful. That is, once you have solved the problems from Step 3, 
"
834,487,"but rather to demonstrate that you can analyze and solve problems. Poking holes in your own solution is a 
fantastic way to demonstrate this. 
� Key Concepts 
While system design questions aren't really tests of what you know, certain concepts can make things a lot 
easier. We will give a brief over"
835,508,"A system can be scaled one of two ways. 
Vertical scaling means increasing the resources of a specific node. For example, you might add addi­
tional memory to a server to improve its ability to handle load changes. 
Horizontal scaling means increasing the number of nodes. For example, you might add "
836,417,"or disk space. 
Load Balancer 
Typically, some frontend parts of a scalable website will be thrown behind a load balancer. This allows a 
system to distribute the load evenly so that one server doesn't crash and take down the whole system. To 
do so, of course, you have to build out a network of clo"
837,495,"Database Denormalization and NoSQL 
Joins in a relational database such as SQL can get very slow as the system grows bigger. For this reason, you 
would generally avoid them. 
Denormalization is one part of this. Denormalization means adding redundant information into a database 
to speed up reads. "
838,483,"across these tables, you can store the project name within the task table (in addition to the project table). 
Or, you can go with a NoSQL database. A NoSQL database does not support joins and might structure data 
in a different way. It is designed to scale better. 
Database Partitioning (Sharding)"
839,90,"A few common ways of partitioning include: 
140 Cracking the Coding Interview, 6th Edition"
840,424,"Chapter 9 I System Design and Scalability 
• Vertical Partitioning: This is basically partitioning by feature. For example, if you were building a social
network, you might have one partition for tables relating to profiles, another one for messages, and so
on. One drawback of this is that if one of"
841,419,"database (possibly using a different partitioning scheme).
Key-Based (or Hash-Based) Partitioning: This uses some part of the data (for example an ID) to parti­
tion it. A very simple way to do this is to allocate N servers and put the data on mod (key, n). One issue
with this is that the number of "
842,451,"reallocating all the data-a very expensive task.
Directory-Based Partitioning: In this scheme, you maintain a lookup table for where the data can be
found. This makes it relatively easy to add additional servers, but it comes with two major drawbacks.
First, the lookup table can be a single point of"
843,408,"Caching 
An in-memory cache can deliver very rapid results. It is a simple key-value pairing and typically sits between 
your application layer and your data store. 
When an application requests a piece of information, it first tries the cache. If the cache does not contain the 
key, it will then lo"
844,413,"in the data store.) 
When you cache, you might cache a query and its results directly. Or, alternatively, you can cache the specific 
object (for example, a rendered version of a part of the website, or a list of the most recent blog posts). 
Asynchronous Processing & Queues 
Slow operations should "
845,465,"waiting for a process to complete. 
In some cases, we can do this in advance (i.e., we can pre-process). For example, we might have a queue of 
jobs to be done that update some part of the website. If we were running a forum, one of these jobs might 
be to re-render a page that lists the most popula"
846,469,"to load simply because someone added a new comment and invalidated the cached version of this page. 
In other cases, we might tell the user to wait and notify them when the process is done. You've probably 
seen this on websites before. Perhaps you enabled some new part of a website and it says it n"
847,408,"Some of the most important metrics around networking include: 
Bandwidth: This is the maximum amount of data that can be transferred in a unit of time. It is typically 
expressed in bits per second (or some similar ways, such as gigabytes per second). 
• Throughput: Whereas bandwidth is the maximum "
848,311,"throughput is the actual amount of data that is transferred.
Latency: This is how long it takes data to go from one end to the other. That is, it is the delay between the
sender sending information (even a very small chunk of data) and the receiver receiving it.
CrackingTheCodinglnterview.com I 6th "
849,457,"Chapter 9 I System Design and Scalability 
Imagine you have a conveyor belt that transfers items across a factory. Latency is the time it takes an item to 
go from one side to another. Throughput is the number of items that roll off the conveyor belt per second. 
Building a fatter conveyor belt will"
850,485,"Shortening the belt will decrease latency, since items spend less time in transit. It won't change the 
throughput or bandwidth. The same number of items will roll off the belt per unit of time. 
Making a faster conveyor belt will change all three. The time it takes an item to travel across the fact"
851,431,"tions. Throughput is the time it really takes, when the machines perhaps aren't operating smoothly. 
Latency can be easy to disregard, but it can be very important in particular situations. For example, if you're 
playing certain online games, latency can be a very big deal. How can you play a typic"
852,458,"ally, unlike throughput where at least you have the option of speeding things up through data compres­
sion, there is often little you can do about latency. 
MapReduce 
MapReduce is often associated with Google, but it's used much more broadly than that. A MapReduce 
program is typically used to pro"
853,466,"is handled by the system. 
Map takes in some data and emits a <key, value> pair. 
Redu ce takes a key and a set of associated values and ""reduces""them in some way, emitting a new key 
and value. The results of this might be fed back into the Redu ce program for more reducing. 
MapReduce allows us to"
854,459,"� Considerations 
In addition to the earlier concepts to learn, you should consider the following issues when designing a 
system. 
Failures: Essentially any part of a system can fail. You'll need to plan for many or all of these failures. 
• Availability and Reliability: Availability is a 
function"
855,457,"Read-heavy vs. Write-heavy: Whether an application will do a lot of reads or a lot of writes impacts the
design. If it's write-heavy, you could consider 
queuing up the writes (but think about potential failure
here!). If it's read-heavy, you might want to cache. Other design decisions could change "
856,222,"system might face and design around those.
This is just to get you started with the potential issues for a system. Remember to be open in your interview 
about the tradeoffs. 
142 Cracking the Coding Interview, 6th Edition"
857,485,"Chapter 9 I System Design and Scalability 
� There is no ""perfect"" system. 
There is no single design for TinyURL or Google Maps or any other system that works perfectly (although 
there are a great number that would work terribly). There are always tradeoffs. Two people could have 
substantially di"
858,490,"assumptions, create a solid design based on those assumptions, and be open about the weaknesses of your 
design. Do not expect something perfect. 
� Example Problem 
Given a list of millions of documents, how would you find all documents that contain a list of words? The words 
can appear in any ord"
859,496,"this findWords procedure will be called repeatedly. Let's assume that we will be calling findWord s many 
times for the same set of documents, and, therefore, we can accept the burden of pre-processing. 
Step 1 
The first step is to pretend we just have a few dozen documents. How would we implement "
860,498,"map from a word to a list of the documents that contain that word. 
""books"" -> {doc2, doc3, doc6, doc8} 
""many"" -> {docl, doc3, doc7, doc8, doc9} 
To search for""many books;' we would simply do an intersection on the values for""books"" and ""many'; and 
return {doc 3, doc8} as the result. 
Step2 
Now g"
861,449,"of factors, such as the number of possible words and the repetition of words in a document, we may not be 
able to fit the full hash table on one machine. Let's assume that this is the case. 
This division introduces the following key concerns: 
1. How will we divide up our hash table? We could divi"
862,506,"contains the keyword mapping for only a subset of the documents.
2. Once we decide how to divide up the data, we may need to process a document on one machine and
push the results off to other machines. What does this process look like? (Note: if we divide the hash
table by document this step may no"
863,107,"These are just three concerns. There may be many others. 
Cracking TheCodinglnterview.com J 6th Edition 143"
864,455,"Chapter 9 I System Design and Scalability 
Step3 
In Step 3, we find solutions to each of these issues. One solution is to divide up the words alphabetically by 
keyword, such that each machine controls a range of words (e.g., ""after""through ""apple""). 
We can implement a simple algorithm in which we"
865,419,"The advantage of this approach is that the lookup table is small and simple (since it must only specify a 
range of values), and each machine can store a copy of the lookup table. However, the disadvantage is that 
if new documents or words are added, we may need to perform an expensive shift of key"
866,499,"a lookup request for the strings that the machine owns. For example, if our string is ""after builds 
boat amaze banana"", machine 1 would get a lookup request for{"" after"", ""amaze""}. 
Machine 1 looks up the documents containing ""after"" and ""amaze;' and performs an intersection on these 
document list"
867,464,"The following diagram explains this process. 
I ""after builds boat amaze banana"" I 
Machine 1: ""after amaze"" Machine 3: ""builds boat banana"" 
""after"" doc1, docs, doc7 ""builds"" -> doc3, doc4, docs -> ""boat"" doc2, doc3, docs ""amaze"" doc2, docs, doc7 -> -> ""banana"" doc 3, doc4, docs -> 
{docs, doc7} {d"
868,493,"what questions you would ask your interviewer and then make reasonable assumptions. You may make 
different assumptions than us, and that will lead you to a very different design. That's okay! 
9.1 Stock Data: Imagine you are building some sort of service that will be called by up to 1,000 client 
a"
869,487,"design the client-facing service that provides the information to client applications?You are respon­
sible for the development, rollout, and ongoing monitoring and maintenance of the feed. Describe 
the different methods you considered and why you would recommend your approach. Your service 
can us"
870,458,"Chapter 9 I System Design and Scalability 
9.2 Social Network: How would you design the data structures for a very large social network like Face­
book or Linked In? Describe how you would design an algorithm to show the shortest path between 
two people (e.g., Me -> Bob -> Susan -> Jason -> You). 
"
871,510,"Hints: #334, #353, #365 
9.4 Duplicate URLs: You have 10 billion URLs. How do you detect the duplicate documents? In this 
case, assume ""duplicate"" means that the URLs are identical. 
Hints: #326, #347 
.. ... ... P9 380 
9.5 Cache: Imagine a web server for a simplified search engine. This system ha"
872,510,"is chosen at random, so you cannot guarantee that the same machine will always respond to the 
same request. The method proc essSearch is very expensive. Design a caching mechanism for 
the most recent queries. Be sure to explain how you would update the cache when data changes. 
Hints: #259, #274, "
873,456,"best-selling product under ""Sports Equipment"" and the #24th best-selling product under ""Safety."" 
Describe how you would design this system. 
Hints:#142, #158, #176, #189, #208, #223, #236, #244 
385 
9.7 Personal Financial Manager: Explain how you would design a personal financial manager (like 
Mi"
874,337,"Hints:#762, #180, #199, #212, #247, #276 
9.8 Pastebin: Design a system like Pastebin, where a user can enter a piece of text and get a randomly 
generated URL to access it. 
Hints:#165, #184, #206, #232 
Additional Questions: Object-Oriented Design (#7.7) 
Hints start on page 662. 
392 
CrackingThe"
875,511,"10 
Sorting and Searching 
U
nderstanding the common sorting and searching algorithms is incredibly valuable, as many sorting
and searching problems are tweaks of the well-known algorithms. A good approach is therefore to run 
through the different sorting algorithms and see if one applies particula"
876,453,"We're given two interesting bits of knowledge here: 
1. It's a large array, so efficiency is very important.
2. We are sorting based on ages, so we know the values are in a small range.
By scanning through the various sorting algorithms, we might notice that bucket sort (or radix sort) would 
be a p"
877,455,"0 ( n) running time. 
� Common Sorting Algorithms 
Learning (or re-learning) the common sorting algorithms is a great way to boost your performance. Of the 
five algorithms explained below, Merge Sort, Quick Sort and Bucket Sort are the most commonly used in 
interviews. 
Bubble Sort I Runtime: 0( n"
878,493,"than the second. Then, we go to the next pair, and so on, continuously making sweeps of the array until it is 
sorted. In doing so, the smaller items slowly""bubble"" up to the beginning of the list. 
Selection Sort I Runtime: 0( n2 ) average and worst case. Memory: 0( 1) . 
Selection sort is the chil"
879,499,"again doing a linear scan. Continue doing this until all the elements are in place. 
Merge Sort I Runtime: 0 ( n log ( n)) average and worst case. Memory: Depends. 
Merge sort divides the array in half, sorts each of those halves, and then merges them back together. Each 
of those halves has the sam"
880,478,"Chapter 10 I Sorting and Searching 
The merge method operates by copying all the elements from the target array segment into a helper array, 
keeping track of where the start of the left and right halves should be (he lperleft and he lperRight). 
We then iterate through helper, copying the smaller e"
881,498,"2 int[] helper = new int[array.length]; 
3 mergesort(array, helper, 0, array.length - 1); 
4 } 
5 
6 
7 
8 
9 
void mergesort(int[] array, int[] helper, int low, int high) { 
if (low< high) { 
int middle = (low + high)/ 2; 
10 
11 
12 
13 } 
mergesort(array, helper, low, middle); // Sort left half 
"
882,471,"16 /* Copy both halves into a helper array*/ 
17 for (int i= low; i <= high; i++) { 
18 helper[i] = array[i]; 
19 } 
20 
21 int helperleft = low; 
22 int helperRight =middle + l; 
23 int current = low; 
24 
25 /* Iterate through helper array. Compare the left and right half, copying back 
26 * the s"
883,480,"28 if (helper[helperleft] <= helper[helperRight]) { 
29 array[current] = helper[helperleft]; 
30 helperleft++; 
31 } else {//If right element is smaller than left element 
32 array[current] = helper[helperRight]; 
33 helperRight++; 
34 } 
35 current++; 
36 } 
37 
38 /* Copy the rest of the left side"
884,490,"41 array[current + i] = helper[helperleft + i]; 
42 } 
43 } 
You may notice that only the remaining elements from the left half of the helper array are copied into the 
target array. Why not the right half? The right half doesn't need to be copied because it's already there. 
Consider, for example, "
885,204,"we copy over four elements (1, 4, 5, and 2) into the target array, the [ 8, 9] will still be in place in both 
arrays. There's no need to copy them over. 
CrackingTheCodinglnterview.com I 6th Edition 14 7"
886,493,"Chapter 10 I Sorting and Searching 
The space complexity of merge sort is 0( n) due to the auxiliary space used to merge parts of the array. 
Quick Sort I Runtime: O(n log( n)) average, O(n2 ) worst case. Memory: 0( log(n)). 
In quick sort we pick a random element and partition the array, such that "
887,499,"efficiently through a series of swaps (see below). 
If we repeatedly partition the array (and its sub-arrays) around an element, the array will eventually become 
sorted. However, as the partitioned element is not guaranteed to be the median (or anywhere near the 
median), our sorting could be very "
888,502,"3 if (left< index - 1) { II Sort left half 
4 quickSort(arr, left, index - 1); 
5 } 
5 if (index< right) { II Sort right half 
7 quickSort(arr, index, right); 
3 } 
9 } 
10 
11 int partition(int[] arr, int left, int right) { 
12 int pivot = arr[(left + right) I 2]; II Pick pivot point 
13 while (lef"
889,482,"18 while (arr[right] > pivot) right--; 
19 
20 II Swap elements, and move left and right indices 
21 if (left<= right) { 
22 swap(arr, left, right); II swaps elements 
23 left++; 
24 right--; 
25 } 
26 } 
27 return left; 
28 } 
Radix Sort I Runtime: 0 (kn) (see below) 
Radix sort is a sorting algori"
890,410,"grouping numbers by each digit. For example, if we have an array of integers, we might first sort by the 
first digit, so that the Os are grouped together. Then, we sort each of these groupings by the next digit. We 
repeat this process sorting by each subsequent digit, until finally the whole array"
891,180,"case, radix sort has a runtime of 0( kn), where n is the number of elements and k is the number of passes 
of the sorting algorithm. 
148 Cracking the Coding Interview, 6th Edition"
892,413,"Chapter 10 I Sorting and Searching 
• Searching Algorithms
When we think of searching algorithms, we generally think of binary search. Indeed, this is a very useful 
algorithm to study. 
In binary search, we look for an element x in a sorted array by first comparing x to the midpoint of the array. 
"
893,494,"we search the right half of the array. We then repeat this process, treating the left and right halves as subar­
rays. Again, we compare x to the midpoint of this subarray and then search either its left or right side. We 
repeat this process until we either find x or the subarray has size 0. 
Note "
894,467,"1 int binarySearch(int[] a, int x) { 
2 int low = 0; 
3 int high= a.length 
- 1; 
4 int mid; 
5 
6 while (low <= high) { 
7 mid= (low+ high)/ 2; 
8 if (a[mid] < x) { 
9 low = mid+ 1; 
10 } else if (a[mid] > x) { 
11 high= mid - 1; 
12 } else { 
13 return mid; 
14 } 
15 } 
16 return -1; // Error 
17 "
895,500,"21 
22 int mid (low + high)/ 2; 
23 if (a[mid] < x) { 
24 return binarySearchRecu rsive(a, x, mid+ 1, high); 
25 } else if (a[mid] > x) { 
26 return binarySearchRecursive(a, x, low, mid - 1); 
27 } else { 
28 return mid; 
29 } 
30 } 
Potential ways to search a data structure extend beyond binary sea"
896,299,"a hash table. Think beyond binary search! 
· · 
Interview Questions 
10.1 Sorted Merge: You are given two sorted 
arrays, A and B, where A has a large enough buffer at the 
end to hold B. Write a method to merge B into A in sorted order. 
Hints:#332 
CrackingTheCodinglnterview.com / 6th Edition 149"
897,482,"Chapter 10 I Sorting and Searching 
10.2 Group Anagrams: Write a method to sort an array of strings so that all the anagrams are next to 
each other. 
Hints: #717, #182, #263, #342 
10.3 Search in Rotated Array: Given a sorted array of n integers that has been rotated an unknown 
number of times, wr"
898,418,"lnput:findSin{lS, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14} 
Output: 8 (the index of 5 in the array) 
Hints:#298, #370 
pg39S
10.4 Sorted Search, No Size: You are given an array-like data structure Listy which lacks a size
method. It does, however, have an elementAt ( i) method that returns the element"
899,497,"structure only supports positive integers.) Given a Li sty which contains sorted, positive integers, 
find the index at which an element x occurs. If x occurs multiple times, you may return any index. 
Hints: #320, #337, #348 
10.5 Sparse Search: Given a sorted array of strings that is interspersed "
900,492,"10.6 Sort Big File: Imagine you have a 20 GB file with one string per line. Explain how you would sort 
the file. 
Hints:#207 
······················ ············ pg402 
10.7 Missing Int: Given an input file with four billion non-negative integers, provide an algorithm to 
generate an integer that i"
901,149,"no more than one billion non-negative integers. 
Hints: #235, #254, #281 
150 Cracking the Coding Interview, 6th Edition 
..... ······-·----·· pg 403"
902,475,"Chapter 1 O I Sorting and Searching 
10.8 Find Duplicates: You have an array with all the numbers from 1 to N, where N is at most 32,000. The 
array may have duplicate entries and you do not know what N is. With only 4 kilobytes of memory 
available, how would you print all duplicate elements in the"
903,431,"ascending order, write a method to find an element. 
Hints:#193, #211, #229, #251, #266, #279, #288, #297, #303, #317, #330 
10.1 o Rank from Stream: Imagine you are reading in a stream of integers. Periodically, you wish to be able 
to look up the rank of a numberx (the number of values less than o"
904,446,"x), which is called when each number is generated, and the method getRankOfNumber(int 
x), which returns the number of values less than or equal to x (not including x itself). 
EXAMPLE 
Stream (in order of appearance): 5, 1, 4, 4, 5, 9, 7, 13, 3 
getRankOfNumber(l) 0 
getRankOfNumber(3) = 1 
getRank"
905,509,"the adjacent integers and a ""valley"" is an element which is less than or equal to the adjacent inte­
gers. For example, in the array {5, 8, 6, 2, 3, 4, 6}, {8, 6} are peaks and {5, 2} are valleys. Given an array 
of integers, sort the array into an alternating sequence of peaks and valleys. 
EXAMPLE"
906,98,"Hard (#17.11, #17.26). 
Hints start on page 662. 
CrackingTheCodinglnterview.com I 6th Edition 151"
907,478,"11 
Testing 
B
efore you flip past this chapter saying, ""but I'm not a tester;' stop and think. Testing is an important task 
for a software engineer, and for this reason, testing questions may come up during your interview. Of 
course, if you are applying for Testing roles (or Software Engineer in "
908,446,"Test a piece of software; (3) Write test code for a function; (4) Troubleshoot an existing issue. We'll cover 
approaches for each of these four types. 
Remember that all four types require you to not make an assumption that the input or the user will play 
nice. Expect abuse and plan for it. 
� Wha"
909,461,"And to some extent, that's right. You do need to come up with a reasonable list of test cases. 
But in addition, interviewers want to test the following: 
• Big Picture Understanding: Are you a person who understands what the software is really about? Can
you prioritize test cases properly? For exam"
910,502,"important that payments work reliably, products are added to the shipment queue, and customers are
never double charged.
• Knowing How the Pieces Fit Together: Do you understand how software works, and how it might fit into
a greater ecosystem? Suppose you're asked to test Google Spreadsheets. It's "
911,472,"Organization: Do you approach the problem in a structured manner, or do you just spout off anything
that comes to your head? Some candidates, when asked to come up with test cases for a camera, will
just state anything and everything that comes to their head. A good candidate will break down the par"
912,370,"Practicality: Can you actually create reasonable testing plans? For example, if a user reports that the
software crashes when they open a specific image, and you just tell them to reinstall the software, that's
typically not very practical. Your testing plans need to be feasible and realistic for a "
913,457,"Chapter 11 I Testing 
Demonstrating these aspects will show that you will be a valuable member of the testing team. 
� Testing a Real World Object 
Some candidates are surprised to be asked questions like how to test a pen. After all, you should be testing 
software, right? Maybe, but these ""real wo"
914,421,"Step 1: Who will use it? And why? 
You need to discuss with your interviewer who is using the product and for what purpose. The answer may 
not be what you think. The answer could be ""by teachers, to hold papers together;' or it could be ""by artists, 
to bend into the shape of animal:' Or, it could "
915,413,"Step 2: What are the use cases? 
It will be useful for you to make a list of the use cases. In this case, the use case might be simply fastening 
paper together in a non-damaging (to the paper) way. 
For other questions, there might be multiple use cases. It might be, for example, that the product n"
916,456,"Step 3: What are the bounds of use? 
The bounds of use might mean holding up to thirty sheets of paper in a single usage without permanent 
damage (e.g., bending), and thirty to fifty sheets with minimal permanent bending. 
The bounds also extend to environmental factors as well. For example, should"
917,401,"Step 4: What are the stress/ failure conditions? 
No product is fail-proof, so analyzing failure conditions needs to be part of your testing. A good discussion 
to have with your interviewer is about when it's acceptable (or even necessary) for the product to fail, and 
what failure should mean. 
Fo"
918,416,"handle at least 30 shirts or pants. Loading 30 - 45 pieces of clothing may result in minor failure, such as the 
clothing being inadequately cleaned. At more than 45 pieces of clothing, extreme failure might be accept­
able. However, extreme failure in this case should probably mean the machine neve"
919,481,"Step 5: How would you perform the testing? 
In some cases, it might also be relevant to discuss the details of performing the testing. For example, if you 
need to make sure a chair can withstand normal usage for five years, you probably can't actually place it in a 
home and wait five years. Instea"
920,90,"a machine to automate some of the usage. 
CrackingTheCodinglnterview.com \ 6th Edition 153"
921,420,"Chapter 11 I Testing 
� Testing a Piece of Software 
Testing a piece of software is actually very similar to testing a real world object. The major difference is that 
software testing generally places a greater emphasis on the details of performing testing. 
Note that software testing has two core "
922,451,"feasible. Some things are simply much better with manual testing because some features are too quali­
tative for a computer to effectively examine (such as if content represents pornography). Additionally, 
whereas a computer can generally recognize only issues that it's been told to look for, human"
923,465,"an essential part of the testing process. 
• Black Box Testing vs. White Box Testing: This distinction refers to the degree of access we have into the
software. In black box testing, we're just given the software as-is and need to test it. With white box
testing, we have additional 
programmatic acc"
924,455,"Let's walk through an approach from start to end. 
Step 1: Are we doing Black Box Testing or White Box Testing? 
Though this question can often be delayed to a later step, I like to get it out of the way early on. Check with 
your interviewer as to whether you're doing black box testing or white box"
925,444,"example, if you're asked to test software for parental controls on a web browser, your target users include 
both parents (who are implementing the blocking) and children (who are the recipients of blocking). You 
may also have ""guests"" (people who should neither be implementing nor receiving blocki"
926,442,"controls, removing controls, and of course their own personal internet usage. For the children, the use cases 
include accessing legal content as well as ""illegal"" content. 
Remember that it's not up to you to just magically decide the use cases. This is a conversation to have with 
your interviewer"
927,500,"it mean for a website to be blocked? Should just the ""illegal"" page be blocked, or the entire website? Is the 
application supposed to"" learn"" what is bad content, or is it based on a white list or black list? If it's supposed 
to learn what inappropriate content is, what degree of false positives o"
928,160,"failure shouldn't crash the computer. Instead, it's likely that the software should just permit a blocked site, 
1 S4 Cracking the Coding Interview, 6th Edition"
929,480,"Chapter 11 I Testing 
or ban an allowable site. In the latter case, you might want to discuss the possibility of a selective override 
with a password from the parents. 
Step 6: What are the test cases? How would you perform the testing? 
Here is where the distinctions between manual and automated t"
930,431,"how to perform the testing. What exact situations are you testing? Which of these steps can be automated? 
Which require human intervention? 
Remember that while automation allows you to do some very powerful testing, it also has some significant 
drawbacks. Manual testing should usually be part of "
931,489,"you're sure to miss major categories. Instead, approach this in a structured manner. Break down your testing 
into the main components, and go from there. Not only will you give a more complete list of test cases, but 
you'll also show that you're a structured, methodical person. 
� Testing a Functi"
932,435,"However, don't overlook the value of some conversation with your interviewer. You should discuss any 
assumptions with your interviewer, particularly with respect to how to handle specific situations. 
Suppose you were asked to write code to test sort ( int [] array), which sorts an array of integer"
933,510,"The normal case: Does it generate the correct output for typical inputs? Remember to think about poten­
tial issues here. For example, because sorting often requires some sort of partitioning, it's reasonable to 
think that the algorithm might fail on arrays with an odd number of elements, since the"
934,476,"if you pass in a very large one? 
Nulls and ""illegal"" input: It is worthwhile to think about how the code should behave when given illegal 
input. For example, if you're testing a function to generate the nth Fibonacci number, your test cases 
should probably include t�e situation where n is negativ"
935,227,"Generating these tests does require knowledge of the function you are writing. If you are unclear as to the 
constraints, you will need to ask your interviewer about this first. 
CrackingTheCodinglnterview.com \ 6th Edition 155"
936,466,"Chapter 11 I Testing 
Step 2: Define the expected result 
Often, the expected result is obvious: the right output. However, in some cases, you might want to validate 
additional aspects. For instance, if the sort method returns a new sorted copy of the array, you should 
probably validate that the o"
937,453,"fairly straightforward. Your code might look something like: 
1 void testAddThreeSorted() { 
2 Mylist list = new Mylist(); 
3 list.addThreeSorted(3, 1, 2); // Adds 3 items in sorted order 
4 ass ertEquals(list.getElement(0), 1); 
5 as sertEquals (list.getElement(l), 2); 
6 as sertEquals (list.getEle"
938,444,"dates balk at a question like this, giving unrealistic answers like ""reinstall the software:'You can approach 
these questions in a structured manner, like anything else. 
Let's walk through this problem with an example: You're working on the Google Chrome team when you 
receive a bug report: Chrome"
939,495,"be experiencing the same issue. Your goal is to understand what's really happening, so that the developers 
can fix it. 
Step 1: Understand the Scenario 
The first thing you should do is ask questions to understand as much about the situation as possible. 
How long has the user been experiencing thi"
940,452,"Is there an error report that launches? 
Step 2: Break Down the Problem 
Now that you understand the details of the scenario, you want to break down the problem into testable 
units. In this case, you can imagine the flow of the situation as follows: 
1. Go to Windows Start menu.
2. Click on Chrome "
941,469,"Chapter 11 I Testing 
6. Browser gets HTIP response.
7. Browser parses webpage.
8. Browser displays content.
At some point in this process, something fails and it causes the browser to crash. A strong tester would 
iterate through the elements of this scenario to diagnose the problem. 
Step 3: Creat"
942,472,"things that you can do yourself 
(such as replicating steps on your own machine). In the real world, you will 
be dealing with customers, and you can't give them instructions that they can't or won't do. 
Interview Questions 
11.1 Mistake: Find the mistake(s) in the following code: 
unsigned inti; 
"
943,497,"running it ten times in a debugger, you find it never crashes in the same place. The application is 
single threaded, and uses only the C standard library. What programming errors could be causing 
this crash? How would you test each one? 
Hints:#325 
11.3 ChessTest:We have the following method used"
944,469,"position (x, y). Explain how you would test this method. 
Hints:#329, #401 
11.4 No Test Tools: How would you load test a webpage without using any test tools? 
Hints: #313, #345 
11.5 Test a Pen: How would you test a pen? 
Hints: #140, #164, #220 
-- ······- ················---· ·········---··-····"
945,206,"Hints: #210, #225, #268, #349, #393 
____ .... 
············---···· ····-·-··- ----······-·····-·---·--····------·- ·····---P9 421 
Hints start on page 662. 
CrackingTheCodinglnterview.com I 6th Edition 157"
946,415,"12 
CandC++ 
A
good interviewer won't demand that you code in a language you don't profess to know. Hopefully, 
if you're asked to code in C++, it's listed on your resume. If you don't remember all the APls, don't 
worry-most interviewers (though not all) don't care that much. We do recommend, howev"
947,498,"� Classes and Inheritance 
Though C ++ classes have similar characteristics to those of other languages, we'll review some of the syntax 
below. 
The code below demonstrates the implementation of a basic class with inheritance. 
1 #include <iostream> 
2 using namespace std; 
3 
4 #define NAME_SIZE 5"
948,392,"12 cout « ""I am a person.""; 
13 } 
14 } ; 
15 
16 class Student : public Person { 
17 public: 
18 void aboutMe() { 
19 cout << ""I am a student.""; 
20 } 
21 }; 
22 
23 int main() { 
24 Student * p = new Student(); 
25 p->aboutMe(); II prints ""I am a student."" 
26 delete p; II Important! Make sure to "
949,503,"Chapter 12 I C and C++
All data members and methods are private by default in C++. One can modify this by introducing the 
keyword public. 
� Constructors and Destructors 
The constructor of a class is automatically called upon an object's creation. If no constructor is defined, the 
compiler automa"
950,448,"1 Person(int a) { 
2 id = a; 
3 } 
This works for primitive types, but you might instead want to do this: 
1 Person(int a) : id(a) { 
2 
3 } 
The data member id is assigned before the actual object is created and before the remainder of the 
constructor code is called. This approach is necessary whe"
951,485,"cannot take an argument as we don't explicitly call a destructor. 
1 -Person() {
2 delete obj; // free any memory allocated within class 
3 } 
� Virtual Functions 
In an earlier example, we defined p to be of type Student: 
1 Student * p = new Student(); 
2 p->aboutMe(); 
What would happen if we def"
952,438,"at compile-time, in a mechanism known as static binding. 
If we want to ensure that the Student's implementation of aboutMe is called, we can define aboutMe in 
the Person class to be virtual. 
1 class Person { 
2 
3 virtual void aboutMe() { 
4 cout << ""I am a person.""; 
5 } 
6 }; 
7 
8 class Studen"
953,449,"Chapter 12 I C and C++ 
13 } ; 
Another usage for virtual functions is when we can't (or don't want to) implement a method for the parent 
class. Imagine, for example, that we want Student and Teacher to inherit from Person so that we 
can implement a common method such as addCourse(string s ). Call"
954,503,"a Student or Teacher. 
In this case, we might want addCourse to be a virtual function defined within Person, with the imple­
mentation being left to the subclass. 
1 class Person { 
2 int id;// all members are private by default 
3 char name[NAME_SIZE]; 
4 public: 
5 virtual void aboutMe() { 
6 cout"
955,470,"14 cout << ""I am a student."" << endl; 
15 } 
16 
17 bool addCourse(string s) { 
18 cout << ""Added course "" << s << ""to student."" << endl; 
19 return true; 
20 } 
21 }; 
22 
23 int main() { 
24 
25 
26 
27 
28 } 
Person * p = new Student(); 
p->aboutMe(); // prints ""I am a student."" 
p->addCourse(""Hi"
956,428,"cannot instantiate it. 
� Virtual Destructor 
The virtual function naturally introduces the concept of a ""virtual destructor.""Suppose we wanted to imple­
ment a destructor method for Person and Student. A naive solution might look like this: 
1 class Person { 
2 public: 
3 -Person() {
4 cout « ""Dele"
957,492,"10 �student() { 
11 cout « ""Deleting a student."" « endl; 
12 } 
13 } ; 
14 
15 int main() { 
16 Person * p new Student(); 
17 delete p; // prints ""Deleting a person."" 
18 } 
Chapter 12 I C and c++ 
As in the earlier example, since pi s a Person, the destructor for the Person class is called. This is"
958,495,"1 class Person { 
2 public: 
3 virtual �Person() { 
4 cout « ""Deleting a person."" « endl; 
5 } 
6 }; 
7 
8 class Student : public Person { 
9 public: 
10 �student() { 
11 cout « ""Deleting a student."" < < endl; 
12 } 
13 } ; 
14 
15 int main() { 
16 Person * p new Student(); 
17 delete p; 
18 } 
This"
959,497,"side of the function declaration, as there would be no other way to specify how the parameters line up. 
1 int func(int a, int b = 3) { 
2 X = a; 
3 y = b; 
4 return a+ b; 
5 } 
6 
7 w func(4); 
8 z func(4, 5); 
� Operator Overloading 
Operator overloading enables us to apply operators like + to obj"
960,72,"+ operator as follows.
CrackingTheCodinglnterview.com j 
6th Edition 161"
961,505,"Chapter 12 I C and C ++ 
1 Bookshelf BookShelf::operator+(BookShelf &other) { ... } 
� Pointers and References 
A pointer holds the address of a variable and can be used to perform any operation that could be directly 
done on the variable, such as accessing and modifying it. 
Two pointers can equal"
962,489,"2 *p = 7;
3 int * q p; 
4 *p = 8;
5 cout « *q; II prints 8 
Note that the size of a pointer varies depending on the architecture: 32 bits on a 32-bit machine and 64 
bits on a 64-bit machine. Pay attention to this difference, as it's common for interviewers to ask exactly how 
much space a data stru"
963,509,"example: 
1 int a = s·, 
2 int & b = a. ,
3 b = 7; 
4 cout << a· , II prints 7 
In line 2 above, b is a reference to a; modifying b will also modify a. 
You cannot create a reference without specifying where in memory it refers to. However, you can create a 
free-standing reference as shown below: 
"
964,426,"Pointer Arithmetic 
One will often see programmers perform addition on a pointer, such as what you see below: 
1 int * p = new int[2]; 
2 p[0] 0; 
3 p[l] = 1; 
4 p++; 
5 cout << *p; II Outputs 1 
Performing p++ will skip ahead by sizeof(int) bytes, such that the code outputs 1. Had p been of 
differ"
965,508,"Chapter 12 I C and C++ 
� Templates 
Templates are a way of reusing code to apply the same class to different data types. For example, we might 
have a list-like data structure which we would like to use for lists of various types. The code below imple­
ments this with the Shi ftedlist class. 
1 tem"
966,436,"7 } 
8 
9 =Shiftedlist() { 
10 delete [] array; 
11 } 
12 
13 void shiftBy(int n) { 
14 offset= (offset+ n) % size; 
15 } 
16 
17 T getAt(int i) { 
18 return array[convertindex(i)]; 
19 } 
20 
21 void setAt(T item, int i) { 
22 array[convertindex(i)] = item; 
23 } 
24 
25 private: 
26 int convertlnd"
967,439,"29 return index; 
30 } 
31 }; 
Interview Questions 
12.1 Last K Lines: Write a method to print the last Klines of an input file using C++. 
Hints: #449, #459 
pg422 
12.2 Reverse String: Implement a function void reverse( char* str) in C or C++ which reverses 
a null-terminated string. 
Hints:#470, "
968,282,"12.3 Hash Table vs. STL Map: Compare and contrast a hash table and an STL map. How is a hash table 
implemented? If the number of inputs is small, which data structure options can be used instead of 
a hash table? 
Hints:#423 
pg423 
CrackingTheCodinglnterview.com I 6th Edition 163"
969,480,"Chapter 12 I C and C++
12.4 Virtual Functions: How do virtual functions work in C++? 
Hints:#463 
12.5 Shallow vs. Deep Copy: What is the difference between deep copy and shallow copy? Explain how 
you would use each. 
Hints:#445 
12.6 Volatile: What is the significance of the keyword ""volatile"" in "
970,493,"··--·········--·····---------·--- .......... --P9 427 
12.8 Copy Node: Write a method that takes a pointer to a Node structure as a parameter and returns a 
complete copy of the passed in data structure. The Node data structure contains two pointers to 
other Nodes. 
Hints: #427, #462 
12.9 Smart Po"
971,476,"cally counts the number of references to a SmartPointer<T*> object and frees the object of type 
T when the reference count hits zero. 
Hints: #402, #438, #453 
,.. pg428 
12.10 Malloc: Write an aligned malloc and free function that supports allocating memory such that the 
memory address returned i"
972,489,"to memory of size 1000 bytes. 
aligned_ free () will free memory allocated by align_malloc. 
Hints:#473, #432, #440 
pg430 
12.11 20 Alloc: Write a function in C called my2DA1loc which allocates a two-dimensional array. Mini­
mize the number of calls to malloc and make sure that the memory is access"
973,72,"Hints start on page 676. 
164 Cracking the Coding Interview, 6th Edition"
974,453,"13 
Java 
W
hile Java-related questions are found throughout this book, this chapter deals with questions about 
the language and syntax. Such questions are more unusual at bigger companies, which believe more 
in testing a candidate's aptitude than a candidate's knowledge (and which have the time a"
975,479,"quite common. 
� How to Approach 
As these questions focus so much on knowledge, it may seem silly to talk about an approach to these prob­
lems. After all, isn't it just about knowing the right answer? 
Yes and no. Of course, the best thing you can do to master these questions is to learn Java insi"
976,473,"of the scenario, and ask yourself how things should play out.
2. Ask yourself how other languages would handle this scenario.
3. Consider how you would design this situation if 
you were the language designer. What would the impli-
cations of each choice be?
Your interviewer may be equally-or more-i"
977,494,"see if I can figure it out. Suppose we have this code ... 
"" 
� Overloading vs. Overriding 
Overloading is a term used to describe when two methods have the same name but differ in the type or 
number of arguments. 
1 public double computeArea(Circle c) { .•• } 
2 public double computeArea(Square s)"
978,201,"1 public abstract class Shape { 
2 public void printMe() { 
3 System.out.println(""I am a sh ape.""); 
4 } 
5 public abstract double computeArea(); 
6 } 
CrackingTheCodi nglnterview.com I 6th Edition 165"
979,503,"Chapter 13 I Java 
7 
8 public class Circle extends Shape { 
9 private double rad= 5; 
10 public void printMe() { 
11 System.out.println(""I am a circle.""); 
12 } 
13 
14 public double computeArea() { 
15 return rad* rad* 3.15; 
16 } 
17 } 
18 
19 public class Ambiguous extends Shape { 
20 private do"
980,471,"28 Shape[] shapes = new Shape[2]; 
29 Circle circle = new Circle(); 
30 Ambiguous ambiguous = new Ambiguous(); 
31 
32 
33 
34 
shapes[0] 
shapes[l] 
circle; 
ambiguous; 
35 for (Shape s : shapes) { 
36 s.printMe();
37 System.out.println(s.computeArea());
38 } 
39 } 
40 } 
The above code will print:"
981,410,"� Collection Framework 
Java's collection framework is incredibly useful, and you will see it used throughout this book. Here are 
some of the most useful items: 
Array List: An Array List is a dynamically resizing array, which grows as you insert elements. 
1 Arraylist<String> myArr = new Arraylist"
982,224,"4 System.out.println(myArr.get(0)); /* prints <one>*/ 
Vector: A vector is very similar to an Arraylist except that it is synchronized. Its syntax is almost 
identical as well. 
166 Cracking the Coding Interview, 6th Edition"
983,476,"Chapter 13 I Java 
1 Vector<String> myVect new Vector<String>(); 
2 myVect.add(""one""); 
3 myVect. add (""two"") ; 
4 system.out.printin(myVect.get(0)); 
Linked List: Linkedlist is, of course, Java's built-in Linkedlist class. Though it rarely comes up in 
an interview, it's useful to study because it "
984,453,"3 myLinkedList. add First (""one""); 
4 Iterator<String> iter = mylinkedlist.iterator(); 
5 while (iter.hasNext()) { 
6 System.out.println(iter.next()); 
7 } 
HashMap:The HashMap collection is widely used, both in interviews and in the real world. We've provided 
a snippet of the syntax below. 
1 Hash"
985,468,"4 System . out. println(map. get (""one"")); 
Before your interview, make sure you're very comfortable with the above syntax. You'll need it. 
Interview Questions 
Please note that because virtually all the solutions in this book are implemented with Java, we have selected 
only a small number of ques"
986,500,"13.1 Private Constructor: In terms of inheritance, what is the effect of keeping a constructor private? 
Hints:#404 
13.2 Return from Finally: In Java, does the finally block get executed if we insert a return state­
ment inside the try block of a try-catc h-finally? 
Hints:#409 
..................."
987,359,"13.4 Generics vs. Templates: Explain the difference between templates in C ++ and generics in Java. 
Hints:#416, #425 
13.5 TreeMap, HashMap, LinkedHashMap: Explain the differences between Tre eMap, HashMap, and 
LinkedHashMap. Provide an example of when each one would be best. 
Hints: #420, #424, #"
988,510,"Chapter 13 I Java 
13.6 Object Reflection: Explain what object reflection is in Java and why it is useful. 
Hints:#435 
... _pg 4-37 
13.7 Lambda Expressions: There is a class Country that has methods getContinent() and 
getPopulation(). Write a function int getPopulation(List<Country> countries, 
S"
989,470,". ................................. . .. .... pg433 
13.8 Lambda Random: Using Lambda expressions, write a function List<Integer> 
getRandomSubs et ( List< Integer> list) that returns a random subset of arbitrary size. All 
subsets (including the empty set) should be equally likely to be chosen. 
Hi"
990,72,"Hints start on page 676. 
168 Cracking the Coding Interview, 6th Edition"
991,468,"14 
Databases 
I
f you profess knowledge of databases, you might be asked some questions on it. We'll review some of the 
key concepts and offer an overview of how to approach these problems. As you read these queries, don't 
be surprised by minor variations in syntax. There are a variety of flavors"
992,500,"� SQL Syntax and Variations 
implicit and explicit joins are shown below. These two statements are equivalent, and it's a matter of 
personal preference which one you choose. For consistency, we will stick to the explicit join. 
1 
2 
3 
SELECT CourseName, TeacherName 
FROM Courses INNER JOIN Teache"
993,481,"WHERE Courses.TeacherID = 
Teachers.TeacherID 
Normalized databases are designed to minimize redundancy, while denormalized databases are designed 
to optimize read time. 
In a traditional normalized database with data like Courses and Teachers, Courses might contain a 
column called TeacherID, whic"
994,424,"queries will require expensive joins. 
Instead, we can denormalize the database by storing redundant data. For example, if we knew that we 
would have to repeat this query often, we might store the teacher's name in the Courses table. Denormal­
ization is commonly used to create highly scalable syst"
995,248,"earlier. This database has the following simple structure(* indicates a primary key): 
Courses: CourseID*, CourseName, TeacherID 
Teachers: TeacherID*, TeacherName 
Students; StudentID*, StudentName 
CrackingTheCodinglnterview.com J 6th Edition 169"
996,508,"Chapter 14 I Databases 
StudentCourses: CourseID*, StudentID* 
Using the above table, implement the following queries. 
Query 1: Student Enrollment 
Implement a query to get a list of all students and how many courses each student is enrolled in. 
At first, we might try something like this: 
1 /* In"
997,424,"5 GROUP BY Students.StudentID 
This has three problems: 
1. We have excluded students who are not enrolled in any courses, since StudentCourses only includes
enrolled students. We need to change this to a LEFT JOIN.
2. Even if we changed it to a LEFT JOIN, the query is still not quite right. Doing c"
998,497,"have one item in their group. We need to change this to count the number of CourseIDs in each group:
count(StudentCourses.CourseID).
3. We've grouped by Students. Student ID, but there are still multiple StudentNames in each group.
How will the database know which StudentName to return? Sure, they m"
999,506,"Fixing these issues gets us to this query: 
1 /* Solution 1: Wrap with another query*/ 
2 SELECT StudentName, Students.StudentID, Cnt 
3 FROM ( 
4 SELECT Students.StudentID, count(StudentCourses.CourseID) as [Cnt] 
5 FROM Students LEFT JOIN StudentCourses 
6 ON Students.StudentID = StudentCourses.St"
1000,474,"wrap lines 3 through 6 with another query. This (incorrect) solution is shown below. 
1 /* Incorrect Code */ 
1 SELECT StudentName, Students.StudentID, count(StudentCourses.CourseID) as [Cnt] 
2 FROM Students LEFT JOIN StudentCourses 
3 ON Students.StudentID = StudentCourses.StudentID 
4 GROUP BY St"
1001,475,"aggregate function or in the GROUP BY clause. 
Alternatively, we could resolve the above issues with either of the following statements: 
1 /* Solution 2: Add StudentName to GROUP BY clause. */ 
2 SELECT StudentName, Students.StudentID, count(StudentCourses.CourseID) as [Cnt] 
3 FROM Students LEFT J"
1002,445,"1 /* Solution 3: Wrap with aggregate function. */ 
Chapter 14 I Databases
2 SELECT max(StudentName) as [StudentName], Students.StudentID, 
3 count(StudentCourses.CourseID) as [Count] 
4 FROM Students LEFT JOIN StudentCourses 
5 ON Students.StudentID = StudentCourses.StudentID 
6 GROUP BY Students.St"
1003,487,"the same student in two courses, you should double count the student. Sort the list in descending order of 
the number of students a teacher teaches. 
We can construct this query step by step. First, let's get a list of TeacherIDs and how many students are 
associated with each TeacherID. This is ve"
1004,479,"3 ON Courses.CourseID = StudentCourses.CourseID 
4 GROUP BY Courses.TeacherID 
Note that this INNER JOIN will not select teachers who aren't teaching classes. We'll handle that in the 
below query when we join it with the list of all teachers. 
1 SELECT TeacherName, isnull(StudentSize.Number, 0) 
2 "
1005,508,"5 ON Courses.CourseID = StudentCourses.CourseID 
6 GROUP BY Courses.TeacherID) StudentSize 
7 ON Teachers.TeacherID = StudentSize.TeacherID 
8 ORDER BY StudentSize.Number DESC 
Note how we handled the NULL values in the SELECT statement to convert the NULL values to zeros. 
� Small Database Design 
"
1006,408,"Step 1: Handle Ambiguity 
Database questions often have some ambiguity, intentionally or unintentionally. Before you proceed with 
your design, you must understand exactly what you need to design. 
Imagine you are asked to design a system to represent an apartment rental agency. You will need to kno"
1007,482,"general you should be. For example, it would be extremely rare for a person to rent two apartments in the 
same building. But does that mean you shouldn't be able to handle that? Maybe, maybe not. Some very rare 
conditions might be best handled through a work around (like duplicating the person's c"
1008,147,"table. In this case, our core objects might be Property, Building, Apartment, Tenant and Manager. 
CrackingTheCodinglnterview.com I 6th Edition 171"
1009,493,"Chapter 14 I Databases
Step 3: Analyze Relationships 
Outlining the core objects should give us a good sense of what the tables should be. How do these tables 
relate to each other? Are they many-to-many? One-to-many? 
lfBuildings has a one-to-many relationship with Apartments (one Building has many"
1010,481,"BuildingName varchar(100) 
BuildingAddress varchar(500) 
Note that the Apartments table links back to Buildings with a BuildingID column. 
If we want to allow for the possibility that one person rents more than one apartment, we might want to 
implement a many-to-many relationship as follows: 
Tenan"
1011,455,"TenantName varchar(100) 
TenantAddress varchar(500) 
The TenantApartments table stores a relationship between Tenants and Apartments. 
Step 4: Investigate Actions 
Finally, we fill in the details. Walk through the common actions that will be taken and understand how to 
store and retrieve the releva"
1012,413,"� Large Database Design 
When designing a large, scalable database, joins (which are required in the above examples) are generally 
very slow. Thus, you must denormalize your data. Think carefully about how data will be used-you'll prob­
ably need to duplicate the data in multiple tables. 
Interview"
1013,337,"multiple tenants, and each tenant can have multiple apartments. Each apartment belongs to one building, 
and each building belongs to one complex. 
14.1 Multiple Apartments: Write a SOL query to get a list of tenants who are renting more than one 
apartment. 
Hints:#408 
172 Cracking the Coding Inte"
1014,508,"Chapter 14 I Databases 
14.2 Open Requests: Write a SQL query to get a list of all buildings and the number of open requests 
(Requests in which status equals 'Open'). 
Hints: #411 
pg 44.2 
14.3 Close All Requests: Building #11 is undergoing a major renovation. Implement a query to close all 
reque"
1015,420,"are better in certain situations. 
Hints: #451 
14.5 Denormalization: What is denormalization? Explain the pros and cons. 
Hints: #444, #455 
14.6 Entity-Relationship Diagram: Draw an entity-relationship diagram for a database with companies, 
people, and professionals (people who work for companies"
1016,506,"Design what this database might look like and provide a SQL query to return a list of the honor roll 
students (top 10%), sorted by their grade point average. 
Hints: #428, #442 
_og445 
Additional Questions: Object-Oriented Design (#7.7), System Design and Scalability (#9.6) 
Hints start on page 67"
1017,153,"Address varchar(500) 
Status varchar(100) 
AptID int 
Description varchar(500) 
TenantName varchar(100) 
CrackingTheCodinglnterview.com I 6th Edition 173"
1018,469,"15 
Threads and Locks 
I
n a Microsoft, Google or Amazon interview, it's not terribly common to be asked to implement an algo­
rithm with threads (unless you're working in a team for which this is a particularly important skill). It 
is, however, relatively common for interviewers at any company to "
1019,489,"� Threads in Java 
Every thread in Java is created and controlled by a unique object of the java. lang. Thread class. When 
a standalone application is run, a user thread is automatically created to execute the main () method. This 
thread is called the main thread. 
In Java, we can implement thread"
1020,433,"Implementing the Runnable Interface 
The Runnable interface has the following very simple structure. 
1 public interfa ce Runnable { 
2 void run(); 
3 } 
To create and use a thread using this interface, we do the following: 
1. Create a class which implements the Runnable 
interface. An object of th"
1021,384,"The Thread object now has a Runnable object that implements the run () method.
3. The start() method is invoked on the Thread object created in the previous step.
For example: 
1 public class RunnableThreadExample implements Runnable 
{ 
2 public int count = 0; 
4 public void run() { 
5 System.out.p"
1022,508,"6 try { 
7 while (count< 5) { 
8 Thread. sleep(500); 
9 count++; 
10 } 
11 } catch (InterruptedException exc) { 
Chapter 15 I Threads and Locks 
12 System.out.println(""RunnableThread interrupted.""); 
13 } 
14 system.out.print ln(""RunnableThread terminating.""); 
15 } 
16 } 
17 
18 public static void "
1023,491,"22 
23 /* waits until above thread counts to 5 (slowly) */ 
24 while (instance.count != 5) { 
25 try { 
26 Thread.sleep(250); 
27 } catch (InterruptedException exc) { 
28 exc.printStackTrace(); 
29 } 
30 } 
31 } 
In the above code, observe that all we really needed to do is have our class implement "
1024,480,"Extending the Thread Class 
Alternatively, we can create a thread by extending the Th read class. This will almost always mean that 
we override the run() method, and the subclass may also call the thread constructor explicitly in its 
constructor. 
The below code provides an example of this. 
1 pub"
1025,332,"6 try { 
7 while (count< 5) { 
8 Thread.sleep(500); 
9 System.out.println(""In Thread, count is ""+ count); 
10 
11 } 
count++; 
12 } catch (InterruptedException exc) { 
13 System.out.println(""Thread interrupted.""); 
14 } 
15 System.out.println(""Thread terminating.""); 
16 } 
17 } 
18 
CrackingTheCodin"
1026,445,"Chapter 15 I Threads and Locks 
19 public class fxampleB { 
20 public static void main(String args[]) { 
21 ThreadExample instance = new ThreadExample(); 
22 instance.start(); 
23 
24 while (instance.count != 5) { 
25 try { 
26 Thread.sleep(250); 
27 } catch (InterruptedException exc) { 
28 exc.prin"
1027,412,"class, rather than just implementing an interface, we can call start () on the instance of the class itself. 
Extending the Thread Class vs. Implementing the Runnable Interface 
When creating threads, there are two reasons why implementing the Runnable interface may be prefer­
able to extending the "
1028,501,"subclass cannot extend any other class. A class implementing the Runnable interface will be able to 
extend another class. 
• A class might only be interested in being runnable, and therefore, inheriting the full overhead of the
Thread class would be excessive.
� Synchronization and Locks 
Threads w"
1029,496,"when two threads modify a resource at the same time. Java provides synchronization in order to control 
access to shared resources. 
The keyword synchronized and the lock form the basis for implementing synchronized execution of 
code. 
Synchronized Methods 
Most commonly, we restrict access to shar"
1030,307,"taneously on the same object. 
To clarify the last point, consider the following code: 
1 public class MyClass extends Thread { 
2 private String name; 
3 private MyObject myObj; 
4 
5 public MyClass(MyObject obj, String n) { 
6 name = n; 
7 myObj = obj; 
3 } 
176 Cracking the Coding Interview, 6th "
1031,454,"9 
10 public void run() { 
11 myObj.foo(name); 
12 } 
13 } 
14 
15 
16 
17 
public class MyObject { 
public synchronized void foo(String name) { 
try { 
Chapter 15 I Threads and Locks 
18 
19 
20 
21 
22 
System.out.println(""Thread ""+ name + "".foo(): starting""); 
Thread.sleep(3000); 
System.out.prin"
1032,478,"23 } 
24 } 
25 } 
Can two instances of MyClass call foo at the same time? It depends. If they have the same instance of 
MyObj ect, then no. But, if they hold different references, then the answer is yes. 
1 /* Difference references - both threads can call MyObject.foo() */ 
2 MyObject objl = new My"
1033,419,"6 threadl.start(); 
7 thread2.start() 
8 
9 /* Same reference to obj. Only one will be allowed to call foo, 
10 * and the other will be forced to wait. */
11 MyObject obj= new MyObject(); 
12 MyClass thread! new MyClass (obj, ""1""); 
13 MyClass thread2 = new MyClass(obj, ""2""); 
14 threadl.start() 
15"
1034,460,"synchronized static methods on the same class, even if one is calling foo and the other is calling bar. 
1 public class MyClass extends Thread { 
2 
3 public void run() { 
4 if (name.equals(""!"")) MyObject.foo(name); 
5 else if (name.equals(""2"")) MyObject.bar(name); 
6 } 
7 } 
8 
9 public class MyObj"
1035,213,"12 } 
If you run this code, you will see the following printed: 
Thread 1.foo(): starting 
Thread 1.foo(): ending 
Thread 2.bar(): starting 
Thread 2.bar(): ending 
CrackingTheCodinglnterview.com I 6th Edition 177"
1036,464,"Chapt@r 15 I Threads and Locks 
Synchronized Blocks 
Similarly, a block of code can be synchronized. This operates very similarly to synchronizing a method. 
1 public class MyClass extends Thread { 
2 
3 public void run() { 
4 myObj.foo(name); 
5 } 
6 } 
7 public class MyObject { 
8 public void foo("
1037,487,"sync hronized block. That means that if threadl and thread2 have the same instance ofMyObject, 
only one will be allowed to execute the code block at a time. 
Locks 
For more granular control, we can utilize a lock. A lock (or monitor) is used to synchronize access to a 
shared resource by associati"
1038,497,"and, therefore, only one thread can access the shared resource. 
A common use case for locks is when a resource is accessed from multiple places, but should be only 
accessed by one thread at a time. This case is demonstrated in the code below. 
1 public class LockedATM { 
2 private Lock lock; 
3 pr"
1039,368,"11 int temp= balance; 
12 try { 
13 Thread.sleep(100); 
14 temp= temp - value; 
15 Thread.sleep(100); 
16 balance = temp; 
17 } catch (InterruptedException 
18 lock. unlock(); 
19 return temp; 
20 } 
21 
22 public int deposit(int value) { 
23 lock. lock(); 
24 int temp= balance; 
25 try { 
26 Thread"
1040,402,"27 
28 
29 
30 
31 
32 
33 } 
34 } 
temp= temp+ value; 
Thread.sleep(300); 
balance= temp; 
} catch (InterruptedException e) { 
lock.unlock(); 
return temp; 
Chapter 15 I Threads and Locks 
} 
Of course, we've added code to intentionally slow down the execution of withdraw and deposit, as it 
helps "
1041,497,"situation it mirrors is very, very real. Using a lock will help protect a shared resource from being modified in 
unexpected ways. 
� Deadlocks and Deadlock Prevention 
A deadlock is a situation where a thread is waiting for an object lock that another thread holds, and this 
second thread is waitin"
1042,480,"forever. The threads are said to be deadlocked. 
In order for a deadlock to occur, you must have all four of the following conditions met: 
1. Mutual Exclusion: Only one process can access a resource at a given time. (Or, more accurately, there is
limited access to a resource. A deadlock could also "
1043,455,"quishing their current resources.
3. No Preemption: One process cannot forcibly remove another process' resource.
4. Circular Wait: Two or more processes form a circular chain where each process is waiting on another
resource in the chain.
Deadlock prevention entails removing any of the above condit"
1044,453,"be used by one process at a time (e.g., printers). Most deadlock prevention algorithms focus on avoiding 
condition #4: circular wait. 
Interview Questions 
15.1 Thread vs. Process: What's the difference between a thread and a process? 
Hints:#405 
........ _pg447 
15.2 Context Switch: How would you"
1045,424,"Chapter 1 S I Threads and Locks 
15.3 Dining Philosophers: In the famous dining philosophers problem, a bunch of philosophers are 
sitting around a circular table with one chopstick between each of them. A philosopher needs 
both chopsticks to eat, and always picks up the left chopstick before the r"
1046,447,"threads and locks, implement a simulation of the dining philosophers problem that prevents dead­
locks. 
Hints: #419, #437 
.. P!J449 
15.4 Deadlock-Free Class: Design a class which provides a lock only if there are no possible deadlocks. 
Hints: #422, #434 
15.5 Call In Order: Suppose we have the f"
1047,435,"public void second() { ... } 
public void third() { ... } 
} 
The same instance of Fo o will be passed to three different threads. ThreadA will call first, 
threads will call second, and thread( will call third. Design a mechanism to ensure that 
first is called before second and second is called be"
1048,470,"B. If you have two threads in one instance of a program, can they both execute A at the same time?
Can they execute A and Ba t the same time?
Hints:#429 
15.7 FizzBuzz: In the classic problem FizzBuzz, you are told to print the numbers from 1 to n. However, 
when the number is divisible by 3, print "
1049,420,"Implement a multithreaded version of FizzBuzz with four threads. One thread checks for divisibility 
of 3 and prints ""Fizz''. Another thread is responsible for divisibility of 5 and prints""Buzz''. A third thread 
is responsible for divisibility of 3 and 5 and prints ""FizzBuzz''. A fourth thread does"
1050,507,"16 
Moderate 
16.1 Number Swapper: Write a function to swap a number in place (that is, without temporary vari­
ables). 
Hints: #492, #716, #737 
16.2 Word Frequencies: Design a method to find the frequency of occurrences of any given word in a 
book. What if we were running this algorithm multiple "
1051,509,"Hints:#465, #472, #497, #517, #527 
16.4 Tic Tac Win: Design an algorithm to figure out if someone has won a game of tic-tac-toe. 
Hints:#710, #732 
--·········---... ········-------········-··---···--·······---················-----·---·-····----- _pg 466 
16.5 Factorial Zeros: Write an algorithm wh"
1052,461,"array) with the smallest (non-negative) difference. Return the difference. 
EXAMPLE 
Input: {1, 3, 15, 11, 2}, {23, 127,235, 19, 8} 
Output: 3. That is, the pair (11, 8). 
Hints: #632, #670, #679 
···········--·········--·-···-·---· _pg 474
16.7 Number Max: Write a method that finds the maximum of t"
1053,492,"Chapter 16 I Moderate
16.8 English Int: Given any integer, print an English phrase that describes the integer (e.g., ""One Thou­
sand, Two Hundred Thirty Four""). 
Hints: #502, #588, #688 
16.9 Operations: Write methods to implement the multiply, subtract, and divide operations for integers. 
The resu"
1054,494,"compute the year with the most number of people alive. You may assume that all people were born 
between 1900 and 2000 (inclusive). If a person was alive during any portion of that year, they should 
be included in that year's count. For example, Person (birth= 1908, death= 1909) is included in the "
1055,492,"There are two types of planks, one of length shorter and one of length 
longer. You must use 
exactly K planks of wood. Write a method to generate all possible lengths for the diving board. 
Hints: #690, #700, #715, #722, #740, #747 
16.12 XML Encoding: Since XML is very verbose, you are given a way"
1056,436,"Attribute --> Tag Value 
END --> 0 
Tag --> some predefined mapping to int 
Value --> string value 
For example, the following XML might be converted into the compressed string below (assuming a 
mapping of family -> 1, person ->2, firstName -> 3, lastName -> 4, state 
-> 5). 
<family lastName=""McDo"
1057,458,"Becomes: 
1 4 McDowell SCA 0 2 3 Gayle 0 Some Message 0 0 
Write code to print the encoded version of an XML element (passed in Element and Attribute 
objects). 
Hints:#466 
16.13 Bisect Squares: Given two squares on a two-dimensional plane, find a line that would cut these two 
squares in half. Ass"
1058,171,"Chapter 16 I Moderate 
16.14 Best Line: Given a two-dimensional graph with points on it, find a line which passes the most 
number of points. 
Hints:#491, #520, #529, #563"
1059,484,"number of points. 
Hints:#491, #520, #529, #563 
...................................................................................................... .. . . . .............................................................. ............................................................................"
1060,413,"The computer has four slots, and each slot will contain a ball that is red (R). yellow (Y) . green (G) or 
blue (B). For example, the computer might have RGGB (Slot #1 is red, Slots #2 and #3 are green, Slot 
#4 is blue). 
You, the user, are trying to guess the solution. You might, for example, gues"
1061,449,"but is in the wrong slot, you get a ""pseudo-hit:' Note that a slot that is a hit can never count as a 
pseudo-hit. 
For example, if the actual solution is RGBY and you guess GGRR, you have one hit and one pseudo-hit. 
Write a method that, given a guess and a solution, returns the number of hits and "
1062,506,"elements m through n, the entire array would be sorted. Minimize n - m (that is, find the smallest 
such sequence). 
EXAMPLE 
lnput:1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19 
Output: (3, 9) 
Hints: #482, #553, #667, #708, #735, #746 
........................ ......................................."
1063,489,"EXAMPLE 
lnput:2, -8, 3 , -2, 4, -10 
Output: 5 ( i. e • , { 3, -2, 4}) 
Hints:#537, #551, #567, #594, #614 
··········--- pg498 
16.18 Pattern Matching: You are given two strings, pattern and value. The pattern string consists of 
just the letters a and b, describing a pattern within a string. For "
1064,204,"Write a method to determine if value matches pattern. 
Hints:#631, #643, #653, #663, #685, #718, #727 
............................................. pg499 
CrackingTheCodinglnterview.com I 6th Edition 183"
1065,499,"Chapter 16 / Moderate
16.19 Pond Sizes: You have an integer matrix representing a plot of land, where the value at that loca­
tion represents the height above sea level. A value of zero indicates water. A pond is a region of 
water connected vertically, horizontally, or diagonally. The size of the p"
1066,508,"0 1 0 1 
1 1 0 1 
0 1 0 1 
Output: 2, 4, 1 (in any order) 
Hints: #674, #687, #706, #723 
16.20 T9: On old cell phones, users typed on a numeric keypad and the phone would provide a list of 
words that matched these numbers. Each digit mapped to a set of O - 4 letters. Implement an algo­
rithm to re"
1067,481,"EXAMPLE 
Input: 
Output: 
8733 
tree, used 
1 
4 
ghi 
7 
pqrs 
Hints:#477, #487, #654, #703, #726, #744 
2 3 
abc def 
5 6 
jkl mno 
8 9 
tuv wxyz 
0 
16.21 Sum Swap: Given two arrays of integers, find a pair of values (one value from each array) that you 
can swap to give the two arrays the same s"
1068,410,"Chapter 16 I Moderate
16.22 Langton's Ant: An ant is sitting on an infinite grid of white and black squares. It initially faces right. 
At each step, it does the following: 
(1) At a white square, flip the color of the square, turn 90 degrees right (clockwise), and move forward
one unit.
(2) At a bl"
1069,472,"forward one unit.
Write a program to simulate the first K moves that the ant makes and print the final board as a grid. 
Note that you are not provided with the data structure to represent the grid. This is something you 
must design yourself. The only input to your method is K. You should print the"
1070,451,"pg 512 
16.23 Rand7 from Rands: Implement a method rand7() given rand5( ). That is, given a method that 
generates a random number between O and 4 (inclusive), write a method that generates a random 
number between O and 6 (inclusive). 
Hints:#505, #574, #637, #668, #697, #720 
------------------ --"
1071,496,"16.24 Pairs with Sum: Design an algorithm to find all pairs of integers within an array which sum to a 
specified value. 
Hints: #548, #597, #644, #673 
_____ pg520 
16.25 LRU Cache: Design and build a ""least recently used"" cache, which evicts the least recently used 
item. The cache should map from"
1072,360,"recently used item. 
Hints: #524, #630, #694 
-- - -------- ------------ --- pg521 
16.26 Calculator: Given an arithmetic equation consisting of positive integers, +, -, * and / (no paren­
theses), compute the result. 
EXAMPLE 
Input: 
Output: 
2*3+5/6*3+15 
23.5 
Hints: #521, #624, #665, #698 
----"
1073,452,"17 
Hard 
17 .1 Add Without Plus: Write a function that adds two numbers. You should not use+ or any arithmetic 
operators. 
Hints: #467, #544, #607, #628, #642, #664, #692, #772, #724 
17 .2 Shuffle: Write a method to shuffle a deck of cards. It must be a perfect shuffle-in other words, each 
of th"
1074,435,"number generator which is perfect. 
Hints: #483, #579, #634 
17 .3 Random Set: Write a method to randomly generate a set of m integers from an array of size n. Each 
element must have equal probability of being chosen. 
Hints: #494, #596 
17.4 Missing Number: An array A contains all the integers fro"
1075,430,"elements of A are represented in binary, and the only operation we can use to access them is ""fetch 
the jth bit of A[ i ],""which takes constant time. Write code to find the missing integer. Can you do 
it inO(n) time? 
Hints: #6 7 0, #659, #683 
17 .5 Letters and Numbers: Given an array filled with"
1076,330,"Hints: #485, #575, #679, #677, #773 
17.6 Count of 2s: Write a method to count the number of 2s that appear in all the numbers between O 
and n (inclusive). 
EXAMPLE 
Input: 25 
Output: 9 (2, 12, 20, 21, 22, 23, 24 and 25. Note that 22 counts for two 2s.) 
Hints: #573, #6 7 2, #641 
186 Cracking the"
1077,510,"Chapter 17 I Hard 
17.7 Baby Names: Each year, the government releases a list of the 10000 most common baby names 
and their frequencies (the number of babies with that name). The only problem with this is that 
some names have multiple spellings. For example, ""John"" and ''.Jon"" are essentially the "
1078,465,"name. Note that if John and Jon are synonyms, and Jon and Johnny are synonyms, then John and 
Johnny are synonyms. (It is both transitive and symmetric.) In the final list, any name can be used 
as the ""real"" name. 
EXAMPLE 
Input: 
Names: John (15), Jon (12), Chris (13), Kris (4), Christopher (19) "
1079,447,"Hints:#478, #493, #512, #537, #586, #605, #655, #675, #704 
17 .8 Circus Tower: A circus is designing a tower routine consisting of people standing atop one anoth­
er's shoulders. For practical and aesthetic reasons, each person must be both shorter and lighter 
than the person below him or her. Giv"
1080,446,"EXAMPLE 
lnput(ht,wt): (65, 100) (70, 150) (56, 90) (75, 190) (60, 95) (68, 110) 
Output: The longest tower is length 6 and includes from top to bottom: 
(56, 90) (60,95) (65,100) (68,110) (70,150) (75,190) 
Hints: #638, #657, #666, #682, #699 
''''''''''''''''''' ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"
1081,423,"and 7. Note that 3, 5, and 7 do not have to be factors, but it should not have any other prime factors. 
For example, the first several multiples would be (in order) 1, 3, 5, 7, 9, 15, 21. 
Hints:#488,#508,#550,#591,#622,#660,#686 
_ ·--··· --·--··--····-··-- ····-·-·-···-----·-···----·-··--·-···---"
1082,510,"an array. Given a positive integers array, find the majority element. If there is no majority element, 
return-1. Do this inO(N) time and 0(1) space. 
EXAMPLE 
Input: 
Output: 
1 2 5 9 5 9 5 5 5 
5 
Hints: #522, #566, #604, #620, #650 
. ,,,,,,,,,,,,,,,,,,,,,,,.''''''''''''''''''''''''''''''''''''pg"
1083,229,"many times for the same file (but different pairs of words), can you optimize your solution? 
Hints: #486, #501, #538, #558, #633 
·--···--- -···-- -·-""""·""--··- ---- -- ____ pg 557
CrackingTheCodinglnterview.com \ 6th Edition 187"
1084,481,"Chapter 17 I Hard
17.12 BiNode: Consider a simple data structure called BiNode, which has pointers to two other nodes. 
public class BiNode { 
} 
public BiNode nodel, node2; 
public int data; 
The data structure BiNode could be used to represent both a binary tree (where nodel is the left 
node and "
1085,479,"BiNode) into a doubly linked list. The values should be kept in order and the operation should be 
performed in place (that is, on the original data structure). 
Hints: #509, #608, #646, #680, #707, #779 
17 .13 Re-Space: Oh, no! You have accidentally removed all spaces, punctuation, and capitalizat"
1086,470,"talization later; right now you need to re-insert the spaces. Most of the words are in a dictionary but 
a few are not. Given a dictionary (a list of strings) and the document (a string), design an algorithm 
to unconcatenate the document in a way that minimizes the number of unrecognized characters"
1087,508,"Hints: #496, #623, #656, #677, #739, #749
17.14 Smallest K: Design an algorithm to find the smallest K numbers in an array. 
Hints: #470, #530, #552, #593, #625, #647, #661, #678
17 .15 Longest Word: Given a list of words, write a program to find the longest word made of other words 
in the list. 
E"
1088,463,"and is debating which ones to accept. She needs a 15-minute break between appointments and 
therefore she cannot accept any adjacent requests. Given a sequence of back-to-back appoint­
ment requests (all multiples of 15 minutes, none overlap, and none can be moved), find the optimal 
(highest total "
1089,158,"Output:180 minutes ({30, 60, 45, 45}). 
Hints: #495, #504, #576, #526, #542, #554, #562, #568, #578, #587, #607
188 Cracking the Coding Interview, 6th Edition"
1090,444,"Chapter 17 I Hard 
17.17 Multi Search: Given a string band an array of smaller strings T, design a method to search b for 
each small string in T. 
Hints:#480, #582, #617, #743 
pg 578 
17.18 Shortest Supersequence: You are given two arrays, one shorter (with all distinct elements) and one 
longer. "
1091,470,"array. The items can appear in any order. 
EXAMPLE 
lnput:{1, 5, 9} I {7, 5, 9, 0, 2, 1, 3, 5, 7, 9. 1, 1, 5, 8, 8, 9, 7} 
Output: [ 7, 10] (the underlined portion above) 
Hints: #645, #652, #669, #687, #697, #725, #731, #741
17.19 Missing Two: You are given an array with all the numbers from 1 to N"
1092,493,"0(1) space? What if there were two numbers missing? 
Hints: #503, #590, #609, #626, #649, #672, #689, #696, #702, #717
······-·--···-······-····- ··········-· ····-· . ·····-··········-·······-· ._pg 591
17.20 Continuous Median: Numbers are randomly generated and passed to a method. Write a program "
1093,497,"volume of water it could hold if someone poured water across the top. You can assume that each 
histogram bar has width 1. 
EXAMPLE (Black bars are the histogram. Gray is water.) 
lnput:{0, 0, 4, 0, 0, 6, 0, 0, 3, 0, 5, 0, 1, 0, 0, 0} 
0040060030501000 
Output: 26 
Hints:#629,#640,#657,#658,#662,#67"
1094,368,"transform one word into 
another word by changing only one letter at a time. The new word you get 
in each step must be in the dictionary. 
EXAMPLE 
Input: DAMP, LIKE 
Output: DAMP-> LAMP-> LIMP-> LIME-> LIKE 
Hints: #506, #535, #556, #580, #598, #618, #738
-········- ·····-· ······-·······-······ ·"
1095,481,"Chapter 17 I Hard 
17 .23 Max Black Square: Imagine you have a square matrix, where each cell (pixel) is either black or white 
Design an algorithm to find the maximum subsquare such that all four borders are filled with black 
pixels. 
Hints: #684, #695, #705, #714, #721, #736 
17.24 Max Submatrix:"
1096,465,"Hints: #469, #511, #525, #539, #565, #581, #595, #615, #621 
17 .25 Word Rectangle: Given a list of millions of words, design an algorithm to create the largest possible 
rectangle of letters such that every row forms a word (reading left to right) and every column forms 
a word (reading top to bott"
1097,464,"Hints: #477, #500, #748 
17 .26 Sparse Similarity: The similarity of two documents (each with distinct words) is defined to be the 
size of the intersection divided by the size of the union. For example, if the documents consist of 
integers, the similarity of { 1, 5, 3} and { 1, 7, 2, 3} is 0. 4, b"
1098,506,"similarity is believed to be ""sparse:'That is, any two arbitrarily selected documents are very likely to 
have similarity 0. Design an algorithm that returns a list of pairs of document IDs and the associated 
similarity. 
Print only the pairs with similarity greater than 0. Empty documents should n"
1099,315,"16: {32, 1, 9, 3, 5} 
19: {15, 29, 2, 6, 8, 7} 
24: {7, 10} 
Output: 
ID1, ID2 SIMILARITY 
13, 19 0.1 
13, 16 0.25 
19, 24 0.14285714285714285 
Hints: #484, #498, #510, #518, #534, #547, #555, #561, #569, #577, #584, #603, #611, #636 
Cracking the Coding Interview, 6th Edition 
I 
I \ 
' 
' i 
� 
� "
1100,417,"1 
Solutions to Arrays and Strings 
1.1 Is Unique: Implement an algorithm to determine if a string has all unique characters. What if you 
cannot use additional data structures? 
pg90
SOLUTION 
You should first ask your interviewer if the string is an ASCII string or a Unicode string. Asking this qu"
1101,432,"acter set is ASCII. If this assumption is not valid, we would need to increase the storage size. 
One solution is to create an array of boolean values, where the flag at index i indicates whether character 
i in the alphabet is contained in the string. The second time you see this character you can "
1102,487,"alphabet. After all, you can't form a string of 280 unique characters out of a 128-character alphabet. 
I 
It's also okay to assume 256 characters. This would be the case in extended ASCII. You should 
clarify your assumptions with your interviewer. 
The code below implements this algorithm. 
1 bool"
1103,491,"6 int val= str.charAt(i); 
7 if (char_set[val]) {//Already found this char in string 
8 return false; 
9 } 
10 char_set[val] = true; 
11 } 
12 return true; 
13 }
The time complexity for this code isO( n ), where n is the length of the string. The space complexity isO(l ). 
(You could also argue the "
1104,139,"O( c) space and O(min ( c, n)) or O( c) time, where c is the size of the character set. 
192 Cracking the Coding Interview, 6th Edition 
t;"
1105,507,"Solutions to Chapter 1 I Arrays and Strings 
We can reduce our space usage by a factor of eight by using a bit vector. We will assume, in the below code, 
that the string only uses the lowercase letters a through z. This will allow us to use just a single int. 
1 boolean isUniqueChars(String str) { "
1106,490,"7 } 
8 checker I= (1 << val); 
9 } 
10 return true; 
11 } 
If we can't use additional data structures, we can do the following: 
1. Compare every character of the string to every other character of the string. This will take 0( n2) time
and 0(1) space.
2. If we are allowed to modify the input string"
1107,483,"algorithms take up extra space.
These solutions are not as optimal in some respects, but might be better depending on the constraints of 
the problem. 
1.2 Check Permutation: Given two strings, write a method to decide if one is a permutation of the 
other. 
pg90
SOLUTION 
Like in many questions, we"
1108,485,"ask if whitespace is significant. We will assume for this problem that the comparison is case sensitive and 
whitespace is significant. So, ""god ""i s different from ""dog"". 
Observe first that strings of different lengths cannot be permutations of each other. There are two easy 
ways to solve this pr"
1109,441,"fore, sorting the strings will put the characters from two permutations in the same order. We just need to 
compare the sorted versions of the strings. 
1 String sort(String s) { 
2 char[] content= s.toCharArray(); 
3 java.util.Arrays.sort(content); 
4 return new String(content); 
5 } 
6 
7 boolean "
1110,458,"Solutions to Chapter 1 I Arrays and Strings 
11 return sort(s).equals(sort(t)); 
12 } 
Though this algorithm is not as optimal in some senses, it may be preferable in one sense: It's clean, simple 
and easy to understand. In a practical sense, this may very well be a superior way to implement the pr"
1111,502,"We can also use the definition of a permutation-two words with the same character counts-to imple­
ment this algorithm. We simply iterate through this code, counting how many times each character appears. 
Then, afterwards, we compare the two arrays. 
1 boolean permutation(String s, String t) { 
2 i"
1112,432,"char[] s_array = s.toCharArray(); 
for (char c : s_array) { II count number of each char in s. 
letters[c]++; 
} 
for (int i= 0; i < t.length(); i++) { 
int c = (int) t.charAt(i); 
letters[c]--; 
if (letters[c] < 0) { 
return false; 
} 
} 
return true; 
Note the assumption on line 6. In your intervi"
1113,423,"1.3 URLify: Write a method to replace all spaces in a string with '%20'. You may assume that the string 
has sufficient space at the end to hold the additional characters, and that you are given the ""true"" 
length of the string. (Note: if implementing in Java, please use a character array so that yo"
1114,354,"Output: ""Mr%20John%20Smith"" 
pg90 
SOLUTION 
A common approach in string manipulation problems is to edit the string starting from the end and working 
backwards. This is useful because we have an extra buffer at the end, which allows us to change characters 
without worrying about what we're overwr"
1115,511,"Solutions to Chapter 1 I Arrays and Strings 
We will use this approach in this problem. The algorithm employs a two-scan approach. In the first scan, we 
count the number of spaces. By tripling this number, we can compute how many extra characters we will 
have in the final string. In the second pas"
1116,492,"The code below implements this algorithm. 
1 void replaceSpaces(char(J str, int trueLength) { 
2 int spaceCount = 0, index, i = 0; 
3 for (i - 0; i < trueLength; i++) { 
4 if (str[i] == ' ') { 
5 spaceCount++; 
6 } 
7 } 
g 
9 
10 
11 
12 
B 
14 
index = truelength + spaceCount * 2; 
if (truelength <"
1117,478,"str[index - 3] = '%'; 
15 index = index - 3; 
16 } else { 
17 str[index - 1] = str[i]; 
18 index--; 
19 } 
20 } 
21 } 
'\0'; II End array 
We have implemented this problem using character arrays, because Java strings are immutable. If we used 
strings directly, the function would have to return a ne"
1118,495,"a palindrome. A palindrome is a word or phrase that is the same forwards and backwards. A 
permutation is a rearrangement of letters. The palindrome does not need to be limited to just 
dictionary words. 
EXAMPLE 
Input: Tact Coa 
Output: True (permutations: ""taco cat'; ""atco eta·; etc.) 
pg 97 
SOL"
1119,509,"A palindrome is a string that is the same forwards and backwards. Therefore, to decide if a string is a permu­
tation of a palindrome, we need to know if it can be written such that it's the same forwards and backwards. 
What does it take to be able to write a set of characters the same way forwards"
1120,152,"For example, we know tactc oapapa is a permutation of a palindrome because it has two Ts, four As, two 
CrackingTheCodinglnterview.com I 6th Edition 195"
1121,503,"Solutions to Chapter 1 I Arrays and Strings 
Cs, two Ps, and one 0. That O would be the center of all possible palindromes. 
I 
To be more precise, strings with even length (after removing all non-letter characters) must have 
all even counts of characters. Strings of an odd length must have exactly"
1122,451,"number). Likewise, a string with odd length can't have all characters with even counts (sum of 
evens is even). It's therefore sufficient to say that, to be a permutation ot a palindrome, a string 
can have no more than one character that is odd. This will cover both the odd and the even cases. 
Thi"
1123,498,"character appears. Then, we iterate through the hash table and ensure that no more than one character has 
an odd count. 
1 boolean isPermutationOfPalindrome(String phrase) { 
2 int[] table = buildCharFrequencyTable(phrase); 
3 return checkMaxOneOdd(table); 
4 } 
5 
6 /* Check that no more than one "
1124,486,"11 if (foundOdd) { 
12 return false; 
13 } 
14 foundOdd = true; 
15 } 
16 } 
17 return true; 
18 } 
19 
20 /* Map each character to a number. a- > 0, b -> 1, c -> 2, etc. 
21 * This is case insensi tive. Non-letter characters map to -1. */
22 int getCharNumber(Character c) { 
23 int a= Character.get"
1125,369,"27 return val - a; 
28 } 
29 return -1; 
30 } 
31 
32 /* Count how many times each character appears. */ 
33 int[] buildCharFrequencyTable(String phrase) { 
34 int[] table new int[Character.getNumericValue('z') 
35 Character.getNumericValue('a') + 1]; 
36 for (char c phrase.toCharArray()) { 
37 int "
1126,499,"Solutions to Chapter 1 I Arrays and Strings 
38 if (x != -1) { 
39 table[x]++; 
40 } 
41 } 
42 return table; 
43 } 
This algorithm takes O ( N) time, where N is the length of the string. 
Solution #2 
We can't optimize the big O time here since any algorithm will always have to look through the enti"
1127,500,"Instead of checking the number of odd counts at the end, we can check as we go along. Then, as soon as 
we get to the end, we have our answer. 
1 boolean isPermutationOfPalindrome(String phrase) { 
2 int countOdd = 0; 
3 int[] table new int[Character.getNumericValue('z') -
4 Character.getNumericValu"
1128,503,"10 countOdd++; 
11 } else { 
12 countOdd--; 
13 } 
14 } 
15 } 
16 return countOdd <= 1; 
17 } 
It's important to be very clear here that this is not necessarily more optimal. It has the same big O time and 
might even be slightly slower. We have eliminated a final iteration through the hash table, b"
1129,463,"Solution #3 
If you think more deeply about this problem, you might notice that we don't actually need to know the 
counts. We just need to know if the count is even or odd. Think about flipping a light on/off (that is initially 
off). If the light winds up in the off state, we don't know how many t"
1130,464,"between O and 26 (assuming an English alphabet). Then we toggle the bit at that value. At the end of the 
iteration, we check that at most one bit in the integer is set to 1. 
We can easily check that no bits in the integer are 1: just compare the integer to 0. There is actually a very 
elegant way "
1131,156,"a single 1. Alternatively, if we subtract 1 from the number, we'll get 00001111. What's notable about this 
CrackingTheCodinglnterview.com j 6th Edition 197"
1132,508,"Solutions to Chapter 1 I Arrays and Strings 
is that there is no overlap between the numbers (as opposed to say 00101000, which, when we subtract 1 
from, we get 00100111.) So, we can check to see that a number has exactly one 1 because if we subtract 1 
from it and then AND it with the new number, "
1133,510,"2 int bitVector = createBitVector(phrase); 
3 return bitVector == 0 I I checkExactlyOneBitSet(bitVector); 
4 } 
5 
6 /* Create a bit vector for the string. For each letter with value i, toggle the 
7 * ith bit. */
8 int createBitVector(String phrase) { 
9 int bitVector = 0; 
10 for (char c : phrase."
1134,473,"18 int toggle(int bitVector, int index) { 
19 if (index < 0) return bitVector; 
20 
21 
22 
23 
24 
25 
int mask= 1 << index; 
if ((bitVector & mask) 
bitVector I= mask; 
} else { 
bitVector &= =mask; 
26 } 
27 return bitVector; 
28 } 
29 
0) {
30 /* Check that exactly one bit is set by subtracting "
1135,424,"33 return (bitVector & (bitVector - 1)) == 0; 
34 } 
Like the other solutions, this is O(N). 
It's interesting to note a solution that we did not explore. We avoided solutions along the lines of""create 
all possible permutations and check if they are palindromes:'While such a solution would work, it"
1136,498,"exponential time), and it is essentially infeasible to perform on strings longer than about 10-15 characters. 
I mention this (impractical) solution because a lot of candidates hear a problem like this and say, ""In order 
to check if A is in group B, I must know everything that is in B and then chec"
1137,102,"permutations in order to check if one is a palindrome. 
198 Cracking the Coding Interview, 6th Edition"
1138,492,"Solutions to Chapter 1 I Arrays and Strings 
1.s One Away: There are three types of edits that can be performed on strings: insert a 
character, 
remove a character, or replace a character. Given two strings, write a function to check if they are 
one edit (or zero edits) away. 
EXAMPLE 
pale, ple -"
1139,466,"testing the removal of each character (and comparing), testing the replacement of each character (and 
comparing), and then testing the insertion of each possible character (and comparing). 
That would be too slow, so let's not bother with implementing it. 
This is one of those problems where it's h"
1140,422,"Replacement: Consider two strings, such as bale and pale, that are one replacement away. Yes, that 
does mean that you could replace a character in bale to make pale. But more precisely, it means that 
they are different only in one place. 
• Insertion: The strings apple and aple are one insertion a"
1141,492,"• Removal: The strings apple and aple are also one removal away, since removal is just the inverse of
insertion.
We can go ahead and implement this algorithm now. We'll merge the insertion and removal check into one 
step, and check the replacement step separately. 
Observe that you don't need to ch"
1142,488,"1 boolean oneEditAway(String first, String second) { 
2 if (first.length()== second.length()) { 
3 return oneEditReplace(first, second); 
4 } else if (first.length()+ 1 == second.length()) { 
5 return oneEditinsert(first, second); 
6 } else if (first.length() - 1 == second.length()) { 
7 return oneE"
1143,188,"14 for (int i= 0; i < sl.length(); i++) { 
15 if (sl.charAt(i) != s2.charAt(i)) { 
16 if (foundDifference) { 
17 
18 
19 
} 
return false; 
CrackingTheCodinglnterview.com I 6th Edition 199"
1144,511,"Solutions to Chapter 1 I Arrays and Strings 
20 foundDifference = true; 
21 } 
22 } 
23 return true; 
24 } 
25 
26 /* Check if you can insert a character into sl to make s2. */ 
27 boolean oneEditinsert(String sl, String s2) { 
28 int indexl = 0; 
29 int index2 = 0; 
30 while (index2 < s2.length() &"
1145,485,"37 indexl++; 
38 index2++; 
39 } 
40 } 
41 return true; 
42 } 
This algorithm (and almost any reasonable algorithm) takes O ( n) time, where n is the length of the shorter 
string. 
I 
Why is the runtime dictated by the shorter string instead of the longer string? If the strings are 
the same length"
1146,414,"algorithm will terminate in 0( 1) time. One really, really long string therefore won't significantly 
extend the runtime. It increases the runtime only if both strings are long. 
We might notice that the code for one Edi tReplace is very simtlar to that for one Edi tinsert. We can 
merge them into o"
1147,479,"strings are only different by one. The methods vary in how they handle that difference. The method 
one Edi tReplace does nothing other than flag the difference, whereas one Edi tinsert increments 
the pointer to the longer string. We can handle both of these in the same method. 
1 boolean oneEditAw"
1148,427,"4 return false; 
5 } 
6 
7 /* Get shorter and longer string.*/ 
8 String sl first.length()< second.length() ? first : second; 
9 String s2 =first.length()< second.length() ? second : first; 
10 
11 int indexl = 0; 
12 int index2 = 0; 
13 boolean foundDifference = false; 
14 while (index2 < s2.length"
1149,417,"Solutions to Chapter 1 I Arrays and Strings 
16 /* Ensure that this is the first difference found.*/ 
17 if (foundDifference) return false; 
18 foundDifference = true; 
19 
20 if (sl.length() == s2.length()) {//On replace, move shorter pointer 
21 indexl++; 
22 } 
23 } else { 
24 indexl++; // If mat"
1150,473,"27 } 
28 return true; 
29 } 
Some people might argue the first approach is better, as it is clearer and easier to follow. Others, however, 
will argue that the second approach is better, since it's more compact and doesn't duplicate code (which 
can facilitate maintainability). 
You don't necessaril"
1151,411,"of repeated characters. For example, the string aabcccccaaa would become a2blc5a3. If the 
""compressed"" string would not become smaller than the original string, your method should return 
the original string. You can assume the string has only uppercase and lowercase letters (a - z). 
pg91
SOLUTION"
1152,487,"through the string, copying characters to a new string and counting the repeats. At each iteration, check 
if the current character is the same as the next character. If not, add its compressed version to the result. 
How hard could it be? 
1 String compressBad(String str) { 
2 String compressedStri"
1153,437,"8 if (i + 1 >= str.length() I I str.charAt(i) != str.charAt(i + 1)) { 
9 compressedString += """" + str. charAt ( i) + countConsecuti ve; 
10 countConsecutive = 0; 
11 } 
12 } 
13 return compressedString.length() < str.length() ? compressedString str; 
14 }
This works. ls it efficient, though?Take a l"
1154,276,"sequences. For example, if the string is aabccdeeaa, then there are six characte sequences. It's slow 
because string concatenation operates in O(n2 ) time (see StringBuilder on pg 8 ). 
We can fix this by using a StringBuilder. 
CrackingTheCodinglnterview.com 6th Editiqn 201"
1155,492,"Solutions to Chapter 1 I Arrays and Strings 
1 String compress(String str) { 
2 StringBuilder compressed= new StringBuilder(); 
3 int countConsecutive = 0; 
4 for (int i= 0; i < str.length(); i++) { 
5 countConsecutive++; 
6 
7 /* If next character is different than current, append this char to resu"
1156,477,"11 countConsecutive = 0; 
12 } 
13 } 
14 return compressed.length() < str.length() ? compressed.toString() : str; 
15 } 
Both of these solutions create the compressed string first and then return the shorter of the input string 
and the compressed string. 
Instead, we can check in advance. This will"
1157,467,"it causes a second loop through the characters and also adds nearly duplicated code. 
1 String compress(String str) { 
2 /* Check final length and return input string if it would be longer. */ 
3 int finallength = countCompression(str); 
4 if (finallength >= str.length()) return str; 
5 
6 StringBui"
1158,510,"9 countConsecutive++; 
10 
11 /* If next character is different than current, append this char to result.*/ 
12 if (i + 1 >= str.length() I I str.charAt(i) != str.charAt(i + 1)) { 
13 compressed.append(str.charAt(i)); 
14 compressed.append(countConsecutive); 
15 countConsecutive = 0; 
16 } 
17 } 
18"
1159,365,"25 countConsecutive++; 
26 
27 /* If next character is different than current, increase the length.*/ 
28 if (i + 1 >= str.length() I I str.charAt(i) != str.charAt(i + 1)) { 
29 compressedlength += 1 + String.valueOf(countConsecutive).length(); 
30 countConsecutive = 0; 
31 } 
32 } 
33 return compre"
1160,511,"Solutions to Chapter 1 I Arrays and Strings 
One other benefit of this approach is that we can initialize StringBuilder to its necessary capacity 
up-front. Without this, StringBuilder will (behind the scenes) need to double its capacity every time it 
hits capacity. The capacity could be double wha"
1161,422,"pg91
SOLUTION 
Because we're rotating the matrix by 90 degrees, the easiest way to do this is to implement the rotation in 
layers. We perform a circular rotation on each layer, moving the top edge to the right edge, the right edge 
to the bottom edge, the bottom edge to the left edge, and the left "
1162,443,"move the left to the top, the bottom to the left, and so on. This requires O(N) memory, which is actually 
unnecessary. 
A better way to do this is to implement the swap index by index. In this case, we do the following: 
1 for i = 0 to n 
2 temp= top[i]; 
3 top[i] = left[i] 
4 left[i] = bottom[i] 
"
1163,464,"(Alternatively, we could start from the inner layer and work outwards.) 
The code for this algorithm is below. 
1 boolean rotate(int[][] matrix) { 
2 if (matrix.length== 0 I I matrix.length != matrix[0].length) return false; 
3 int n = matrix.length; 
4 for (int layer = 0; layer < n / 2; layer++) { "
1164,436,"Solutions to Chapter 1 I Arrays and Strings 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 } 
} 
} 
int top= matrix[first][i]; II save top 
II left -> top 
matrix[first][i] matrix[last-offset][first]; 
II bottom -> left 
matrix[last-offset][first] 
II right -> bottom 
matrix[last"
1165,410,"matrix[i][last] top; II right<- saved top 
return true; 
This algorithm is O ( N2 ), which is the best we can do since any algorithm must touch all N2 elements. 
1.8 Zero Matrix: Write an algorithm such that if an element in an MxN matrix is 0, its entire row and 
column are set to 0. 
pg91 
SOLUTIO"
1166,436,"value zero, set its row and column to 0. There's one problem with that solution though: when we come 
across other cells in that row or column, we'll see the zeros and change their row and column to zero. Pretty 
soon, our entire matrix will be set to zeros. 
One way around this is to keep a second "
1167,495,"Do we really need O(MN) space? No. Since we're going to set the entire row and column to zero, we don't 
need to track that it was exactly cell [ 2] [ 4] (row 2, column 4). We only need to know that row 2 has a 
zero somewhere, and column 4 has a zero somewhere. We'll set the entire row and column t"
1168,511,"the columns with zeros. We then nullify rows and columns based on the values in these arrays. 
1 void setZeros(int[][] matrix) { 
2 boolean[] row = new boolean[matrix .length]; 
3 boolean[] column = new boolean[matrix[0].length]; 
4 
5 II Store the row and column index with value 0 
6 for (int i= 0;"
1169,470,"Solutions to Chapter 1 I Arrays and Strings 
15 // Nullify rows 
16 for (int i= 0; i < row.length; i++) { 
17 if (row[i]) nullifyRow(matrix, i); 
18 } 
19 
20 // Nullify columns 
21 for (int j = 0; j < column.length; j++) { 
22 if (column[j]) nullifyColumn(matrix, j); 
23 } 
24 } 
25 
26 void nullif"
1170,443,"30 } 
31 
32 void nullifyColumn(int[][] matrix, int col) { 
33 for (int i= 0; i < matrix.length; i++) { 
34 matrix[i][col] = 0; 
35 } 
36 } 
To make this somewhat more space efficient we could use a bit vector instead of a boolean array. It would 
still be O(N) space. 
We can reduce the space to 0(1"
1171,498,"1. Check if the first row and first column have any zeros, and set variables rowHasZero and
columnHasZero. (We'll nullify the first row and first column later, if necessary.)
2. Iterate through the rest of the matrix, setting matrix[ i] [ 0) and matrix [ 0) [ j] to zero whenever
there's a zero in ma"
1172,506,"5. Nullify the first row and first column, if necessary (based on values from Step 1 ). 
This code is below: 
1 void setzeros(int[][] matrix) { 
2 boolean rowHasZero = false; 
3 boolean colHasZero = false; 
4 
5 // Check if first row has a zero 
6 for (int j = 0; j < matrix[0].length; j++) { 
7 if ("
1173,111,"15 if (matrix[i][0] == 0) { 
16 colHasZero = true; 
17 break; 
CrackingTheCodinglnterview.com I 6th Edition 20S"
1174,497,"Solutions to Chapter 1 I Arrays and Strings 
18 
19 
2.0 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32. 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 } 
} 
} 
// Check for zeros in the rest of the array 
for (int i= 1; i < matrix.length; i++) { 
} 
for (in"
1175,504,"for (int i= 1; i < matrix.length; i++) { 
if (matrix[i][0] == 0) { 
nullifyRow(matrix, i); 
} 
} 
// Nullify columns based on values in first row 
for (int j = 1; j < matrix[0].length; j++) { 
if (matrix[0][j] == 0) { 
nullifyColumn(matrix, j); 
} 
} 
// Nullify first row 
if (rowHasZero) { 
nullify"
1176,509,"could abbreviate this code by adding comments and TODOs that explain that the next chunk of code looks 
the same as the earlier code, but using rows. This would allow you to focus on the most important parts of 
the algorithm. 
1.9 String Rotation: Assume you have a method i 5Su b 5 tr ing which che"
1177,335,"pg91 
SOLUTION 
If we imagine that 52 is a rotation of 51, then we can ask what the rotation point is. For example, if you 
rotate waterbottle after wat. you get erbottlewat. In a rotation, we cut 51 into two parts, x and y, 
and rearrange them to get 52. 
51 = xy = waterbottle 
x = wat 
206 Crackin"
1178,502,"Solutions to Chapter 1 I Arrays and Strings 
y = erbottle 
s2 = yx = erbottlewat 
So, we need to check if there's a way to split s1 into x and y such that xy = s1 and yx = s2. Regardless of 
where the division between x and y is, we can see thatyx will always be a substring of xyxy.That is, s2 will "
1179,501,"1 boolean isRotation(String sl, String s2) { 
2 int len = sl.length(); 
3 /* Check that sl and s2 are equal length and not empty*/ 
4 if (len == s2.length() && len > 0) { 
5 /* Conca tenate sl and sl within new buffer */ 
6 String slsl = sl + sl; 
7 return isSubst ring(slsl, s2); 
8 } 
9 return fals"
1180,48,CrackingTheCodinglnterview.com J 6th Edition 207
1181,449,"2 
Solutions to Linked Lists 
2.1 Remove Dups: Write code to remove duplicates from an unsorted linked list. 
FOLLOW UP 
How would you solve this problem if a temporary buffer is not allowed? 
SOLUTION 
pg94 
In order to remove duplicates from a linked list, we need to be able to track duplicates. A"
1182,433,"we discover a duplicate element, we remove the element and continue iterating. We can do this all in one 
pass since we are using a linked list. 
1 void deleteDups( LinkedListNode n) { 
2 HashSet<Integer> set = new HashSet<Integer>(); 
3 LinkedListNode previous = null; 
4 while (n != null) { 
5 if ("
1183,504,"9 previous = n; 
10 } 
11 n = n.next; 
12 } 
13 } 
The above solution takes O(N) time, where N is the number of elements in the linked list. 
Follow Up: No Buffer Allowed 
lfwe don't have a buffer, we can iterate with two pointers: current which iterates through the linked list, 
and runner which ch"
1184,216,"4 /* Remove all future nodes that have the same value */ 
5 LinkedListNode runner = current; 
6 while (runner.next != null) { 
7 if (runner.next.data == current.data) { 
208 Cracking the Coding Interview, 6th Edition"
1185,442,"Solutions to Chapter 2 I Linked Lists
8 
9 
10 
runner.next = runner.next.next; 
} else { 
runner = runner.next; 
11 } 
12 } 
13 current current.next; 
14 } 
15 } 
This code runs in O ( 1) space, but O ( N2) time. 
2.2 Return Kth to Last: Implement an algorithm to find the kth to last element of a s"
1186,475,"often cleaner but less optimal. For example, in this problem, the recursive implementation is about half the 
length of the iterative solution but also takes 0( n) space, where n is the number of elements in the linked 
list. 
Note that for this solution, we have defined k such that passing ink = 1 "
1187,488,"= 0 would return the last element. 
Solution #1: If linked list size is known 
If the size of the linked list is known, then the kth to last element is the ( length - k)th element. We can 
just iterate through the linked list to find this element. Because this solution is so trivial, we can almost b"
1188,410,"to 0. Each parent call adds 1 to this counter. When the counter equals k, we know we have reached the kth 
to last element of the linked list. 
Implementing this is short and sweet-provided we have a way of""passing back"" an integer value through 
the stack. Unfortunately, we can't pass back a node a"
1189,476,"do we handle this? 
Approach A: Don't Return the Element. 
One way to do this is to change the problem to simply printing the kth to last element. Then, we can pass 
back the value of the counter simply through return values. 
1 int printKthToLast(LinkedlistNode head, int k) { 
2 if (head== null) { "
1190,76,"8 } 
9 return index; 
10 } 
CrackingTheCodinglnterview.com / 6th Edition 209"
1191,498,"Solutions to Chapter 2 I Linked Lists 
Of course, this is only a valid solution if the interviewer says it is valid. 
Approach B: Use C ++. 
A second way to solve this is to use C++ and to pass values by reference. This allows us to return the node 
value, but also update the counter by passing a po"
1192,481,"6 i = i + 1; 
7 if (i == k) { 
8 return head; 
9 } 
10 return nd; 
11 } 
12 
13 node* nthToLast(node* head, int k) { 
14 int i = 0; 
15 return nthToLast(head, k, i); 
16 } 
Approach C: Create a Wrapper Class. 
We described earlier that the issue was that we couldn't simultaneously return a counter a"
1193,463,"reference. 
1 class Index { 
2 public int value 
3 } 
4 
0· , 
5 LinkedListNode kthTolast(LinkedlistNode head, int k) { 
6 Index idx = new Index(); 
7 return kthToLast(head, k, idx); 
8 } 
9 
10 LinkedListNode kthToLast(LinkedListNode head, int k, Index idx) { 
11 if (head== null) { 
12 return null;"
1194,503,"17 return head; 
18 } 
19 return node; 
20 } 
Each of these recursive solutions takes 0( n) space due to the recursive calls. 
There are a number of other solutions that we haven't addressed. We could store the counter in a static vari­
able. Or, we could create a class that stores both the node and"
1195,100,"way that all levels of the recursive stack will see. 
210 Cracking the Coding Interview, 6th Edition"
1196,489,"Solutions to Chapter 2 I Linked Lists 
Solution #3: Iterative 
A more optimal, but less straightforward, solution is to implement this iteratively. We can use two pointers, 
pl and p2. We place them k nodes apart in the linked list by putting p2 at the beginning and moving pl 
k nodes into the list."
1197,486,"The code below implements this algorithm. 
1 LinkedListNode nthTolast(LinkedListNode head, int k) { 
2 LinkedlistNode pl head; 
3 LinkedlistNode p2 = head; 
4 
5 /* Move pl k nodes into the list.*/ 
6 for (int i= 0; i < k; i++) { 
7 if (pl == null) return null; // Out of bounds 
8 pl = pl.next; 
9 }"
1198,485,"14 pl pl.next; 
15 p2 = p2.next; 
16 } 
17 return p2; 
18 } 
This algorithm takes O(n) time and 0(1) space. 
2.3 Delete Middle Node: Implement an algorithm to delete a node in the middle (i.e., any node but 
the first and last node, not necessarily the exact middle) of a singly linked list, given on"
1199,499,"pg94 
SOLUTION 
In this problem, you are not given access to the head of the linked list. You only have access to that node. 
The solution is simply to copy the data from the next node over to the current node, and then to delete the 
next node. 
The code below implements this algorithm. 
1 boolean "
1200,112,"6 n.data = next.data;
7 n.next = next.next;
8 return true;
9 } 
CrackingTheCodinglnterview.com / 6th Edition 211"
1201,409,"Solutions to Chapter 2 I Linked Lists
Note that this problem cannot be solved if the node to be deleted is the last node in the linked list. That's 
okay-your interviewer wants you to point that out, and to discuss how to handle this case. You could, for 
example, consider marking the node as dummy."
1202,414,"before all nodes greater than or equal to x. If xi s contained within the list the values of x only need 
to be after the elements less than x (see below). The partition element x can appear anywhere in the 
""right partition""; it does not need to appear between the left and right partitions. 
EXAMPL"
1203,406,"Output: 3 -> 1 -> 2 -> 10 -> 5 -> 5 -> 8
pg94 
SOLUTION 
If this were an array, we would need to be careful about how we shifted elements. Array shifts are very 
expensive. 
However, in a linked list, the situation is much easier. Rather than shifting and swapping elements, we can 
actually create t"
1204,466,"equal to x. 
We iterate through the linked list, inserting elements into our before list or our after list. Once we reach 
the end of the linked list and have completed this splitting, we merge the two lists. 
This approach is mostly ""stable"" in that elements stay in their original order, other than"
1205,486,"2 LinkedListNode partition(LinkedListNode node, int x) { 
3 LinkedlistNode beforeStart = null; 
4 LinkedListNode beforeEnd = null; 
5 LinkedListNode afterStart = null; 
6 LinkedListNode afterEnd = null; 
7 
8 /* Partition list*/ 
9 while (node!= null) { 
10 LinkedListNode next= node.next; 
11 node.n"
1206,318,"18 
19 
26 
21 
22 
23 
24 
25 
25 
212 
beforeStart = node; 
beforeEnd = beforeStart; 
} else { 
} 
beforeEnd.next = node; 
beforeEnd = node; 
} else { 
/* Insert node into end of after list*/ 
if (afterStart == null) { 
afterStart = node; 
afterEnd = afterStart; 
} else { 
Cracking the Coding Inte"
1207,436,"27 
28 
29 
30 } 
} 
afterEnd.next = node; 
afterEnd = node; 
31 node next; 
32 } 
33 
34 if (beforeStart == null) { 
35 return afterStart; 
36 } 
37 
38 /* Merge before list and after list */ 
39 beforeEnd.next = afterStart; 
40 return beforeStart; 
41 }
Solutions to Chapter 2 I Linked Lists 
If it"
1208,498,"make this code a bit shorter. 
If we don't care about making the elements of the list ""stable"" (which there's no obligation to, since the 
interviewer hasn't specified that), then we can instead rearrange the elements by growing the list at the 
head and tail. 
In this approach, we start a""new"" list"
1209,507,"the head or tail. 
1 LinkedlistNode partition(LinkedlistNode node, int x) { 
2 LinkedListNode head node; 
3 LinkedListNode tail= node; 
4 
5 while (node != null) { 
6 LinkedListNode next = node.next; 
7 if (node.data < x) { 
8 /* Ins ert node at head. */ 
9 node.next= head; 
10 head= node; 
11 } els"
1210,180,"21 return head; 
22 } 
There are many equally optimal solutions to this problem. If you came up with a different one, that's okay! 
CrackingTheCodinglnterview.com I 6th Edition 213"
1211,507,"Solutions to Chapter 2 I Linked Lists
2.5 Sum Lists: You have two numbers represented by a linked list, where each node contains a single 
digit. The digits are stored in reverse order, such that the 1 's digit is at the head of the list. Write a 
function that adds the two numbers and returns the s"
1212,430,"Input: (6 -> 1 -> 7) + (2 -> 9 -> 5).That is,617 + 295. 
Output: 9 -> 1 -> 2. That is, 912. 
SOLUTION 
It's useful to remember in this problem how exactly addition works. Imagine the problem: 
6 1 7 
+ 2 9 5
pg95 
First, we add 7 and 5 to get 12. The digit 2 becomes the last digit of the number, and"
1213,462,"carried over the final step. Third and finally, we add 1, 6 and 2 to get 9. So, our value becomes 912. 
We can mimic this process recursively by adding node by node, carrying over any ""excess"" data to the next 
node. Let's walk through this for the below linked list: 
7 -> 1 -> 6 
+ 5 -> 9 -> 2
We d"
1214,510,"1 to the next sum.
List: 2 -> ?
2. We then add 1 and 9, as well as the ""carry;' getting a result of 11. 1 becomes the second element of our
linked list, and we carry the 1 to the next sum.
List: 2 -> 1 ->?
3. Finally, we add 6, 2 and our""carrY:'to get 9. This becomes the final element of our linked "
1215,255,"if (11 ==·null && 12 == null && carry== 0) { 
3 return null; 
4 } 
5 
6 LinkedlistNode result new LinkedlistNode(); 
7 int value = carry; 
8 if (11 != null) { 
9 value += 11.data; 
10 } 
11 if (12 != null) { 
214 Cracking the Coding Interview, 6th Edition"
1216,468,"12 value += 12.data; 
13 } 
14 
Solutions to Chapter 2 I Linked Lists
15 result.data value% 10; /* Second digit of number */ 
16 
17 /*Recurse */ 
18 if (11 != null II 12 != null) { 
19 LinkedlistNode more = addlists(ll == null ? null : 11.next, 
20 12 == null? null : 12 . next, 
21 value>= 10? 1 : "
1217,409,"another. We don't want to get a null pointer exception. 
Follow Up 
Part B is conceptually the same (recurse, carry the excess), but has some additional complications when it 
comes to implementation: 
1. One list may be shorter than the other, and we cannot handle this ""on the flY:' For example, su"
1218,459,"2, not the 1. We can accomplish this by comparing the lengths of the lists in the beginning and padding
the shorter list with zeros.
2. In the first part, successive results were added to the tail (i.e., passed forward). This meant that the recur­
sive call would be passed the carry, and would retur"
1219,500,"the result, as before, as well as the carry. This is not terribly challenging to implement, but it is more
cumbersome. We can solve this issue by creating a wrapper class called Partial Sum.
The code below implements this algorithm. 
1 class PartialSum { 
2 public LinkedListNode sum = null; 
3 publi"
1220,450,"9 
10 /* Pad the shorter list with zeros - see note (1) */ 
11 if (lenl < len2) { 
12 11 = padlist(ll, len2 - lenl); 
13 } else { 
14 12 = padlist(l2, lenl - len2); 
15 } 
16 
17 /* Add lists */ 
18 PartialSum sum = addListsHelper(ll, 12); 
19 
20 /* If there was a carry value left over, insert this"
1221,509,"Solutions to Chapter 2 I Linked Lists 
23 return sum.sum; 
24 } else { 
25 LinkedListNode result insertBefore(sum.sum, sum.carry); 
26 return result; 
27 } 
28 } 
2.9 
30 Partia1Sum addListsHelper(LinkedListNode 11, LinkedlistNode 12) { 
31 if (11 == null && 12 == null) { 
32 Partia1Sum sum= new Par"
1222,502,"39 int val= sum.carry + 11.data + 12.data; 
40 
41 /* Insert sum of current digits*/ 
42 LinkedListNode full_result = insertBefore(sum.sum, val% 10); 
43 
44 /* Return sum so far, and the carry value*/ 
45 sum.sum= full_result; 
46 sum.carry val/ 10; 
47 return sum; 
48 } 
49 
50 /* Pad the list wit"
1223,480,"55 } 
56 return head; 
57 } 
58 
59 /* Helper function to insert node in the front of a linked list*/ 
60 LinkedListNode insertBefore(LinkedListNode list, int data) { 
61 LinkedListNode node= new LinkedListNode(data); 
62 if (list != null) { 
63 node.next= list; 
64 } 
55 return node; 
66 } 
Note ho"
1224,357,"2.6 Palindrome: Implement a function to check if a linked list is a palindrome. 
SOLUTION 
pg95 
To approach this problem, we can picture a palindrome like 0 - > 1 - > 2 - > 1 - > 0. We know that, 
since it's a palindrome, the list must be the same backwards and forwards. This leads us to our first "
1225,449,"Solutions to Chapter 2 I Linked Lists
Solution #1: Reverse and Compare 
Our first solution is to reverse the linked list and compare the reversed list to the original list. If they're the 
same, the lists are identical. 
Note that when we compare the linked list to the reversed list, we only actuall"
1226,465,"of the normal list must match the second half of the reversed list. 
1 boolean isPalindrome(LinkedListNode head) { 
2 LinkedListNode reversed= reverseAndClone(head); 
3 return isEqual(head, reversed); 
4 } 
5 
6 LinkedlistNode reverseAndClone(LinkedListNode node) { 
7 LinkedListNode head= null; 
8 w"
1227,412,"11 head n;
12 node= node.next;
13 } 
14 return head; 
15 } 
16 
17 boolean isEqual(LinkedListNode one, LinkedListNode two) { 
18 while (one != null && two != null) { 
19 if (one.data != two.data) { 
20 
21 } 
return false; 
22 one one.next; 
23 two two.next; 
24 } 
25 return one== null && two== null"
1228,496,"class so that we can return both the head and the tail of this method. We could have also returned a two­
element array, but that approach is less maintainable. 
Solution #2: Iterative Approach 
We want to detect linked lists where the front half of the list is the reverse of the second half. How wo"
1229,419,"on whether or not we know the size of the linked list. 
If we know the size of the linked list, we can iterate through the first half of the elements in a standard for 
loop, pushing each element onto a stack. We must be careful, of course, to handle the case where the length 
of the linked list is "
1230,411,"runner technique described in the beginning of the chapter. At each step in the loop, we push the data from 
the slow runner onto a stack. When the fast runner hits the end of the list, the slow runner will have reached 
the middle of the linked list. By this point, the stack will have all the eleme"
1231,499,"Solutions to Chapter 2 I Linked Lists
Now, we simply iterate through the rest of the linked list. At each iteration, we compare the node to the top 
of the stack. If we complete the iteration without finding a difference, then the linked list is a palindrome. 
1 boolean isPalindrome(LinkedListNode h"
1232,484,"8 * (which is moving at 2x speed) reaches the end of the linked list, then we
9 * know we're at the middle*/
10 while (fast != null && fast.next != null) {
11 stack.push(slow.data); 
12 slow slow.next; 
13 fast= fast.next.next; 
14 } 
15 
16 /* Has odd number of elements, so skip the middle element*"
1233,411,"24 /* If values are different, then it's not a palindrome*/ 
25 if (top != slow.data) { 
26 return false; 
27 } 
28 slow= slow.next; 
29 } 
30 return true; 
31 } 
Solution #3: Recursive Approach 
First, a word on notation: in this solution, when we use the notation node Kx, the variable K indicates "
1234,436,"with that value or the back node. For example, in the below linked list node 2b would refer to the second 
(back) node with value 2. 
Now, like many linked list problems, you can approach this problem recursively. We may have some intui­
tive idea that we want to compare element 0 and element n - 1,"
1235,508,"0 ( 1 ( 2 ( 3 ) 2 ) 1 ) 0 
In order to apply this approach, we first need to know when we've reached the middle element, as this will 
form our base case. We can do this by passing in length - 2 for the length each time. When the length 
equals 0 or 1, we're at the center of the linked list. This is"
1236,119,"3 return [something]; // At middle 
4 } 
5 recurse(n.next, length - 2); 
218 Cracking the Coding Interview, 6th Edition"
1237,478,"Solutions to Chapter 2 I Linked Lists
6 
7 } 
This method will form the outline of the isPalindrome method. The ""meat"" of the algorithm though is 
comparing node i to node n - i to check if the linked list is a palindrome. How do we do that? 
Let's examine what the call stack looks like: 
1 vl = is "
1238,479,"3 v3 = isPalindrome: list = 2 ( 3 ) 2 ) 1 ) 0. length = 3 
4 v4 = is Palindrome: list = 3 ) 2 ) 1 ) 0. length = 1 
5 returns v3 
6 returns v2 
7 returns vl 
8 returns ? 
In the above call stack, each call wants to check if the list is a palindrome by comparing its head node with 
the corresponding n"
1239,420,"Line 3 needs to compare node 2f with node 2b
• Line 4 needs to compare node 3f with node 3b.
If we rewind the stack, passing nodes back as described below, we can do just that: 
• Line 4 sees that it is the middle node (since length = 1), and passes back head. next. The value head
equals node 3, so "
1240,472,"which is node 2b. lf the values match, it passes a reference to node lb (returned_node. next) up
to line 2.
Line 2 compares its head (node 1 f) to returned_node (node lb). If the values match, it passes a
reference to node 0b (or, returned _node. next) up to line 1.
Line 1 compares its head, node 0f"
1241,500,"up the stack. In this way, every node i gets compared to node n - i. If at any point the values do not 
match, we return false, and every call up the stack checks for that value. 
But wait, you might ask, sometimes we said we'll return a boolean value, and sometimes we're returning 
a node. Which is"
1242,388,"2 public LinkedlistNode node; 
3 public boolean result; 
4 } 
The example below illustrates the parameters and return values from this sample list. 
1 isPalindrome: list = 0 ( 1 ( 2 ( 3 ( 4 ) 3 ) 2 ) 1 ) 0. len = 9 
2 is Palindrome: list = 1 ( 2 ( 3 ( 4 ) 3 ) 2 ) 1 ) 0. len = 7 
3 is Palindrome: lis"
1243,498,"Solutions to Chapter 2 l Linked Lists 
4 is Palindrome: list = 3 ( 4 ) 3 ) 2 ) 1 ) 0, len = 3 
5 isPalindrome: list = 4 ) 3 ) 2 ) 1 ) 0. len = 1 
6 returns node 3b, true 
7 returns node 2b, true 
8 returns node lb, true 
9 returns node 0b, true 
10 returns null, true 
Implementing this code is now j"
1244,503,"4 return p.result; 
5 } 
6 
7 Result isPalindromeRecurse(LinkedListNode head, int length) { 
8 if (head== null I I length<= 0) { II Even number of nodes 
9 return new Result(head, true); 
10 } else if (length== 1) { II Odd number of nodes 
11 return new Result(head.next, true); 
12 } 
13 
14 I* Recu"
1245,432,"18 * 
a failure. *I
19 if (! res.result I I res.node== null) { 
20 return res; 
21 } 
22 
23 I* Check if matches corresponding node on other side. *I
24 res.result = (head.data== res.node.data); 
25 
26 I* Return corresponding node. *I
27 res.node= res.node.next; 
28 
29 return res; 
30 } 
31 
32 in"
1246,460,"35 size++; 
36 n = n.next; 
37 } 
38 return size; 
39 } 
Some of you might be wondering why we went through all this effort to create a special Result class. Isn't 
there a better way? Not really-at least not in Java. 
However, if we were implementing this in C or C ++, we could have passed in a dou"
1247,492,"Solutions to Chapter 2 I Linked Lists 
2.7 Intersection: Given two (singly) linked lists, determine if the two lists intersect. Return the 
intersecting node. Note that the intersection is defined based on reference, not value. That is, if the 
kth node of the first linked list is the exact same nod"
1248,438,"Here is a picture of intersecting linked lists: 
And here is a picture of non-intersecting linked lists: 
pg95 
We should be careful here to not inadvertently draw a special case by making the linked lists the same 
length. 
Let's first ask how we would determine if two linked lists intersect. 
Dete"
1249,435,"throw all the linked lists nodes into there. We would need to be careful to reference the linked lists by their 
memory location, not by their value. 
There's an easier way though. Observe that two intersecting linked lists will always have the same last node. 
Therefore, we can just traverse to the"
1250,432,"Finding the intersecting node. 
One thought is that we could traverse backwards through each linked list. When the linked lists""split'; that's 
the intersection. Of course, you can't really traverse backwards through a singly linked list. 
If the linked lists were the same length, you could just tra"
1251,485,"Solutions to Chapter 2 I Linked Lists 
7 
When they're not the same length, we'd like to just""chop off""-or ignore-those excess (gray) nodes. 
How can we do this? Well, if we know the lengths of the two linked lists, then the difference between those 
two linked lists will tell us how much to chop of"
1252,489,"Putting it all together. 
We now have a multistep process. 
1. Run through each linked list to get the lengths and the tails.
2. Compare the tails. If they are different (by reference, not by value), return immediately. There is no inter-
section.
3. Set two pointers to the start of each linked list"
1253,497,"The implementation for this is below. 
1 LinkedlistNode findintersection(LinkedListNode listl, LinkedListNode list2) { 
2 if (listl == null I I list2 == null) return null; 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 } 
29 
/* Get tail and sizes. *"
1254,506,"if (resultl.tail != result2.tail) { 
return null; 
} 
/* Set pointers to the start of each linked list. */ 
LinkedlistNode shorter = resultl.size < result2.size? listl : list2; 
LinkedlistNode longer = resultl.size < result2.size ? list2 : listl; 
/* Advance the pointer for the longer linked list by"
1255,168,"while (shorter != longer) { 
} 
shorter = shorter.next; 
longer = longer.next; 
/* Return either one. */ 
return longer; 
222 Cracking the Coding Interview, 6th Edition"
1256,486,"Solutions to Chapter 2 I Linked Lists 
30 class Result { 
31 public LinkedlistNode tail; 
32 public int size; 
33 public Result(LinkedListNode tail, int size) { 
34 this.tail tail; 
35 this.size= size; 
36 } 
37 } 
38 
39 Result getTailAndSize(LinkedListNode list) { 
40 if (list == null) return null"
1257,507,"47 } 
48 return new Result(current, size); 
49 } 
50 
51 LinkedListNode getKthNode(LinkedListN ode head, int k) { 
52 LinkedListNode current= head; 
53 while (k > 0 && current != null) { 
54 current = current.next; 
55 k--; 
56 } 
57 return current; 
58 } 
This algorithm takes O(A + B) time, where A"
1258,462,"beginning of the loop. 
DEFINITION 
Circular linked list: A (corrupt) linked list in which a node's next pointer points to an earlier node, so 
as to make a loop in the linked list. 
EXAMPLE 
Input: 
Output: 
SOLUTION 
A - > B - > C - > D - > E - > C [the same C as earlier] 
C 
pg95 
This is a modif"
1259,372,"Matching approach. 
Part 1 : Detect If Linked List Has A Loop 
An easy way to detect if a linked list has a loop is through the FastRunner / SlowRunner approach. 
FastRunner moves two steps at a time, while SlowRunner moves one step. Much like two cars racing 
around a track at different steps, they"
1260,468,"Solutions to Chapter 2 I Linked Lists 
An astute reader may wonder if FastRunner might ""hop over"" SlowRunner completely, without 
ever colliding. That's not possible. Suppose that FastRunner did hop over SlowRunner, such that 
SlowRunner is at spot i and FastRunner is at spot i + 1. In the previous "
1261,509,"have collided. 
Part 2: When Do They Collide? 
Let's assume that the linked list has a ""non-looped"" part of size k. 
If we apply our algorithm from part l, when will FastRunner and SlowRunner collide? 
We know that for every p steps that SlowRunner takes, FastRunner has taken 2p steps. Therefore, wh"
1262,494,"should actually write this as mod ( k, LOOP _SIZE) steps, which we will denote as K. 
At each subsequent step, FastRunner and SlowRunner get either one step farther away or one step 
closer, depending on your perspective. That is, because we are in a circle, when A moves q steps away from 
B, it is "
1263,500,"3. SlowRunner is K steps behind FastRunner.
4. FastRunner is LOOP _SIZE - K steps behind SlowRunner.
5. FastRunner catches up to SlowRunner at a rate of 1 step per unit of time.
So, when do they meet? Well, if FastRunner is LOOP _SIZE K steps behind SlowRunner, and 
FastRunner catches up at a rate o"
1264,475,"nl and n2 will meet here, 
three nodes from start of loop 
Part 3: How Do You Find The Start of the Loop? 
We now know that CollisionSpot is K nodes before the start of the loop. Because K = mod (k, LOOP_ 
SIZE) (or, in other words, k = K + M * LOOP _SIZE, for any integer M), it is also correct to s"
1265,183,"it is 7, 12, or even 397 nodes into the loop. 
Therefore, both CollisionSpot and LinkedlistHead are k nodes from the start of the loop. 
224 Cracking the Coding Interview, 6th Edition"
1266,478,"Solutions to Chapter 2 I Linked Lists
Now, if we keep one pointer at CollisionSpot and move the other one to LinkedListHead, they will 
each be k nodes from LoopSta rt. Moving the two pointers at the same speed will cause them to collide 
again-this time after k steps, at which point they will both "
1267,502,"the loop, after k nodes, FastPointer is k nodes into the loop. This means that FastPointer and 
SlowPointer are LOOP _SIZE - k nodes away from each other. 
Next, if FastPointer moves two nodes for each node that SlowPointer moves, they move one node 
closer to each other on each turn. Therefore, the"
1268,473,"and move the other pointer to the head of the linked list, then they will meet at the front of the loop. 
Our algorithm is derived directly from parts 1, 2 and 3. 
1. Create two pointers, FastPointer and SlowPointer.
2. Move FastPointer at a rate of 2 steps and SlowPointer at a rate of 1 step.
3. Wh"
1269,507,"The code below implements this algorithm. 
1 LinkedListNode FindBeginning(LinkedlistNode head) { 
2 LinkedListNode slow head; 
3 LinkedlistNode fast = head; 
4 
5 /* Find meeting point. This will be LOOP_SIZE - k steps into the linked list. */ 
6 while (fast != null && fast.next != null) { 
7 slow ="
1270,449,"15 if (fast == null I I fast.next == null) { 
16 return null; 
17 } 
18 
19 /* Move slow to Head. Keep fast at Meeting Point. Each are k steps from the 
20 * Loop Start. If they move at the same pace, they must meet at Loop Start . */
21 slow = head;
22 while (slow!= fast) {
23 slow slow.next; 
24 f"
1271,84,"Solutions to Chapter 2 I Linked Lists
226 Cracking the Coding Interview, 6th Edition"
1272,435,"3 
Solutions to Stacks and Queues 
3.1 Three in One: Describe how you could use a single array to implement three stacks. 
SOLUTION -------- ·······----
pg98
Like many problems, this one somewhat depends on how well we'd like to support these stacks. If we're 
okay with simply allocating a fixed amo"
1273,485,"Alternatively, we can be flexible in our space allocation, but this significantly increases the complexity of 
the problem. 
Approach 1: Fixed Division 
We can divide the array in three equal parts and allow the individual stack to grow in that limited space. 
Note: We will use the notation ""["" to m"
1274,500,"2X ) . 
For stack 3, we will use [ 2X , n) . 
The code for this solution is below. 
1 class FixedMultiStack { 
2 private int numberOfStacks 3; 
3 private int stackCapacity; 
4 private int[] values; 
5 private int[] sizes; 
6 
7 public FixedMultiStack(int stackSize) { 
8 stackCapacity = stackSize; 
9"
1275,169,"15 /* Check that we have space for the next element */ 
16 if (isFull(stackNum)) { 
17 throw new FullStackExc eption(); 
CrackingTheCodinglnterview.com / 6th Edition 227"
1276,476,"Solutions to Chapter 3 I Stacks and Queues
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 } 
} 
} 
/* Increment stack pointer and then update top value. */ 
sizes[stack"
1277,497,"} 
throw new EmptyStackException(); 
} 
int toplndex = indexOfTop(stackNum); 
int value = values[toplndex]; // Get top 
values[topindex] = 0; // Clear 
sizes[stackNum]--; // Shrink 
return value; 
/* Return top element. */ 
public int peek(int stackNum) { 
if (isEmpty(stackNum)) { 
throw new EmptySt"
1278,408,"} 
/* Return if stack is full. */ 
public boolean isFull(int stackNum) { 
return sizes[stackNum] == stackCapacity; 
} 
/* Returns index of the top of the stack. */ 
private int indexOfTop(int stackNum) { 
} 
int offset = stackNum * stackCapacity; 
int size = sizes[stackNum]; 
return offset+ size - 1"
1279,488,"rithm accordingly. For example, if we expected Stack 1 to have many more elements than Stack 2, we could 
allocate more space to Stack 1 and less space to Stack 2. 
Approach 2: Flexible Divisions 
A second approach is to allow the stack blocks to be flexible in size. When one stack exceeds its initi"
1280,77,"wrap around to the beginning. 
228 Cracking the Coding Interview, 6th Edition"
1281,485,"Solutions to Chapter 3 I Stacks and Queues
Please note that the code for this solution is far more complex than would be appropriate for an interview. 
You could be responsible for pseudocode, or perhaps the code of individual components, but the entire 
implementation would be far too much work. 
1"
1282,509,"4 * just a bunch of individual variables, but that's messy and doesn't gain us
5 *m uch. */
6 private class Stackinfo {
7 public int start, size, capacity; 
8 public Stackinfo(int start, int capacity) { 
9 this.start = start; 
10 this.capacity= capacity; 
11 } 
12 
13 /* Check if an index on the ful"
1283,477,"16 /* If outside of bounds of array, return false. */ 
17 if (index< 
0 I I index >= values.length) { 
18 return false; 
19 
20 
21 
22 
23 
24 
25 } 
26 
} 
/* If index wraps around, adjust it. */ 
int contiguousindex =index< start? index + values.length index; 
int end= start + capacity; 
return s"
1284,467,"29 } 
30 
31 public int lastElementindex() { 
32 return adjustindex(start + size - 1); 
33 } 
34 
35 public boolean isFull() { return size== capacity; } 
36 public boolean isEmpty() { return size== 0; } 
37 } 
38 
39 private Stackinfo[J info; 
40 private int[] values; 
41 
42 public MultiStack(int n"
1285,417,"45 for (int i= 0; i < numberOfStacks; i++) { 
46 info[i] = new Stackinfo(defaultSize * i, defaultSize); 
47 } 
48 values = new int[numberOfStacks * defaultSize]; 
49 } 
50 
51 /* Push value onto stack num, shifting/expanding stacks as necessary. Throws 
52 * exception if all stacks are full. */
53 p"
1286,461,"Solutions to Chapter 3 I Stacks and Queues 
54 if (allStacksAreFull()) { 
55 throw new FullStackException(); 
56 } 
57 
58 I* If this stack is full, expand it. *I
59 Stackinfo stack= info[stackNum]; 
60 if (stack.isFull()) { 
61 expand(stackNum); 
62 } 
63 
64 I* Find the index of the top element in"
1287,473,"68 } 
69 
70 I* Remove value from stack. *I
71 public int pop(int stackNum) throws Exception { 
72 Stackinfo stack= info[stackNum]; 
73 if (stack.isEmpty()) { 
74 throw new EmptyStackException(); 
75 } 
76 
77 /* Remove last element. */ 
78 int value= values[stack.lastElementindex()]; 
79 values[sta"
1288,487,"85 public int peek(int stackNum) { 
86 Stackinfo stack = info[stackNum]; 
87 return values[stack.lastElementindex()]; 
88 } 
89 /* Shift items in stack over by one element. If we have available capacity, then 
90 * we'll end up shrinking the stack by one element. If we don't have available
91 * capa"
1289,472,"94 Stackinfo stack = info[stackNum]; 
95 
96 I* If this stack is at its full capacity, then you need to move the next 
97 * stack over by one element. This stack can now claim the freed index. */
98 if (stack.size >= stack.capacity) {
99 int nextStack = (stackNum + 1) % info.length; 
100 shift(nextS"
1290,231,"105 int index= stack.lastCapacityindex(); 
106 while (stack.isWithinStackCapacity(index)) { 
107 values[index] = values[previousindex(index)]; 
108 index= previousindex(index); 
109 } 
230 Cracking the Coding Interview, 6th Edition"
1291,477,"Solutions to Chapter 3 I Stacks and Queues 
110 
111 I* Adjust stack data. *I
112 values[stack.start] = 0; II Clear item 
113 stack.start = nextindex(stack.start); II move start 
114 stack.capacity--; II Shrink capacity 
115 } 
116 
117 I* Expand stack by shifting over other stacks *I
118 private vo"
1292,485,"124 public int numberOfElements() { 
125 int size = 0; 
126 for (Stackinfo sd : info) { 
127 size+= sd.size; 
128 } 
129 return size; 
130 } 
131 
132 I* Returns true is all the stacks are full. *I
133 public boolean allStacksAreFull() { 
134 return numberOfElements() == values.length; 
135 } 
136 
"
1293,495,"140 * return -1, not 4. We actually want the value to be 4 (since we're wrapping
141 * around the index). *I
142 int max = values.length;
143 return ((index% max)+ max)% max;
144 } 
145 
146 /* Get index after this index, adjusted for wrap around. *I
147 private int nextindex(int index) { 
148 retur"
1294,352,"153 return adjustindex(index - 1); 
154 } 
155} 
In problems like this, it's important to focus on writing clean, maintainable code. You should use additional 
classes, as we did with Stackinfo, and pull chunks of code into separate methods. Of course, this advice 
applies to the ""real world"" as wel"
1295,459,"Solutions to Chapter 3 I Stacks and Queues
3.2 Stack Min: How would you design a stack which, in addition to push and pop, has a function min 
which returns the minimum element? Push, pop and min should all operate in 0(1) time. 
pg98 
SOLUTION 
The thing with minimums is that they don't change very"
1296,468,"minValue is popped from the stack, we search through the stack to find the new minimum. Unfortunately, 
this would break the constraint that push and pop operate in 0( 1) time. 
To further understand this question, let's walk through it with a short example: 
push(5); // stack is {5}, min is 5 
push"
1297,503,"pop(); // pops 7. stack is {3, 6, 5}, min is 3 
pop(); // pops 3. stack is {6, 5}. min is 5. 
Observe how once the stack goes back to a prior state ( { 6, 5} ), the minimum also goes back to its prior 
state (5). This leads us to our second solution. 
If we kept track of the minimum at each state, w"
1298,497,"what the top element thinks is the min. 
When you push an element onto the stack, the element is given the current minimum. It sets its ""local 
min""to be the min. 
1 public class StackWithMin extends Stack<NodeWithMin> { 
2 public void push(int value) { 
3 int newMin = Math.min(value, min()); 
4 sup"
1299,414,"10 } else { 
11 return peek().min; 
12 } 
13 } 
14 }
15 
16 class NodeWithMin { 
17 public int value; 
18 public int min; 
19 public NodeWithMin(int v, int min){ 
20 value = v; 
21 this.min = min; 
22 } 
23 } 
There's just one issue with this: if we have a large stack, we waste a lot of space by kee"
1300,505,"Solutions to Chapter 3 I Stacks and Queues 
We can (maybe) do a bit better than this by using an additional stack which keeps track of the mins. 
1 public class StackWithMin2 extends Stack<Integer> { 
2 Stack<Integer> s2; 
3 public stackWithMin2() { 
4 s2 = new Stack<Int eger>(); 
5 } 
6 
7 public v"
1301,415,"16 if (value == min()) { 
17 s2.pop(); 
18 } 
19 return value; 
20 } 
21 
22 public int min() { 
23 if (s2.isEmpty()) { 
24 return Integer.MAX_VALUE; 
25 } else { 
26 return s2.peek(); 
27 } 
28 } 
29 } 
Why might this be more space efficient? Suppose we had a very large stack and the first element "
1302,437,"the stack. In the second solution though, we store just a few pieces of data: a second stack with one element 
and the members within this stack. 
3.3 Stack of Plates: Imagine a (literal) stack of plates. If the stack gets too high, it might topple. 
Therefore, in real life, we would likely start a "
1303,502,"composed of several stacks and should create a new stack once the previous one exceeds capacity. 
SetOfStacks. push() and SetOfStacks. pop() should behave identically to a single stack 
(that is, pop () should return the same values as it would if there were just a single stack). 
FOLLOW UP 
Impleme"
1304,157,"1 class SetOfStacks { 
2 Arraylist<Stack> stacks new Arraylist<Stack>(); 
3 public void push(int v) { ... } 
CrackingTheCodinglnterview.com I 6th Edition 233"
1305,511,"Solutions to Chapter 3 I Stacks and Queues
4 public int pop() { ... } 
5 } 
We know that push () should behave identically to a single stack, which means that we need push () to 
call push () on the last stack in the array of stacks. We have to be a bit careful here though: if the last stack 
is at "
1306,469,"4 last.push(v); 
5 } else {//must create new stack 
6 Stack stack= new Stack(capacity); 
7 stack.push(v); 
8 stacks.add(stack); 
9 } 
10 } 
What should pop() do? It should behave similarly to push () in that it should operate on the last stack. If 
the last stack is empty (after popping), then we sh"
1307,491,"4 int v = last.pop(); 
5 if (last.size== 0) stacks.remove(stacks.size() - 1); 
6 return v; 
7 } 
Follow Up: Implement popAt(int index) 
This is a bit trickier to implement, but we can imagine a ""rollover"" system. If we pop an element from stack 
1, we need to remove the bottom of stack 2 and push it"
1308,487,"being at full capacity. This would improve the time complexity (by a fair amount, with a large number of 
elements), but it might get us into tricky situations later on if someone assumes that all stacks (other than 
the last) operate at full capacity. There's no ""right answer"" here; you should disc"
1309,478,"3 public int capacity; 
4 public SetOfStacks(int capacity) { 
5 this.capacity= capacity; 
6 } 
7 
8 public Stack getLastStack() { 
9 if (stacks.size()== 0) return null; 
10 return stacks.get(stacks.size() - 1); 
11 } 
12 
13 public void push(int v) {/*see earlier code */} 
14 public int pop() {/*see"
1310,497,"Solutions to Chapter 3 I Stacks and Queues 
19 
20 public int popAt(int index) { 
21 return leftShift(index, true); 
22 } 
23 
24 public int leftShift(int index, boolean removeTop) { 
25 Stack stack = stacks.get(index); 
26 int removed_item; 
27 if (removeTop) removed_item = stack.pop(); 
28 else re"
1311,509,"33 stack.push(v); 
34 } 
35 return removed_item; 
36 } 
37 } 
38 
39 public class Stack { 
40 private int capacity; 
41 public Node top, bottom; 
42 public int size = 0; 
43 
44 public Stack(int capacity) {this.capacity= capacity; } 
45 public boolean isFull() { return capacity== size; } 
46 
47 pub"
1312,432,"53 if (size >= capacity) return false; 
54 size++; 
55 Node n = new Node(v); 
56 if (size== 1) bottom = n; 
57 join(n, top); 
58 top= n; 
59 return true; 
60 } 
61 
62 public int pop() { 
63 Node t = top; 
64 top= top.below; 
65 size--; 
66 return t.value; 
67 } 
68 
69 public boolean isEmpty() { 
7"
1313,427,"Solutions to Chapter 3 I Stacks and Queues 
75 bottom = bottom.above; 
76 if (bottom != null) bottom.below null; 
77 size-- ; 
78 return b.value; 
79 } 
80 } 
This problem is not conceptually that tough, but it requires a lot of code to implement it fully. Your inter­
viewer would not ask you to imp"
1314,487,"that popAt can call. This will make your code cleaner and give you the opportunity to lay down the skel­
eton of the code before dealing with some of the details. 
3.4 Queue via Stacks: Implement a MyQueue class which implements a queue using two stacks. 
SOLUTION 
pg99 
Since the major difference b"
1315,476,"reverse the order of the elements (by popping sl and pushing the elements on to s2). In such an imple­
mentation, on each peek() and pop() operation, we would pop everything from sl onto s2, perform 
the peek/ pop operation, and then push everything back. 
This will work, but if two pop/ peeks are p"
1316,506,"elements. 
In this approach, stackNewest has the newest elements on top and stackOldest has the oldest 
elements on top. When we dequeue an element, we want to remove the oldest element first, and so we 
dequeue from stackOldest. If stackOldest is empty, then we want to transfer all elements from 
s"
1317,479,"1 public class MyQueue<T> { 
2 Stack<T> stackNewest, stackOldest; 
3 
4 public MyQueue() { 
5 stackNewest new Stack<T>(); 
6 stackOldest = new Stack<T>(); 
7 } 
8 
9 public int size() { 
19 return stackNewest.size() + stackOldest.size(); 
11 } 
12 
13 public void add(T value) { 
14 /* Push onto stac"
1318,92,"19 * we can do operations on stackOldest. */
23 6 Cracking the Coding Interview, 6th Edition"
1319,486,"20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 } 
Solutions to Chapter 3 I Stacks and Queues 
private void shiftStacks() { 
} 
if (stackOldest.isEmpty()) { 
while (!stackNewest.isEmpty()) { 
stackOldest.push(stackNewest.pop()); 
} 
} 
public T peek() { 
} 
shiftStacks(); // E"
1320,507,"shiftStacks(); // Ensure stackOldest has the current elements 
return stackOldest.pop(); // pop the oldest item. 
During your actual interview, you may find that you forget the exact API calls. Don't stress too much if that 
happens to you. Most interviewers are okay with your asking for them to ref"
1321,409,"an additional temporary stack, but you may not copy the elements into any other data structure 
(such as an array). The stack supports the following operations: push, pop, peek, and is Empty. 
pg99 
SOLUTION 
One approach is to implement a rudimentary sorting algorithm. We search through the entire "
1322,479,"and push that. This will actually require a total of three stacks: s 1 is the original stack, s2 is the final sorted 
stack, and s3 acts as a buffer during our searching of sl. To search sl for each minimum, we need to pop 
elements from sl and push them onto the buffer, s3. 
Unfortunately, this req"
1323,484,"order into s2. How would this work? 
Imagine we have the following stacks, where s2 is""sorted"" and sl is not: 
12 
5 8 
10 3 
7 1 
When we pop 5 from s 1, we need to find the right place in s2 to insert this number. In this case, the correct 
place is on s2 just above 3. How do we get it there? We c"
1324,83,"onto sl) and then push 5 onto s2. 
CrackingTheCodinglnterview.com J 6th Edition 237"
1325,466,"Solutions to Chapter 3 I Stacks and Queues 
Step 1 Step 2 Step 3 
12 8 8 
8 -> 12 -> 12 5 
10 3 10 3 10 3 
7 1 7 1 7 1 
tmp = 5 tmp = 5 tmp 
Note that 8 and 12 are still in sl-and that's okay! We just repeat the same steps for those two numbers as 
we did for 5, each time popping off the top of sl a"
1326,490,"elements will be right on top of 5. We won't need to muck around with s2's other elements, and the inside 
of the below while loop will not be run when tmp is 8 or 12.) 
1 void sort(Stack<Integer> s) { 
2 Stack<Integer> r = new Stack<Integer>(); 
3 while(!s.isEmpty()) { 
4 /* Insert each element in "
1327,472,"10 } 
11 
12 /* Copy the elements from r back into s. */ 
13 while (!r.isEmpty()) { 
14 s.push(r.pop());
15 } 
16 
} 
This algorithm is O ( N2) time and O ( N) space. 
If we were allowed to use unlimited stacks, we could implement a modified quicksort or mergesort. 
With the mergesort solution, we w"
1328,483,"stack. Note that this would require the creation of two additional stacks per level of recursion. 
With the quicksort solution, we would create two additional stacks and divide the stack into the two stacks 
based on a pivot element. The two stacks would be recursively sorted, and then merged back t"
1329,460,"Solutions to Chapter 3 I Stacks and Queues 
3.6 Animal Shelter: An animal shelter, which holds only dogs and cats, operates on a strictly""first in, first 
out"" basis. People must adopt either the ""oldest"" (based on arrival time) of all animals at the shelter, 
or they can select whether they would p"
1330,495,"maintain this system and implement operations such as enqueue, dequeueAny, dequeueDog, 
and dequeueCat. You may use the built-in Linkedlist data structure. 
pg99 
SOLUTION 
We could explore a variety of solutions to this problem. For instance, we could maintain a single queue. 
This would make deque"
1331,479,"efficiency. 
An alternative approach that is simple, clean and efficient is to simply use separate queues for dogs and 
cats, and to place them within a wrapper class called An imalQueue. We then store some sort of timestamp 
to mark when each animal was enqueued. When we call dequeueAny, we peek at"
1332,497,"4 public Animal(String n) {name = n; } 
5 public void setOrder(int ord) { order ord; } 
6 public int getOrder() { return order; } 
7 
8 /* Compare orders of animals to return the older item. */ 
9 public boolean isOlderThan(Animal a) { 
10 return this.order < a.getOrder(); 
11 } 
12 } 
13 
14 class "
1333,480,"18 
19 public void enqueue(Animal a) { 
20 /* Order is used as a sort of timestamp, so that we can compare the insertion 
21 * order of a dog to a cat. */ 
22 a.setOrder(order);
23 order++;
24 
25 if (a instanceof Dog) dogs.addlast((Dog) a); 
26 else if (a instanceof Cat) cats.addlast((Cat)a); 
27 }"
1334,164,"32 if (dogs.size() 0) {
33 return dequeueCats(); 
34 } else if (cats.size()== 0) { 
35 return dequeueDogs(); 
36 } 
CrackingTheCodinglnterview.com I 6th Edition 239"
1335,473,"Solutions to Chapter 3 I Stacks and Queues 
37 
38 Dog dog= dogs.peek(); 
39 Cat cat= cats.peek(); 
40 if (dog.isOlderThan(c at)) { 
41 return dequeueDogs(); 
42 } else { 
43 return dequeueCats(); 
44 } 
45 } 
46 
47 public Dog dequeueDogs() { 
48 return dogs.poll(); 
49 } 
50 
51 public Cat dequeue"
1336,455,"58 } 
59 
60 public class Cat extends Animal { 
61 public Cat(String n) { super(n); } 
62 } 
It is important that Dog and Cat both inherit from an Animal class since dequeueAny() needs to be able 
to support returning both Dog and Cat objects. 
If we wanted, order could be a true timestamp with the "
1337,155,"the same timestamp, then (by definition) we don't have an older animal and we could return either one. 
240 Cracking the Coding Interview, 6th Edition 
.,."
1338,426,"4 
Solutions to Trees and Graphs 
4.1 Route Between Nodes: Given a directed graph, design an algorithm to find out whether there is a 
route between two nodes. 
pg 709
SOLUTION ------------------------------
This problem can be solved by just simple graph traversal, such as depth-first search or bre"
1339,507,"any node found in the course of the algorithm as ""already visited"" to avoid cycles and repetition of the 
nodes. 
The code below provides an iterative implementation of breadth-first search. 
1 enum State { Unvisited, Visited, Visiting; } 
2 
3 boolean search( Graph g, Node start, Node end) { 
4 if "
1340,428,"11 } 
12 start.state = State.Visiting; 
13 q.add(start);
14 Node u; 
15 while (!q.isEmpty()) {
16 u = q.removeFirst(); II i.e., dequeue() 
17 if (u != null) { 
18 for (Node v: u.getAdjacent()) { 
19 if (v.state == State.Unvisited) { 
20 if (v == end) { 
21 return true; 
22 } else { 
23 v.state = Sta"
1341,511,"Solutions to Chapter 4 I Trees and Graphs 
30 } 
31 return false; 
32 } 
It may be worth discussing with your interviewer the tradeoffs between breadth-first search and depth-first 
search for this and other problems. For example, depth-first search is a bit simpler to implement since it can 
be don"
1342,406,"neighbors. 
4.2 Minimal Tree: Given a sorted (increasing order) array with unique integer elements, write an 
algorithm to create a binary search tree with minimal height. 
pg 109 
SOLUTION 
To create a tree of minimal height, we need to match the number of nodes in the left subtree to the number 
o"
1343,466,"array, since this would mean that half the elements would be less than the root and half would be greater 
than it. 
We proceed with constructing our tree in a similar fashion. The middle of each subsection of the array 
becomes the root of the node. The left half of the array will become our left s"
1344,501,"value v through a recursive process that starts with the root node. This will indeed construct a tree with 
minimal height but it will not do so very efficiently. Each insertion will require traversing the tree, giving a 
total cost ofO ( N log N) to the tree. 
Alternatively, we can cut out the extr"
1345,507,"The algorithm is as follows: 
1. Insert into the tree the middle element of the array.
2. Insert (into the left subtree) the left subarray elements.
3. Insert (into the right subtree) the right subarray elements.
4. Recurse.
The code below implements this algorithm. 
1 TreeNode createMinimalBST(int "
1346,250,"7 return null; 
8 } 
9 int mid= (start+ end)/ 2; 
10 TreeNode n = new TreeNode(arr[mid]); 
11 n.left = createMinimalBST(arr, start, mid - 1);
12 n.right = createMinimalBST(arr, mid+ 1, end);
13 return n;
242 Cracking the Coding Interview, 6th Edition"
1347,422,"Solutions to Chapter 4 I Trees and Graphs 
14 } 
Although this code does not seem especially complex, it can be very easy to make little off-by-one errors. 
Be sure to test these parts of the code very thoroughly. 
4.3 List of Depths: Given a binary tree, design an algorithm which creates a linked l"
1348,446,"pg 709 
SOLUTION 
Though we might think at first glance that this problem requires a level-by-level traversal, this isn't actually 
necessary. We can traverse the graph any way that we'd like, provided we know which level we're on as we 
do so. 
We can implement a simple modification of the pre-orde"
1349,501,"1 void createLevelLinkedList(TreeNode root, ArrayList<LinkedList<TreeNode>> lists, 
2 int level) { 
3 if (root== null) return; II base case 
4 
5 LinkedList<TreeNode> list = null; 
6 if (lists.size()== level) { II Level not contained in list 
7 list = new LinkedList<TreeNode>(); 
8 I* Levels are alw"
1350,437,"11 lists.add(list); 
12 } else { 
13 list = lists.get(level); 
14 
15 
16 
17 
18 } 
19 
} 
list.add(root); 
createLevelLinkedList(root.left, lists, level+ 1); 
createlevelLinkedList(root.right, lists, level+ 1); 
20 ArrayList<LinkedList<TreeNode>> createLevelLinkedList(TreeNode root) { 
21 ArrayLis"
1351,450,"23 return lists; 
24 } 
Alternatively, we can also implement a modification of breadth-first search. With this implementation, we 
want to iterate through the root first, then level 2, then level 3, and so on. 
With each level i, we will have already fully visited all nodes on level i. - 1. This mea"
1352,385,"The code below implements this algorithm. 
1 ArrayList<LinkedList<TreeNode>> createLevelLinkedlist(TreeNode root) { 
2 ArrayList<LinkedList<TreeNode>> result = new ArrayList<Linkedlist<TreeNode>>(); 
3 /* ""Visit"" the root */ 
4 LinkedList<TreeNode> current= new LinkedList<TreeNode>(); 
5 if (root !="
1353,482,"Solutions to Chapter 4 I Trees and Graphs 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 } 
while (current.size() > 0) { 
} 
result.add(current); // Add previous level 
Linkedlist<TreeNode> parents = current; //Go to next level 
current = new LinkedList<TreeNode>(); 
for (TreeNode"
1354,473,"current.add(parent.right); 
} 
return result; 
One might ask which of these solutions is more efficient. Both run in O ( N) time, but what about the space 
efficiency? At first, we might want to claim that the second solution is more space efficient. 
In a sense, that's correct. The first solution u"
1355,487,"However, both solutions require returning O(N) data. The extra 0( log N) space usage from the recursive 
implementation is dwarfed by the O ( N) data that must be returned. So while the first solution may actually 
use more data, they are equally efficient when it comes to ""big O:'
4.4 Check Balance"
1356,455,"node never differ by more than one. 
pg 7 70 
SOLUTION 
In this question, we've been fortunate enough to be told exactly what balanced means: that for each node, 
the two subtrees differ in height by no more than one. We can implement a solution based on this defini­
tion. We can simply recurse thro"
1357,469,"2 if (root == null) return -1; // Base case 
3 return Math.max(getHeight(root.left), getHeight(root.right)) + 1; 
4 } 
5 
6 boolean isBalanced(TreeNode root) { 
7 if (root == null) return true;// Base case 
8 
9 int heightDiff = getHeight(root.left) - getHeight(root.right); 
10 if (Math.abs(heightDi"
1358,446,"Solutions to Chapter 4 I Trees and Graphs 
Although this works. it's not very efficient. On each node. we recurse through its entire subtree. This means 
that getHeight is called repeatedly on the same nodes. The algorithm isO(N log N) since each node is 
""touched"" once per node above it. 
We need t"
1359,443,"the same time as it's checking heights. What do we do when we discover that the subtree isn't balanced? 
Just return an error code. 
This improved algorithm works by checking the height of each subtree as we recurse down from the root. 
On each node, we recursively get the heights of the left and ri"
1360,484,"subtree is not balanced, then che ckHeight will return an error code. We will immediately break and 
return an error code from the current call. 
I 
What do we use for an error code? The height of a null tree is generally defined to be -1, so that's 
not a great idea for an error code. Instead, we'l"
1361,482,"3 
4 int leftHeight = checkHeight(root.left); 
5 if (leftHeight Integer.MIN_VALUE) return Integer.MIN_VALUE; // Pass error up 
6 
7 int rightHeight checkHeight(root.right); 
8 if (rightHeight == Integer.MIN_VALUE) return Integer.MIN_VALUE; // Pass error up 
9 
10 int heightDiff = leftHeight - rightH"
1362,469,"15 } 
16 } 
17 
18 boolean isBalanced(TreeNode root) { 
19 return checkHeight(root) != Integer.MIN_VALUE; 
20 } 
This code runs in O(N) time and O(H) space, where Hi s the height of the tree. 
4.5 Validate BST: Implement a function to check if a binary tree is a binary search tree. 
SOLUTION 
pg 710"
1363,110,"second builds off the property that left <= current < right. 
CrackingTheCodinglnterview.com I 6th Edition 245"
1364,504,"Solutions to Chapter 4 I Trees and Graphs 
Solution #1: In-Order Traversal 
Our first thought might be to do an in-order traversal, copy the elements to an array, and then check to see 
if the array is sorted. This solution takes up a bit of extra memory, but it works-mostly. 
The only problem is th"
1365,499,"traversal. 
Valid BST 
� 
@"" 
Invalid BST 
© 
� 
However, if we assume that the tree cannot have duplicate values, then this approach works. The pseudo­
code for this method looks something like: 
1 int index = 0; 
2 void copyBST(TreeNode root, int[] array) { 
3 if (root == null) return; 
4 copyBST("
1366,422,"11 int[] array= new int[root.size]; 
12 copyBST(root, array); 
13 for (int i= 1; i < array.length; i++) { 
14 if (array[i] <= array[i - 1]) return false; 
15 } 
16 return true; 
17 } 
Note that it is necessary to keep track of the logical ""end"" of the array, since it would be allocated to hold all 
"
1367,492,"to compare an element to the previous element. So why not just track the last element we saw and compare 
it as we go? 
The code below implements this algorithm. 
1 Integer last_printed = null; 
2 boolean checkBST(TreeNode n) { 
3 if (n == null) return true; 
4 
5 II Check I recurse left 
6 if (!che"
1368,106,"12 last_printed = n.data; 
13 
14 II Check I recurse right 
246 Cracking the Coding Interview, 6th Edition"
1369,508,"Solutions to Chapter 4 I Trees and Graphs 
15 if (!checkBST(n.right)) return false; 
16 
17 return true;// All good! 
18 } 
We've used an Integer instead of int so that we can know when last_printed has been set to a value. 
If you don't like the use of static variables, then you can tweak this code"
1370,496,"then you can simply do that. 
Solution #2: The Min / Max Solution 
In the second solution, we leverage the definition of the binary search tree. 
What does it mean for a tree to be a binary search tree? We know that it must, of course, satisfy the condition 
left. data <= current . data < right. dat"
1371,502,"search tree since 25 is in the wrong place. 
More precisely, the condition is that a// left nodes must be less than or equal to the current node, which 
must be less than all the right nodes. 
Using this thought, we can approach the problem by passing down the min and max values. As we iterate 
thro"
1372,462,"that there is no min or max.) We then branch left, checking that these nodes are within the range ( min = 
NULL, max = 20). Then, we branch right, checking that the nodes are within the range ( min = 20, 
max = NULL). 
We proceed through the tree with this approach. When we branch left, the max gets"
1373,493,"Solutions to Chapter 4 I Trees and Graphs 
The time complexity for this solution is O(N), where N is the number of nodes in the tree. We can prove that 
this is the best we can do, since any algorithm must touch all N nodes. 
Due to the use of recursion, the space complexity is O ( log N) on a balan"
1374,510,"1 boolean checkBST(TreeNode n) { 
2 return checkBST(n, null, null); 
3 } 
4 
5 boolean checkBST(TreeNode n, Integer min, Integer max) { 
6 if (n == null) { 
7 return true; 
8 } 
9 if ((min != null && n.data <= min) I I (max != null && n.data > max)) { 
10 return false; 
11 } 
12 
13 if (!checkBST(n."
1375,426,"null cases, are well handled. 
4.6 Successor: Write an algorithm to find the ""next"" node (i.e., in-order successor) of a given node in a 
binary search tree. You may assume that each node has a link to its parent. 
pg 110 
SOLUTION 
Recall that an in-order traversal traverses the left subtree, then "
1376,486,"Let's suppose we have a hypothetical node. We know that the order goes left subtree, then current side, 
then right subtree. So, the next node we visit should be on the right side. 
But which node on the right subtree? It should be the first node we'd visit if we were doing an in-order 
traversal of"
1377,499,"If a node n doesn't have a right subtree, then we are done traversing n's subtree. We need to pick up where 
we left off with n's parent, which we'll call q. 
If n was to the left of q, then the next node we should traverse should be q (again, since left - > current 
-> right). 
If n were to the rig"
1378,190,"a node x? We know we have hit this case when we move from a left node to its parent. The left node is fully 
traversed, but its parent is not. 
248 Cracking the Coding Interview, 6th Edition"
1379,438,"Solutions to Chapter 4 I Trees and Graphs 
The pseudocode looks like this: 
1 Node inorderSucc(Node n) { 
2 if (n has a right subtree) { 
3 return leftmost child of right subtree 
4 } else { 
5 while (n is a right child of n.parent) { 
6 n = n.parent; // Go up 
7 } 
8 return n.parent; // Parent has "
1380,504,"we hit the very end of the in-order traversal. That is, if we're already on the far right of the tree, then there is 
no in-order successor. We should return null. 
The code below implements this algorithm (and properly handles the null case). 
1 TreeNode inorderSucc(TreeNode n) { 
2 if (n == null) "
1381,472,"7 } else { 
8 TreeNode q = n; 
9 TreeNode x = q.parent; 
10 // Go up until we're on left instead of right 
11 while (x != null && x.left != q) { 
12 q x; 
13 x = x.parent; 
14 } 
15 return x; 
16 } 
17 }
18 
19 TreeNode leftMostChild(TreeNode n) { 
20 if (n == null) { 
21 return null; 
22 } 
23 whil"
1382,149,"a problem like this, it's useful to sketch out pseudocode to carefully outline the different cases. 
CrackingTheCodinglnterview.com I 6th Edition 249"
1383,502,"Solutions to Chapter 4 I Trees and Graphs 
4.7 Build Order: You are given a list of projects and a list of dependencies (which is a list of pairs of 
projects, where the second project is dependent on the first project). All of a project's dependencies 
must be built before the project is. Find a bu"
1384,422,"dependencies: (a, d), (f, b), (b, d), (f, a), (d, c) 
Output: f, e, a, b, d, c 
SOLUTION 
pg 770 
Visualizing the information as a graph probably works best. Be careful with the direction of the arrows. In 
the graph below, an arrow from d to g means that d must be compiled before g. You can also dr"
1385,421,"example. 
In drawing this example (which is not the example from the problem description), I looked for a few things. 
I wanted the nodes labeled somewhat randomly. If I had instead put a at the top, with b and c as chil­
dren, then d and e, it could be misleading. The alphabetical order would match"
1386,466,"I wanted a graph where a node links to a node that cannot immediately follow it. For example, f links to 
a but a cannot immediately follow it (since b and c must come before a and after f). 
I wanted a larger graph since I need to figure out the pattern. 
I wanted nodes with multiple dependencies. "
1387,467,"Yes. Nodes with no incoming edges can be built immediately since they don't depend on anything. Let's 
add all such nodes to the build order. In the earlier example, this means we have an order of f, d (or d, f). 
Once we've done that, it's irrelevant that some nodes are dependent on d and f since d"
1388,485,"Solutions to Chapter 4 I Trees and Graphs 
Next, we know that c, b, and g are free to build since they have no incoming edges. Let's build those and 
then remove their outgoing edges. 
build order: f, d, c, b, g 
� 
� 
Project a can be built next, so let's do that and remove its outgoing edges. This"
1389,444,"1. We first added the nodes with no incoming edges. If the set of projects can be built, there must be some
""first"" project, and that project can't have any dependencies. If a project has no dependencies (incoming
edges), then we certainly can't break anything by building it first.
2. We removed all"
1390,489,"it doesn't matter if another project depends on them.
3. After that, we found the nodes that now have no incoming edges. Using the same logic from steps 1 and
2, it's okay if we build these. Now we just repeat the same steps: find the nodes with no dependencies,
add them to the build order, remove t"
1391,410,"way to build the system. We should return an error.
The implementation follows this approach very closely. 
Initialization and setup: 
1. Build a graph where each project is a node and its outgoing edges represent the projects that depend
on it. That is, if A has an edge to B (A-> B), it means B has"
1392,275,"2. Initialize a buildOrder array. Once we determine a project's build order, we add it to the array. We also
continue to iterate through the array, using a toBeProcessed pointer to point to the next node to be
fully processed.
CrackingTheCodinglnterview.com I 6th Edition 251"
1393,461,"Solutions to Chapter 4 I Trees and Graphs 
3. Find all the nodes with zero incoming edges and add those to a buildOrder array. Set a
toBeProcessed pointer to the beginning of the array.
Repeat until toBeProcessed is at the end of the buildOrder: 
1. Read node at toBeProcessed.
» If node is null, the"
1394,434,"» If child. dependencies is zero, add child to end of buildOrder.
3. Increment toBeProcessed.
The code below implements this algorithm. 
1 /* Find a correct build order. */ 
2 Project[] findBuildOrder(String[] projects, String[][] dependencies) { 
3 Graph graph= buildGraph(projects, dependencies); 
"
1395,491,"8 * is listed in ""build order"". The pair (a, b) in dependencies indicates that b
9 * depends on a and a must be built before b. */
10 Graph buildGraph(String[] projects, String[][] dependencies) { 
11 Graph graph= new Graph(); 
12 for (String project : projects) { 
13 graph.createNode(project); 
14 "
1396,438,"20 } 
21 
22 return graph; 
23 } 
24 
25 /* Return a list of the projects a correct build order.*/ 
26 Project[] orderProjects(Arraylist<Project> projects) { 
27 Project[] order = new Project[projects.size()]; 
28 
29 /* Add ""roots"" to the build order first.*/ 
30 int endOfList = addNonDependent(ord"
1397,252,"34 Project current= order[toBeProcessed]; 
35 
36 /* We have a circular dependency since there are no remaining projects with 
37 * zero dependencies. */
38 if (current== null) {
39 return null; 
40 } 
41 
252 Cracking the Coding Interview, 6th Edition"
1398,482,"Solutions to Chapter 4 I Trees and Graphs 
42 /* Remove myself as a dependency. */ 
43 Arraylist<Project> children = current.getChildren(); 
44 for (Project child : children) { 
45 child.decrementDependencies(); 
46 } 
47 
48 /* Add children that have no one depending on them. */ 
49 endOfList = add"
1399,461,"57 * array, starting at index offset. */
58 int addNonDependent(Project[] order, Arraylist<Project> projects, int offset) { 
59 for (Project project: projects) { 
60 if (project.getNumberDependencies() == 0) { 
61 order[offset] = project; 
62 offset++; 
63 } 
64 } 
65 return offset; 
66 } 
67 
68 pu"
1400,501,"71 
72 public Project getOrCreateNode(String name) { 
73 if (!map.containsKey(name)) { 
74 Project node = new Project(name); 
75 nodes.add(node); 
76 map.put(name, node); 
77 } 
78 
79 return map.get(name); 
80 } 
81 
82 public void addEdge(String startName, String endName) { 
83 Project start = get"
1401,329,"89 } 
90 
91 public class Project { 
92 private Arraylist<Project> children = new Arraylist<Project>(); 
93 private HashMap<String, Project> map= new HashMap<String, Project>(); 
94 private String name; 
95 private int dependencies 0; 
96 
97 public Project(String n) { name n; } 
CrackingTheCodingln"
1402,489,"Solutions to Chapter 4 I Trees and Graphs 
98 
99 public void addNeighbor(Project node) { 
100 if (!map.c ontainsKey(node.getName())) { 
101 children.add(node); 
102 map.put(node.getName(), node); 
103 node.incrementDependencies(); 
104 } 
105 } 
106 
107 public void incrementDependencies() { depend"
1403,506,"112 public int getNumberDependencies() { return dependencies; } 
113} 
This solution takes O ( P + D) time, where P is the number of projects and D is the number of dependency 
pairs. 
I
Note: You might recognize this as the topological sort algorithm on page 632. We've rederived 
this from scratch."
1404,430,"Suppose we picked an arbitrary node (say b) and performed a depth-first search on it. When we get to the 
end of a path and can't go any further (which will happen at h and e), we know that those terminating 
nodes can be the last projects to be built. No projects 
depend on them. 
DFS(b) // Step 1 "
1405,389,"DFS(e) // Step 5 
build order ... , e, h // Step 6 
// Step 7+ 
Now, consider what happens at node a when we return from the DFS of e. We know a's children need to 
appear after a in the build order. So, once we return from searching a's children (and therefore they have 
been added), we can choose "
1406,446,"Solutions to Chapter 4 I Trees and Graphs 
Once we return from a, and complete the DFS of b's other children, then everything that must appear after 
b is in the list. Add b to the front. 
DFS(b) 
DFS(h) 
build order 
DFS(a) 
DFS(e) 
.. . , h 
build order = ... , e, h 
build order = ... , a, e, h 
D"
1407,485,"// Step 5 
// Step 6 
// Step 7 
// Step 8 
// Step 9 
Let's mark these nodes as having been built too, just in case someone else needs to build them. 
Now what? We can start with any old node again, doing a DFS on it and then adding the node to the front 
of the build queue when the DFS is complete"
1408,483,"build order= f, c, d, g, b, a, e, h 
In an algorithm like this, we should think about the issue of cycles. There is no possible build order if there 
is a cycle. But still, we don't want to get stuck in an infinite loop just because there's no possible solution. 
A cycle will happen if, while doing "
1409,486,"What we can do for this is to mark each node as a""partial""(or""is visiting"") state just before we start 
the DFS on it. If we see any node whose state is partial, then we know we have a problem. When we're 
done with this node's DFS, we need to update the state. 
We also need a state to indicate ""I'v"
1410,271,"The code below implements this algorithm. 
1 Stack<Project> findBuildOrder(String[] projects, String[][] dependencies) { 
2 Graph graph= buildGraph(projects, dependencies); 
3 return orderProjects(graph .getNodes()); 
4 } 
CrackingTheCodinglnterview.com I 6th Edition 2SS"
1411,489,"Solutions to Chapter 4 I Trees and Graphs 
6 Stack<Project> orderProjects(ArrayList<Project> projects) { 
7 Stack<Project> stack = new Stack<Project>(); 
8 for (Project project: projects) { 
9 if (project.getState() == Project.State.BLANK) { 
10 if (!doDFS(project, stack)) { 
11 return null; 
12 } 
"
1412,491,"20 return false; // Cycle 
21 } 
22 
23 if (project.getState() == Project.State.BLANK) { 
24 project.setState(Project.State.PARTIAL); 
25 ArrayList<Project> children = project.getChildren(); 
26 for (Project child : children) { 
27 if (!doDFS(child, stack)) { 
28 
29 } 
return false; 
30 } 
31 proje"
1413,407,"39 public class Graph{} 
40 
41 /* Essentially equivalent to earlier solution, with state info added and 
42 * dependency count removed. */ 
43 public class Project { 
44 
45 
46 
47 
48 
49 } 
public enum State {COMPLETE, PARTIAL, BLANK}; 
private State state = State.BLANK; 
public State getState()"
1414,394,"/* Duplicate code removed for brevity*/ 
Like the earlier algorithm, this solution is O ( P+D) time, where P is the number of projects and D is the 
number of dependency pairs. 
By the way, this problem is called topological sort: linearly ordering the vertices in a graph such that for 
every edge ("
1415,498,"Solutions to Chapter 4 I Trees and Graphs 
4.8 First Common Ancestor: Design an algorithm and write code to find the first common ancestor 
of two nodes in a binary tree. Avoid storing additional nodes in a data structure. NOTE: This is not 
necessarily a binary search tree. 
pg 110 
SOLUTION 
If th"
1416,495,"Let's assume we're looking for the common ancestor of nodes p and q. One question to ask here is if each 
node in our tree has a link to its parents. 
Solution #1: With Links to Parents 
If each node has a link to its parent, we could trace p and q's paths up until they intersect. This is essentiall"
1417,504,"1 TreeNode commonAncestor(TreeNode p, TreeNode q) { 
2 int delta= depth(p) - depth(q); // get difference in depths 
3 TreeNode first = delta > 0? q : p; // get shallower node 
4 TreeNode second= delta > 0? p : q; // get deeper node 
5 second= goUpBy(second, Math.abs(delta)); // move deeper node up 
"
1418,508,"11 } 
12 return first== null I I second 
13 } 
14 
null? null first; 
15 TreeNode goUpBy(TreeNode node, int delta) { 
16 while (delta> 0 && node != null) { 
17 node= node.parent; 
18 delta--; 
19 } 
20 return node; 
21 } 
22 
23 int depth(TreeNode node) { 
24 int depth= 0; 
25 while (node != null) {"
1419,343,"Solution #2: With Links to Parents (Better Worst-Case Runtime) 
Similar to the earlier approach, we could trace p's path upwards and check if any of the nodes cover q. 
The first node that covers q (we already know that every node on this path will cover p) must be the first 
common ancestor. 
Crack"
1420,500,"Solutions to Chapter 4 I Trees and Graphs 
Observe that we don't need to re-check the entire subtree. As we move from a node x to its parent y, all the 
nodes under x have already been checked for q. Therefore, we only need to check the new nodes ""uncov­
ered'; which will be the nodes under x's sibl"
1421,450,"subtree for q. 
Next, we go to node 10, uncovering the subtree rooted at 15. We check this subtree for node 17 and­
voila-there it is. 
3 
To implement this, we can just traverse upwards from p, storing the parent and the sibling node in 
a variable. (The sibling node is always a child of parent and"
1422,485,"parent. 
1 TreeNode commonAncestor(TreeNode root, TreeNode p, TreeNode q) { 
2 /* Check if either node is not in the tree, or if one covers the other. */ 
3 if (!covers(root, p) 11 !covers(root, q)) { 
4 
5 
6 
7 
8 
9 
10 
} 
} 
} 
return null; 
else if (covers(p, q)) { 
return p; 
else if (covers("
1423,506,"14 while (!covers(sibling, q)) { 
15 sibling= getSibling(parent); 
16 parent= parent.parent; 
17 } 
18 return parent; 
19 } 
20 
21 boolean covers(TreeNode root, TreeNode p) { 
22 if (root== null) return false; 
23 if (root == p) return true; 
24 return covers(root.left, p) 11 covers(root.right, p);"
1424,416,"Solutions to Chapter 4 I Trees and Graphs 
33 return parent.left== node? parent.right : parent.left; 
34 } 
This algorithm takes O(t) time, where tis the size of the subtree for the first common ancestor. In the 
worst case, this will be O( n), where n is the number of nodes in the tree. We can deri"
1425,498,"Solution #3: Without Links to Parents 
Alternatively, you could follow a chain in which p and q are on the same side. That is, if p and q are both on 
the left of the node, branch left to look for the common ancestor. If they are both on the right, branch right 
to look for the common ancestor. When"
1426,486,"2 /* Error check - one node is not in the tree. */ 
3 if (!covers(root, p) 11 !c overs(root, q)) { 
4 return null; 
5 } 
6 return ancestorHelper(root, p, q); 
7 } 
8 
9 TreeNode ancestorHelper(TreeNode root, TreeNode p, TreeNode q) { 
10 if (root== null II root== p I I root== q) { 
11 return root; 
"
1427,419,"17 return root; 
18 } 
19 TreeNode childSide = pisOnLeft? root.left root.right; 
20 return ances torHelper(childSide, p, q); 
21 } 
22 
23 boolean covers(TreeNode root, TreeNode p) { 
24 if (root== null) return false; 
25 if (root== p) return true; 
26 return covers(root.left, p) I I covers(root.rig"
1428,468,"first call (n nodes for the left side, and n nodes for the right side). After that the algorithm branches left or 
right, at which point covers will be called on 2rz nodes, then 2X, and so on. This results in a runtime 
ofO(n). 
We know at this point that we cannot do better than that in terms of th"
1429,443,"Solution #4: Optimized 
Although Solution #3 is optimal in its runtime, we may recognize that there is still some inefficiency in how 
it operates. Specifically, covers searches all nodes under root for p and q, including the nodes in each 
subtree (root. left and root. right). Then, it picks one of"
1430,480,"Solutions to Chapter 4 I Trees and Graphs 
We may recognize that we should only need to search the entire tree once to find p and q. We should then 
be able to ""bubble up"" the findings to earlier nodes in the stack. The basic logic is the same as the earlier 
solution. 
We recurse through the entire"
1431,505,"Returns p, if root's subtree includes p (and not q). 
Returns q, if root's subtree includes q (and not p). 
Returns null, if neither p nor q are in root's subtree. 
Else, returns the common ancestor of p and q. 
Finding the common ancestor of p and q in the final case is easy. When commonAncestor(n."
1432,447,"The code below offers an initial 
solution, but it has a bug. Can you find it? 
1 I* The below code has a bug. *I
2 TreeNode commonAncestor(TreeNode root, TreeNode p, TreeNode q) { 
3 if (root null) return null; 
4 if (root == p && root == q) return root; 
5 
6 TreeNode x 
= commonAncestor(root.left"
1433,408,"9 } 
Hi 
11 TreeNode y = commonAncestor(root.right, p, q); 
12 if (y != null && y != p && y != q) { II Already found ancestor 
13 return y; 
14 } 
15 
16 if (x != null && y != null) { II p and q found in diff. subtrees 
17 return root; II This is the common ancestor 
18 } else if (root == p I I root"
1434,456,"22 } 
23 } 
The problem with this code occurs in the case where a node is not contained in the tree. For example, look 
at the following tree: 
1 5 
8 
Suppose we call commonAncestor(node 3, node 5, node 7).0f course,node 7does not exist­
and that's where the issue will come in. The calling order lo"
1435,446,"Solutions to Chapter 4 I Trees and Graphs 
3 calls commonAnc(node 5, node 5, node 7) // --> 5 
4 calls commonAnc(node 8, node 5, node 7) // --> null 
In other words, when we call commonAn cestor on the right subtree, the code will return no de 5, just as 
it should. The problem is that in finding th"
1436,501,"• Case 1: pi s a child of q (or, q is a child of p)
Case 2: p is in the tree and q is not (or, q is in the tree and pis not)
In either of these cases, commonAnce stor will return p. In the first case, this is the correct return value, but 
in the second case, the return value should be null. 
We som"
1437,510,"actually the common ancestor. 
1 class Result { 
2 public TreeNode node; 
3 public boolean isAncestor; 
4 public Result(TreeNode n, boolean isAnc) { 
5 node = n; 
6 isAncestor = isAnc; 
7 } 
8 } 
9 
10 TreeNode commonAncestor(TreeNode root, TreeNode p, TreeNode q) { 
11 Result r = commonAncestorHelp"
1438,487,"19 if (root null) return new Result(null, false); 
20 
21 if (root p && root== q) { 
22 return new Result(root, true); 
23 } 
24 
25 Result rx = commonAncHelper(root.left, p, q); 
26 if (rx.isAncestor) {//Found common ancestor 
27 return rx; 
28 } 
29 
30 Result ry = commonAncHelper(root.right, p, q"
1439,307,"37 } else if (root == p I I root == q) { 
38 /* If we're currently at p or q, and we also found one of those nodes in a 
39 * subtree, then this is truly an ancestor and the flag should be true. */
40 boolean isAncestor = rx.node != null I I ry.node != null;
CrackingTheCodinglnterview.com J 6th Edit"
1440,469,"Solutions to Chapter 4 I Trees and Graphs 
41 
42 } 
43 
44 } 
45 } 
return 
else { 
return 
new Result(root, isAncesto r); 
new Result(rx.node!=null? rx.node ry.node, false); 
Of course, as this issue only comes up when p or q is not actually in the tree, an alternative solution would 
be to first "
1441,494,"and inserting each element. Given a binary search tree with distinct elements, print all possible 
arrays that could have led to this tree. 
EXAMPLE 
Input: 
Output: {2, 1, 3}, {2, 3, 1} 
pg 110 
SOLUTION 
It's useful to kick off this question with a good example. 
5 80 
We should also think about t"
1442,454,"there. 
What this means is that the very first element in our array must have been a 50 in order to create the above 
tree. If it were anything else, then that value would have been the root instead. 
What else can we say? Some people jump to the conclusion that everything on the left must have been"
1443,452,"left or right items doesn't matter. 
Once the 50 is inserted, all items less than 50 will be routed to the left and all items greater than 50 will be 
routed to the right. The 60 or the 20 could be inserted first, and it wouldn't matter. 
Let's think about this problem recursively. If we had all arr"
1444,222,"a rray5et60), how would that give us the full answer? We could just""weave"" each array from a rray5et20 
with each array from arraySet60-and then prepend each array with a 50. 
262 Cracking the Coding Interview, 6th Edition"
1445,462,"Solutions to Chapter 4 I Trees and Graphs 
Here's what we mean by weaving. We are merging two arrays in all possible ways, while keeping the 
elements within each array in the same relative order. 
arrayl: {l, 2} 
array2: { 3, 4} 
weaved: {l, 2, 3, 4}, {l, 3, 2, 4}, {1, 3, 4, 2}, 
{3, 1, 2, 4}, {3, "
1446,494,"weaving will create duplicates. 
The last piece to talk about here is how the weaving works . Let's think recursively about how to weave {1, 
2, 3}and{4, S, 6}. What are the subproblems? 
Prepend al to all weaves of{2, 3}and{4, 5, 6}. 
Prepend a4 to all weaves of{l, 2, 3}and{S, 6}. 
To implement thi"
1447,484,"add the remainder to prefix and store the result. 
It works something like this: 
weave(first, second, prefix): 
weave({l, 2}, {3, 4}, {}) 
weave({2}, {3, 4}, {1}) 
weave({}, {3, 4}, {l, 2}) 
{1, 2, 3, 4} 
weave({2}, {4}, {1, 3}) 
weave({}, {4}, {l, 3, 2}) 
{l, 3, 2, 4} 
weave({2}, {}, {l, 3, 4}) 
{"
1448,473,"{3, 1, 4, 2} 
weave({l, 2}, {}, {3, 4}) 
{3, 4, 1, 2} 
Now, let's think through the implementation of removing, say, 1 from { 1, 2} and recursing. We need to be 
careful about modifying this list, since a later recursive call (e .g., weave( {1, 2}, { 4}, {3})) might need 
the 1 still in {1, 2}. 
We "
1449,466,"We've chosen to implement it the latter way. Since we're keeping the same reference to first, second, and 
prefix the entire way down the recursive call stack, then we'll need to clone prefix just before we store 
the complete result. 
1 ArrayList<LinkedList<Integer>> allSequences(TreeNocte node) { "
1450,108,"5 result.add(new Linkedlist<Integer>()); 
6 return result; 
CrackingTheCodinglnterview.com j 6th Edition 263"
1451,491,"Solutions to Chapter 4 I Trees and Graphs 
7 } 
8 
9 Linkedlist<Integer> prefix new Linkedlist<Integer>(); 
10 prefix.add(node.data); 
11 
12 /* Recurse on left and right subtrees. */ 
13 Arraylist<Linkedlist<Integer>> leftSeq = al1Sequences(node.left); 
14 ArrayList<LinkedList<Integer>> rightSeq = "
1452,503,"18 for (LinkedList<Integer> right : rightSeq) { 
19 ArrayList<LinkedList<Integer>> weaved= 
20 new Arraylist<Linkedlist<Integer>>(); 
21 weavelists(left, right, weaved, prefix); 
22 result.addAll(weaved); 
23 } 
24 } 
25 return result; 
26 } 
27 
28 /* Weave lists together in all possible ways. This"
1453,462,"32 ArrayList<LinkedList<Integer>> results, LinkedList<Integer> prefix) { 
33 /* One list is empty. Add remainder to [a cloned] prefix and store result. */ 
34 if (first.size() == 0 11 second.size() == 0) { 
35 Linkedlist<Integer> result = (Linkedlist<Integer>) prefix.clone(); 
36 result.addAll(first"
1454,510,"43 * first, so we'll need to put it back where we found it afterwards. */
44 int headfirst= first.removeFirst(); 
45 prefix.addLast(headFirst); 
46 weavelists(first, second, results, prefix); 
47 prefix.removelast(); 
48 first.addFirst(headFirst); 
49 
50 /* Do the same thing with second, damaging a"
1455,422,"54 prefix.removelast(); 
55 second.addFirst(headSecond); 
56 } 
Some people struggle with this problem because there are two different recursive algorithms that must be 
designed and implemented. They get confused with how the algorithms should interact with each other 
and they try to juggle both i"
1456,147,"menting an independent method, and focus on the one thing that this independent method needs to do. 
264 Cracking the Coding Interview, 6th Edition"
1457,470,"Solutions to Chapter 4 I Trees and Graphs 
Look at weaveLists. It has a specific job: to weave two lists together and return a list of all possible 
weaves. The existence of allSequences is irrelevant. Focus on the task that weavelists has to do and 
design this algorithm. 
As you're implementing al"
1458,450,"operates while implementing something that is essentially independent. Focus on what you're doing while 
you're doing it. 
In fact, this is good advice in general when you're confused during whiteboard coding. Have a good under­
standing of what a particular function should do (""okay, this function "
1459,509,"the one you are dealing with and trust that the others do the right thing. It's often too much to keep the 
implementations of multiple algorithms straight in your head. 
4.1 O Check Subtree: Tl and T2 are two very large binary trees, with Tl much bigger than T2. Create an 
algorithm to determine if"
1460,501,"pg 111 
SOLUTION 
In problems like this, it's useful to attempt to solve the problem assuming that there is just a small amount 
of data. This will give us a basic idea of an approach that might work. 
The Simple Approach 
In this smaller, simpler problem, we could consider comparing string represen"
1461,410,"we use an in-order traversal or a pre-order traversal? 
An in-order traversal will definitely not work. After all, consider a scenario in which we were using binary 
search trees. A binary search tree's in-order traversal always prints out the values in sorted order. Therefore, 
two binary search tr"
1462,454,"structure is different. 
What about a pre-order traversal? This is a bit more promising. At least in this case we know certain things, 
like the first element in the pre-order traversal is the root node. The left and right elements will follow. 
Unfortunately, trees with different structures could s"
1463,449,"like an 'X'. (We'll assume that the binary trees contain only integers.) The left tree would have the traversal 
{ 3, 4, X} and the right tree will have the traversal { 3, X, 4}. 
Observe that, as long as we represent the NULL nodes, the pre-order traversal of a tree is unique. That is, if 
two tree"
1464,414,"Solutions to Chapter 4 I Trees and Graphs 
To see this, consider reconstructing a tree from its pre-order traversal (with NULL nodes indicated). For 
example: 1, 2, 4, X, X, X, 3, X, X. 
The root is 1, and its left node, 2, follows it. 2.left must be 4. 4 must have two NULL nodes (since it is follow"
1465,502,"is now complete, so we move to 1 's right child. We place a 3 with two NULL children there. The tree is now 
complete. 
This whole process was deterministic, as it will be on any other tree. A pre-order traversal always starts at 
the root and, from there, the path we take is entirely defined by the"
1466,510,"T2's root element must be found in Tl. If we do a pre-order traversal from this element in Tl, we will follow 
an identical path to T2's traversal. Therefore, T2 is a subtree of Tl. 
Implementing th is is quite stra ig htforwa rd. We just need to construct and com pa re the pre-order traversa Is. 
1"
1467,428,"5 getOrderString(tl, stringl); 
6 getOrderString(t2, string2); 
7 
8 return stringl.index Of(string2.toString()) != -1; 
9 } 
10 
11 void getOrderString(TreeNode node, StringBuilder sb) { 
12 if (node == null) { 
13 sb. append ( ""X""); / / Add null indicator 
14 return; 
15 } 
16 
17 
18 
19 } 
sb. a"
1468,475,"getOrderString(node.right, sb); // Add right 
This approach takes O(n + m) time and O(n + m) space, where n and mare the number of nodes in Tl 
and T2, respectively. Given millions of nodes, we might want to reduce the space complexity. 
The Alternative Approach 
An alternative approach is to search"
1469,304,"Analyzing the runtime is somewhat complex. A naive answer would be to say that it is O(nm) time, where 
n is the number of nodes in Tl and mis the number of nodes in T2. While this is technically correct, a little 
more thought can produce a tighter bound. 
266 Cracking the Coding Interview, 6th Edi"
1470,487,"Solutions to Chapter 4 I Trees and Graphs 
We do not actually call match Tree on every node in Tl. Rather, we call it k times, where k is the number 
of occurrences ofT2's root in Tl. The runtime is closer too( n + km). 
In fact, even that overstates the runtime. Even if the root were identical, we "
1471,490,"match Tree. 
The code below implements this algorithm. 
1 boolean containsTree(TreeNode tl, TreeNode t2) { 
2 if (t2 == null) return true; II The empty tree is always a subtree 
3 return subTree(tl, t2); 
4 } 
5 
6 boolean subTree(TreeNode rl, TreeNode r2) { 
7 if (rl == null) { 
8 return false; II "
1472,432,"13 } 
14 
15 boolean matchTree(TreeNode rl, TreeNode r2) { 
16 if (rl == null && r2 == null) { 
17 return true; II nothing left in the subtree 
18 } else if (rl == null II r2 == null) { 
19 return false; II exactly tree is empty, therefore trees don't match 
20 } else if (rl.data != r2.data) { 
21 r"
1473,489,"24 } 
25 }
When might the simple solution be better, and when might the alternative approach be better? This is a 
great conversation to have with your interviewer. Here are a few thoughts on that matter: 
1. The simple solution takes O(n + m) memory. The alternative solution takes O(log(n) + log(m)"
1474,483,"However, the worst case time can be deceiving; we need to look deeper than that.
3. A slightly tighter bound on the runtime, as explained earlier, is O ( n + km), where k is the number of
occurrences ofT2's root in Tl. Let's suppose the node data for Tl and T2 were random numbers picked
between O an"
1475,419,"say p = 1000, n = 1000000 and m = 100. We would do somewhere around l, 100,000 node checks
(1100000 = 1000000 + 100 ·1���0000 ). 
4. More complex mathematics and assumptions could get us an even tighter bound. We assumed in #3
above that if we call match Tree, we would end up traversing all m nodes "
1476,264,"In summary, the alternative approach is certainly more optimal in terms of space and is likely more optimal 
in terms of time as well. It all depends on what assumptions you make and whether you prioritize reducing 
CrackingTheCodinglnterview.com I 6th Edition 267"
1477,452,"Solutions to Chapter 4 I Trees and Graphs 
the average case runtime at the expense of the worst case runtime. This is an excellent point to make to 
your interviewer. 
4.11 Random Node: You are implementing a binary search tree class from scratch, which, in addition 
to insert, find, and delete, has"
1478,425,"for getRandomNode, and explain how you would implement the rest of the methods. 
pg 111 
SOLUTION 
Let's draw an example. 
3 
We're going to explore many solutions until we get to an optimal one that works. 
One thing we should realize here is that the question was phrased in a very interesting way."
1479,496,"is a class that we're building from scratch. There is a reason the question was phrased that way. We probably 
need access to some part of the internals of the data structure. 
Option #1 [Slow & Working] 
One solution is to copy all the nodes to an array and return a random element in the array. Thi"
1480,486,"straightforward (and should make us wonder why the interviewer gave us a binary tree, since we don't 
need that information). 
We should keep in mind as we develop this solution that we probably need to know something about the 
internals of the tree. Otherwise, the question probably wouldn't specif"
1481,433,"maintain an array at all times that lists all the nodes in the tree. The problem is that we'll need to remove 
nodes from this array as we delete them from the tree, and that will take O ( N) time. 
Option #3 [Slow & Working] 
We could label all the nodes with an index from 1 to N and label them in "
1482,156,"between 1 and N. If we apply the label correctly, we can use a binary search tree search to find this index. 
268 Cracking the Coding Interview, 6th Edition"
1483,505,"Solutions to Chapter 4 I Trees and Graphs 
However, this leads to a similar issue as earlier solutions. When we insert a node or a delete a node, all of the 
indices might need to be updated. This can take O(N) time. 
Option #4 [Fast & Not Working] 
What if we knew the depth of the tree? (Since we'r"
1484,490,"wouldn't actually ensure that all nodes are equally likely to be chosen though. 
First, the tree doesn't necessarily have an equal number of nodes at each level. This means that nodes on 
levels with fewer nodes might be more likely to be chosen than nodes on a level with more nodes. 
Second, the ra"
1485,456,"Option #5 [Fast & Not Working] 
We could try just a simple approach: traverse randomly down the tree. At each node: 
, With X odds, we return the current node. 
• With X odds, we traverse left.
With X odds, we traverse right.
This solution, like some of the others, does not distribute the probabilit"
1486,493,"Option #6 [Fast & Working] 
Rather than just continuing to brainstorm new solutions, let's see if we can fix some of the issues in the 
previous solutions. To do so, we must diagnose-deeply-the root problem in a solution. 
Let's look at Option #5. It fails because the probabilities aren't evenly dis"
1487,446,"must return the root node with X probability. (In fact, we must return each node with X probability.
After all, we have N nodes and each must have equal probability. The total must be 1 (100%), therefore each 
must have X probability.) 
We've resolved the issue with the root. Now what about the rest"
1488,483,"side might not be equal. If we have more nodes on the left than the right, then we need to go left more 
often. 
One way to think about it is that the odds of picking something-anything-from the left must be the sum 
of each individual probability. Since each node must have probability X, the odds o"
1489,491,"Likewise, the odds of going right should be RIGHT _SIZE * X. 
This means that each node must know the size of the nodes on the left and the size of the nodes on the 
right. Fortunately, our interviewer has told us that we're building this tree class from scratch. It's easy to 
keep track of this siz"
1490,509,"Solutions to Chapter 4 I Trees and Graphs 
1 class TreeNode { 
2 private int data; 
3 public TreeNode left; 
4 public TreeNode right; 
5 private int size = 0; 
6 
7 public TreeNode(int d) { 
8 data = d; 
9 size = 1; 
10 } 
11 
12 public TreeNode getRandomNode() { 
13 int leftSize =left == null? 0 le"
1491,494,"19 return this; 
20 } else { 
21 return right.getRandomNode(); 
22 } 
23 } 
24 
25 public void insertinOrder(int d) { 
26 if (d <= data) { 
27 if (left == null) { 
28 left = new TreeNode(d); 
29 } else { 
30 left. insertlnOrder( d); 
31 } 
32 } else { 
33 if (right == null) { 
34 right = new TreeNod"
1492,393,"44 
45 public TreeNode find(int d) { 
46 if (d == data) { 
47 return this; 
48 } else if (d <= data) { 
49 return left != null? left.find(d) : null; 
50 } else if (d > data) { 
51 return right != null ? right.find(d) : null; 
52 } 
53 return null; 
54 } 
55 } 
In a balanced tree, this algorithm will"
1493,467,"Solutions to Chapter 4 I Trees and Graphs 
Option #7 [Fast & Working] 
Random number calls can be expensive. If we'd like, we can reduce the number of random number calls 
substantially. 
Imagine we called getRandomNode on the tree below, and then traversed left. 
35 
3 
We traversed left because we"
1494,501,"But what if we went right instead? We have a number between 7 and 8 (inclusive) but we would need a 
number between O and 1 (inclusive). That's easy to fix:just subtract out LEFT _SIZE + 1. 
Another way to think about what we're doing is that the initial random number call indicates which node 
(i) "
1495,472,"1 class Tree { 
2 TreeNode root= null; 
3 
4 
s 
public int size() { return root 
6 public TreeNode getRandomNode() { 
7 if (root == null) return null; 
8 
9 Random random = new Random(); 
10 int i= random.nextlnt(size()); 
11 return root.getlthNode(i); 
12 } 
13 
null? 0 root.size(); } 
14 public v"
1496,349,"19 } 
20 } 
21 } 
22 
23 class TreeNode { 
24 /* constructor and variables are the same. */ 
25 
26 public TreeNode getlthNode(int i) { 
27 int leftSize =left== null? 0: left.size(); 
28 if (i < leftSize) { 
29 return left.getithNode(i); 
30 } else if (i == leftSize) { 
31 return this; 
32 } else { "
1497,419,"Solutions to Chapter 4 I Trees and Graphs 
33 /* Skipping over leftSize + 1 nodes, so subtract them. */ 
34 return right.getlthNode(i - (leftSize + 1)); 
35 } 
36 } 
37 
38 
39 
40 
41 } 
public void insertlnOrder(int d) {/* same */} 
public int size() { return size; } 
public TreeNode find(int d) {"
1498,511,"the runtime as O(D), where Dis the max depth of the tree. Note that O(D) is an accurate description of the 
runtime whether the tree is balanced or not. 
4.12 Paths with Sum: You are given a binary tree in which each node contains an integer value (which 
might be positive or negative). Design an al"
1499,499,"(traveling only from parent nodes to child nodes). 
pg 711
SOLUTION 
Let's pick a potential sum-say, 8-and then draw a binary tree based on this. This tree intentionally has a 
. number of paths with this sum. 
3 
One option is the brute force approach. 
Solution #1: Brute Force 
In the brute force "
1500,479,"we increment the total. 
1 int countPathsWithSum(TreeNode root, int targetSum) { 
2 if (root == null) return 0; 
3 
4 /* Count paths with sum starting from the root. */ 
5 int pathsFromRoot = countPathsWithSumFromNode(root, targetSum, 0); 
7 /* Try the nodes on the left and right. */ 
8 int pathsOnl"
1501,133,"12 } 
13 
14 /* Returns the number of paths with this sum starting from this node. */ 
272 Cracking the Coding Interview, 6th Edition"
1502,497,"Solutions to Chapter 4 I Trees and Graphs 
1� int countPathsWithSumFromNode(TreeNode node, int targetSum, int currentSum) { 
16 if (node == null) return 0; 
17 
18 currentSum += node.data; 
19 
20 int totalPaths = 0; 
21 if (currentSum == targetSum) { II Found a path from the root 
22 totalPaths++; "
1503,497,"27 return totalPaths; 
28 } 
What is the time complexity of this algorithm? 
Consider that node at depth d will be ""touched"" (via countPathsWi thSumFromNode) by d nodes above it. 
In a balanced binary tree, d will be no more than approximately log N. Therefore, we know that with N
nodes in the tree,"
1504,448,"it (via countPathsWi thSumFromNode). At the second level (where there are two nodes), we traverse to N - 3 
nodes. At the third level (where there are four nodes, plus three above those), we traverse to N - 7 nodes. 
Following this pattern, the total work is roughly: 
(N - 1) + (N - 3) + (N - 7) + ("
1505,457,"of two. The number of terms is the depth of the tree, which is O(log N). For the right side, we can ignore 
the fact that it's one less than a power of two. Therefore, we really have this: 
O(N * [number of terms] - [su m of powers of two from 1 through NJ) 
O(N log N - N)
O(N log N) 
If the value o"
1506,499,"of two look like in binary: 
0001 
+ 0010
+ 0100
+ 1000
= 1111 
Therefore, the runtime is O(N log N) in a balanced tree. 
In an unbalanced tree, the runtime could be much worse. Consider a tree that is just a straight line down. At 
the root, we traverse to N - 1 nodes. At the next level (with just "
1507,467,"and N, which is 0( N2 ). 
Solution #2: Optimized 
In analyzing the last solution, we may realize that we repeat some work. For a path such as 10 -> 5 -> 
3 -> -2, we traverse this path (or parts of it) repeatedly. We do it when we start with node 10, then when 
we go to node 5 (looking at 5, then 3,"
1508,447,"Solutions to Chapter 4 I Trees and Graphs 
3 
Let's isolate a given path and treat it as just an array. Consider a (hypothetical, extended) path like: 
10 -> 5 -> 1 -> 2 -> -1 -> -1 -> 7 -> 1 -> 2 
What we're really saying then is: How many contiguous subsequences in this array sum to a target sum s"
1509,454,"of x values below.) 
t t t 
s X y 
If each value knows its running sum (the sum of values from s through itself), then we can find this pretty 
easily. We just need to leverage this simple equation: runningSumx = runningSumY - targetSum. 
We then look for the values of x where this is true. 
t 
t 
s"
1510,491,"build a hash table that maps from a runningSum to the number of times we've seen that sum. Then, for 
each y, look up runningSumY - targetSum in the hash table. The value in the hash table will tell you
the number of paths with sum targets um that end at y. 
For example: 
index: 0 1 2 3 4 5 6 7 8 
v"
1511,370,"a value of 2 (originating from index 2 and index 5). As we can see above, indexes 3 through 7 and indexes 
6 through 7 have sums of 8. 
Now that we've settled the algorithm for an array, let's review this on a tree. We take a similar approach. 
We traverse through the tree using depth-first search. "
1512,468,"Solutions to Chapter 4 I Trees and Graphs 
1. Track its runningSum. We'll take this in as a parameter and immediately increment it by node. value.
2. Look up runningSum - targetSum in the hash table. The value there indicates the total number. Set
totalPaths to this value.
3. If runningSum == target"
1513,485,"5. Recurse left and right, counting the number of paths with sum targetSum.
6. After we're done recursing left and right, decrement the value of runningSum in the hash table. This is
essentially backing out of our work; it reverses the changes to the hash table so that other nodes don't
use it (sinc"
1514,486,"1 int countPathsWithSum(TreeNode root, int targetSum) { 
2 return countPathsWithSum(root, targetSum, 0, new HashMap<Integer, Integer>()); 
3 } 
4 
5 int countPathsWithSum(TreeNode node, int targetSum, int runningSum, 
6 HashMap<Integer, Integer> pathCount) { 
7 if (node == null) return 0; // Base ca"
1515,443,"12 int totalPaths = pathCount.getOrDefault(sum, 0); 
13 
14 /* If runningSum equals targetSum, then one additional path starts at root. 
15 * Add in this path.*/
16 if (runningSum == targetSum) {
17 totalPaths++; 
18 } 
19 
20 /* Increment pathCount, recurse, then decrement pathCount. */ 
21 increme"
1516,490,"23 totalPaths += countPathsWithSum(node.right, targetSum, runningSum, pathCount); 
24 incrementHashTable(pathCount, runningSum, -1); // Decrement pathCount 
25 
26 return totalPaths; 
27 } 
28 
29 void incrementHashTable(HashMap<Integer, Integer> hashTable, int key, int delta) { 
30 int newCount = h"
1517,423,"33 } else { 
34 hashTable.put(key, newCount); 
35 } 
36 } 
The runtime for this algorithm is O(N), where N is the number of nodes in the tree. We know it is O(N) 
because we travel to each node just once, doing 0(1) work each time. In a balanced tree, the space 
complexity is O ( log N) due to the h"
1518,504,"5 
Solutions to Bit Manipulation 
5.1 Insertion: You are given two 32-bit numbers, N and M, and two bit positions, i and j. Write a method 
to insert Minto N such that M starts at bit j and ends at bit i. You can assume that the bits j through 
i have enough space to fit all of M. That is, if M = 10"
1519,397,"fit between bit 3 and bit 2. 
EXAMPLE 
Input: N 
Output: N 
SOLUTION 
10000000000, M 
10001001100 
10011, i = 2, j 
This problem can be approached in three key steps: 
1. Clear the bits j through i in N
2. Shift M so that it lines up with bits j through i
3. Merge Mand N. 
6 
pg 115 
The trickiest p"
1520,491,"1 s, except for Os in the bits j through i. We create this mask by creating the left half of the mask first, and 
then the right half. 
1 int updateBits(int n, int m, int i, int j) { 
2 I* Create a mask to clear bits i through ji nn . EXAMPLE: i = 2, j = 4. Result 
3 * should be 11100011. For simpli"
1521,424,"7 int left= allOnes << (j + 1); 
8 
9 II l's after position i. right = 00000011 
10 int right = ((1 << i) - 1); 
11 
12 II All ls, except for 0s between i and j. mask 11100011 
13 int mask left I right; 
14 
15 /* Clear bits j through i then put min there *I
16 int n_c leared = n & mask; II Clear bi"
1522,484,"Solutions to Chapter 5 I Bit Manipulation 
18 
19 return n_cleared I m_shifted; // OR them, and we're done! 
20 } 
In a problem like this (and many bit manipulation problems), you should make sure to thoroughly test your 
code. It's extremely easy to wind up with off-by-one errors. 
5.2 Binary to St"
1523,489,"most 32 characters, print""ERROR:' 
pg 176 
SOLUTION 
NOTE: When otherwise ambiguous, we'll use the subscripts x2 and x10 to indicate whether xis in base 2 or 
base 10. 
First, let's start off by asking ourselves what a non-integer number in binary looks like. By analogy to a 
decimal number, the bin"
1524,471,"""shifting""the fractional sum. That is: 
r 210 * n 
210*0.1012 
1 * Xo + 0 * XI + 1 * X,
1.012 
If r >= 1, then we know that n had a 
1 right after the decimal point. By doing this continuously, we can 
check every digit. 
1 String printBinary(double num) { 
2 if (num >= 1 I I num <= 0) { 
3 return """
1525,349,"20 
21 
22 
23 
24 } 
binary.append("".""); 
while (num > 0) { 
/* Setting a limit on length: 32 characters */ 
if (binary. length() >= 32) { 
return ""ERROR""; 
} 
double r= num * 2; 
if (r >= 1) { 
binary.append(l); 
num = r - 1; 
} else { 
} 
} 
binary.append(0); 
num = r; 
return binary.toString(); "
1526,511,"Solutions to Chapter 5 \ Bit Manipulation 
Alternatively, rather than multiplying the number by two and comparing it to 1, we can compare the 
number to . 5, then . 25, and so on. The code below demonstrates this approach. 
1 String printBinary2(double num) { 
2 if (num >= 1 II num <= 0) { 
3 return"
1527,433,"11 if (binary.length() > 32) { 
12 return ""ERROR""; 
13 } 
14 if (num >= frac) { 
15 binary.append(l); 
15 num -= frac; 
17 } else { 
18 binary.append(0); 
19 } 
20 frac /= 2; 
21 } 
22 return binary.toString(); 
23 } 
Both approaches are equally good; choose the one you feel most comfortable with. 
"
1528,460,"through them in your interview. 
5.3 Flip Bit to Win: You have an integer and you can flip exactly one bit from a Ot o a 1. Write code to 
find the length of the longest sequence of 1 s you could create. 
EXAMPLE 
Input: 1775 
Output: 8 
SOLUTION 
(or: 11011101111) 
pg 116 
We can think about each i"
1529,427,"Brute Force 
One approach is to convert an integer into an array that reflects the lengths of the Os and 1 s sequences. For 
example, 11011101111 would be (reading from right to left) [00, 41, 10, 31, 10, 21, 210]. The
subscript reflects whether the integer corresponds to a Os sequence or a 
1 s seq"
1530,237,"Once we have this, we just walk through the array. At each Os sequence, then we consider merging the 
adjacent 1 s sequences if the Os sequence has length 1. 
l int longestSequence(int n) { 
278 Cracking the Coding Interview, 6th Edition"
1531,511,"Solutions to Chapter 5 I Bit Manipulation 
2 if (n == -1) return Integer.BYTES* 8; 
3 Arraylist<Integer> sequences = getAlternatingSequences(n); 
4 return findLongestSequence(sequences); 
5 } 
7 /* Return a list of the sizes of the sequences. The sequence starts off with the 
8 number of 0s (which m"
1532,498,"12 
13 int searchingFor 0; 
14 int counter = 0; 
15 
16 for (int i= 0; i <Integer.BYTES * 8; i++) { 
17 if ((n & 1) != searchingFor) { 
18 sequences. add(counter); 
19 searchingFor = n & 1; // Flip 1 to 0 or 0 to 1 
20 counter = 0; 
21 } 
22 counter++; 
23 n >>>= 1; 
24 } 
25 sequences.add(counter);"
1533,495,"32 int findlongestSequence(ArrayList<Integer> seq) { 
33 int maxSeq 1; 
34 
35 
36 
37 
38 
39 
for (int i 0; i < seq.size(); i += 2) { 
int zerosSeq = seq.get(i); 
int onesSeqRight = i - 1 >= 0? seq.get(i - 1) : 
int onesSeqLeft = i + 1 < seq.size() ? seq.get(i 
40 int thisSeq = 0; 
41 if (zerosSeq"
1534,401,"44 thisSeq = 1 + Math.max(onesSeqRight, onesSeqLeft); 
0· ,
45 } else if (zerosSeq == 0) {//No zero, but take either side 
46 thisSeq = Math.max(onesSeqRight, 
onesSeqLeft); 
47 } 
48 maxSeq = Math.max(thisSeq, maxSeq); 
49 } 
50 
51 return maxSeq; 
52 } 
This is pretty good. It's O ( b) time and O "
1535,448,"Solutions to Chapter 5 I Bit Manipulation 
I 
Be careful with how you express the runtime. For example, if you say the runtime isO(n), what is 
n? It is not correct to say that this algorithm is O(value of the integer). This algorithm is O(number 
of bits). For this reason, when you have potential a"
1536,435,"We used ""b'; for the number of bits. Something logical works well. 
Can we do better? Recall the concept of Best Conceivable Runtime. The B.C.R. for this algorithm is 0( b) 
(since we'll always have to read through the sequence), so we know we can't optimize the time. We can, 
however, reduce the me"
1537,493,"time. We only need it long enough to compare each 1 s sequence to the immediately preceding 1 s sequence. 
Therefore, we can just walk through the integer doing this, tracking the current 1 s sequence length and the 
previous ls sequence length. When we see a zero, update previous Length: 
If the ne"
1538,496,"Update max Length as we go. 
1 int flipBit(int a) { 
2 I* If all ls, this is already the longest sequence. *I
3 if (=a== 0) return Integer.BYTES * 8; 
4 
5 int currentlength = 0; 
6 int previouslength = 0; 
7 int maxlength = 1; II We can always have 
a sequence of at least one 1 
8 while (a!= 0) { 
"
1539,475,"13 previouslength = (a & 2) == 0? 0 
: currentlength; 
14 currentLength = 0; 
15 } 
16 maxlength = Math.max(previouslength + currentlength + 1, maxlength); 
17 a>>>= 1; 
18 } 
19 return maxlength; 
20 } 
The runtime of this algorithm is still O ( b), but we use only O ( 1) additional memory. 
5.4 Ne"
1540,372,"pg 116 
SOLUTION 
There are a number of ways to approach this problem, including using brute force, using bit manipulation, 
and using clever arithmetic. Note that the arithmetic approach builds on the bit manipulation approach. 
You'll want to understand the bit manipulation approach before going o"
1541,500,"Solutions to Chapter 5 I Bit Manipulation 
I
The terminology can be confusing for this problem. We'll call get Next the bigger number and 
getPrev the smaller number. 
The Brute Force Approach 
An easy approach is simply brute force: count the number of ls in n, and then increment (or decrement) 
un"
1542,428,"Bit Manipulation Approach for Get Next Number 
If we think about what the next number should be, we can observe the following. Given the number 13948, 
the binary representation looks like: 
1 1 0 1 1 0 0 1 1 1 1 1 0 0 
We want to make this number bigger (but not too big). We also need to keep the s"
1543,453,"j from a 0 to a 1. If i > j, then n will have decreased. If i < j, then n will have increased. 
We know the following: 
1. If we flip a zero to a one, we must flip a one to a zero.
2. When we do that, the number will be bigger if and only if the zero-to-one bit was to the left of the one­
to-zero bi"
1544,458,"most zero which has ones on the right of it.
To put this in a different way, we are flipping the rightmost non-trailing zero. That is, using the above 
example, the trailing zeros are in the 0th and 1st spot. The rightmost non-trailing zero is at bit 7. Let's call 
this position p. 
Step 1: Flip rig"
1545,406,"zeros. We'll need to shrink the size of our number as much as possible while keeping that in mind. 
We can shrink the number by rearranging all the bits to the right of bit p such that the 0s are on the left and 
the ls are on the right. As we do this, we want to replace one of the 1 s with a 0. 
A "
1546,231,"0 until p, and then add back in cl-1 ones. Let cl be the number of ones to the right of p and c0 be the 
number of zeros to the right of p. 
Let's walk through this with an example. 
CrackingTheCodinglnterview.com / 6th Edition 281"
1547,493,"Solutions to Chapter 5 I Bit Manipulation 
Step2:Clearbitstotheright ofp.Frombefore,c0 = 2.c1 = 5.p = 7.
I 
,
1
3 I ,
1
, I : I ,
1
• I � I : I � I : I : I : I : I � I : I : I 
To clear these bits, we need to create a mask that is a sequence of ones, followed by p zeros. We can do this 
as follows: "
1548,501,"// all ones, followed by p zeros. 
// clears rightmost p bits. 
Or, more concisely, we do: 
n &= �((1 << p) - 1).
Step 3: Add in c 1 - 1 ones.
To insert cl - 1 ones on the right, we do the following: 
a 1 « (cl - 1); II 0s with a 1 at position cl - 1 
b = a - 1; II 0S with ls at positions 0 through "
1549,493,"The code for get Next is below. 
1 int getNext(int n) { 
2 I* Compute c0 and cl *I
3 int c = n; 
4 int c0 = 0; 
5 int cl = 0; 
6 while (((c & 1) == 0) && (c != 0)) { 
7 c0 ++; 
8 C >>= l; 
9 } 
10 
11 while ((c & 1) 
12 cl++; 
13 C >>= 1; 
14 } 
15 
1) {
16 I* Error: if n == 11 .. 1100 ... 00, then "
1550,233,"23 
24 n I= (1 << p); II Flip rightmost non-trailing zero 
25 n &= �((1 << p) - 1); JI Clear all bits to the right of p 
26 n I= (1 << (cl - 1)) - 1; II Insert (cl-1) ones on the right. 
282 Cracking the Coding Interview, 6th Edition"
1551,452,"Solutions to Chapter S I Bit Manipulation 
27 return n; 
28 } 
Bit Manipulation Approach for Get Previous Number 
To implement getPrev, we follow a very similar approach. 
1. Compute c0 and cl. Note that cl is the number of trailing ones, and c0 is the size of the block of zeros
immediately to the l"
1552,489,"3. Clear all bits to the right of bit p.
4. Insert cl + 1 ones immediately to the right of position p.
Note that Step 2 sets bit p to a zero and Step 3 sets bits 0 through p-1 to a zero. We can merge these steps. 
Let's walk through this with an example. 
Step 1: Initial Number. p = 7. cl = 2. c0 = "
1553,502,"We can do this as follows: 
int a= -0; II Sequence of ls 
int b =a<< (p + 1); 
n &- b; 
II Sequence of ls followed by p + 1 zeros. 
// Clears bits 0 through p. 
Steps 4: Insert c 1 + 1 ones immediately to the right of position p. 
Note that since p cl + c0,the(cl + l)ones willbefollowedby(c0 - l)zer"
1554,214,"n I= c; 
The code to implement this is below. 
1 int getPrev(int n) { 
2 int temp= n; 
3 int c0 = 0; 
4 int Cl= 0; 
s while (temp & 1 1) {6 Cl++; 
7 temp>>= 1; 
8 1 
CrackingTheCodinglnterview.com I 6th Edition 283"
1555,432,"Solutions to Chapter 5 I Bit Manipulation 
10 if (temp == 0) return -1; 
11 
12 while (((temp & 1) == 0) && (temp!= 0)) { 
13 c0++; 
14 temp>>= 1; 
15 } 
16 
17 int p = c0 + cl; // position of rightmost non-trailing one 
18 n &= ((-0) << (p + 1)); // clears from bit p onwards 
19 
20 int mask= (1 <<"
1556,464,"22 
23 return n; 
24 } 
Arithmetic Approach to Get Next Number 
If c0 is the number of trailing zeros, cl is the size of the one block immediately following, and p c0 + 
cl, we can word our solution from earlier as follows: 
1. Set the pth bit to 1.
2. Set all bits following p to 0.
3. Set bits 0 th"
1557,471,"then add 1. Adding one will flip all trailing ones, so we wind up with a 1 at bit p followed by p zeros. We can 
perform this arithmetically. 
n += 2 ce - 1 j 
n += 1; 
II Sets trailing 0s to 1, giving us p trailing ls 
// Flips first p ls to 0s, and puts a 1 at bit p. 
Now, to perform Step 3 arithm"
1558,502,"= n + 2c• + 2c1 - 1 - 1 
The best part is that, using a little bit manipulation, it's simple to code. 
1 int getNextArith(int n) { 
2 /* ... same calculation for c0 and cl as before */ 
3 return n + (1 << c0) + (1 << (cl - 1)) - 1; 
4 } 
Arithmetic Approach to Get Previous Number 
If c1 is the numbe"
1559,276,"1. Set the pth bit to 0
2. Set all bits following p to 1
3. Set bits O through c0 - 1 to 0.
We can implement this arithmetically as follows. For clarity in the example, we will assume n 10000011. 
This makes c 1 = 2 and c 0 = 5. 
284 Cracking the Coding Interview, 6th Edition"
1560,498,"Solutions to Chapter 5 I Bit Manipulation 
n -= 2 c1 - lj
n -= 
1; 
n -= 2c 0 - 1 - 1; 
// Removes trailing ls. n is now 10000000. 
// Flips trailing 0s. n is now 01111111. 
// Flips last (c0-1) 0s. n is now 01110000. 
This reduces mathematically to: 
next = n - (2<1 - 1) - 1 - ( 2'0 - 1 - 1) .
= n "
1561,480,"3 return n - (1 << cl) - (1 << (c0 
- 1)) + 1; 
4 } 
Whew! Don't worry, you wouldn't be expected to get all this in an interview-at least not without a lot of 
help from the interviewer. 
5.5 Debugger: Explain what the following code does: ((n & (n-1 )) == 0). 
SOLUTION 
We can work backwards to sol"
1562,433,"share a 1. 
What does n-1 look like (as compared with n}? 
Try doing subtraction by hand (in base 2 or 10). What happens? 
1101011000 [base 2] 
1 
1101010111 [base 2] 
593100 [base 10] 
1 
593099 [base 10] 
When you subtract 1 from a number, you look at the least significant bit. If it's a 1 you cha"
1563,409,"each bit from a Ot o a 1, until you find a 1. You flip that 1 to a O and you are done. 
Thus, n-1 will look like n, except that n's initial Os will be 1 s in n -1, and n's least significant 1 will be a O in 
n -1. That is: 
if n abcdel000 
then n-1 abcde0111 
So what does n & (n-1} === 0 indicate? 
"
1564,203,"if n = abcde1000 
then n-1 = abcde0111 
abcde must be all 0s, which means that n must look like this: 00001000. The value n is therefore a power 
of two. 
CrackingTheCodinglnterview.com I 6th Edition 285"
1565,445,"Solutions to Chapter 5 l Bit Manipulation 
So, we have our answer: ( ( n & ( n -1)) == 0) checks if n is a power of 2 (or if n is 0). 
5.6 Conversion: Write a function to determine the number of bits you would need to flip to convert 
integer A to integer B. 
EXAMPLE 
Input: 
Output: 
SOLUTION 
29 ("
1566,433,"would figure out which bits in two numbers are different. Simple: with an XOR. 
Each 1 in the XOR represents a bit that is different between A and B. Therefore, to check the number of bits 
that are different between A and B, we simply need to count the number of bits in AAB that are 1. 
1 int bitSw"
1567,509,"4 count+= c & 1; 
5 } 
6 return count; 
7 } 
This code is good, but we can make it a bit better. Rather than simply shifting c repeatedly while checking 
the least significant bit, we can continuously flip the least significant bit and count how long it takes c to 
reach 0. The operation c = c & ( c"
1568,426,"3 for (int c = a Ab; c != 0; c = c & (c-1)) { 
4 count++; 
5 } 
6 return count; 
7 } 
The above code is one of those bit manipulation problems that comes up sometimes in interviews. Though 
it'd be hard to come up with it on the spot if you've never seen it before, it is useful to remember the trick"
1569,451,"possible (e.g., bit O and bit 1 are swapped, bit 2 and bit 3 are swapped, and so on). 
pg 716 
SOLUTION 
Like many of the previous problems, it's useful to think about this problem in a different way. Operating on 
individual pairs of bits would be difficult, and probably not that efficient either. "
1570,152,"and move the odd bits over by 1? Sure. We can mask all odd bits with 10101010 in binary (which is 0xAA), 
286 Cracking the Coding Interview, 6th Edition"
1571,488,"Solutions to Chapter 5 I Bit Manipulation 
then shift them right by 1 to put them in the even spots. For the even bits, we do an equivalent operation. 
Finally, we merge these two values. 
This takes a total of five instructions. The code below implements this approach. 
1 int swapOddEvenBits(int x)"
1572,421,"bit to be filled with a zero. 
We've implemented the code above for 32-bit integers in Java. If you were working with 64-bit integers, you 
would need to change the mask. The logic, however, would remain the same. 
5.8 Draw Line: A monochrome screen is stored as a single array of bytes, allowing eig"
1573,508,"be split across rows). The height of the screen, of course, can be derived from the length of the array 
and the width. Implement a function that draws a horizontal line from (xl, y) to (x2, y). 
The method signature should look something like: 
drawLine(byte[] screen, int width, int xl, int x2, int"
1574,489,"A better solution is to recognize that if xl and x2 are far away from each other, several full bytes will be 
contained between them. These full bytes can be set one at a time by doing screen[byte_pos] 
0xFF. The residual start and end of the line can be set using masks. 
1 void drawLine(byte[] sc r"
1575,480,"5 first_full_byte++; 
6 } 
7 
8 int end_offset = x2 % 8; 
9 int last_full_byte = x2 / 8; 
10 if (end_offset != 7) { 
11 last_full_byte--; 
12 } 
13 
14 // Set full bytes 
15 for (int b = first_full_byte; b <= last_full_byte; b++) { 
16 screen[(width / 8) * y + b] = (byte) 0xFF; 
17 } 
18 
19 // Crea"
1576,151,"22 
23 // Set start and end of line 
24 if ((xl / 8) == (x2 / 8)) { // xl and x2 are in the same byte 
CrackingTheCodinglnterview.com I 6th Edition 287"
1577,422,"Solutions to Chapter 5 I Bit Manipulation 
25 byte mask= (byte) (start_mask & end_mask); 
26 screen[(width / 8) * y + (xl / 8)] I= mask; 
27 } else { 
28 if (start_offset != 0) { 
29 int byte_number =(width/ 8) * y + first_full_byte - 1; 
30 screen[byte_number] I= start_mask; 
31 } 
32 if (end_offse"
1578,327,"34 screen[byte_number] I= end_mask; 
35 } 
36 } 
37 } 
Be careful on this problem; there are a lot of""gotchas"" and special cases. For example, you need to consider 
the case where xl and x2 are in the same byte. Only the most careful candidates can implement this code 
bug-free. 
288 Cracking the Co"
1579,421,"6 
Solutions to Math and Logic Puzzles 
6.1 The Heavy Pill: You have 20 bottles of pills. 19 bottles have 1.0 gram pills, but one has pills of weight 
1.1 grams. Given a scale that provides an exact measurement, how would you find the heavy bottle? 
You can only use the scale once. 
pg 122 
SOLUTION"
1580,486,"scale once. 
Because we can only use the scale once, we know something interesting: we must weigh multiple pills 
at the same time. In fact, we know we must weigh pills from at least 19 bottles at the same time. Other­
wise, if we skipped two or more bottles entirely, how could we distinguish betwee"
1581,481,"suppose there were just two bottles, one of which had heavier pills. If we took one pill from each bottle, we 
would get a weight of 2.1 grams, but we wouldn't know which bottle contributed the extra 0.1 grams. We 
know we must treat the bottles differently somehow. 
If we took one pill from Bottle "
1582,405,"3.2 grams. And that is the trick to this problem. 
We know the ""expected"" weight of a bunch of pills. The difference between the expected weight and the 
actual weight will indicate which bottle contributed the heavier pills, provided we select a different number 
of pills from each bottle. 
We can "
1583,430,"from Bottle #3, and so on. Weigh this mix of pills. If all pills were one gram each, the scale would read 210 
grams (1 + 2 + • • • + 20 = 20 * 21 / 2 = 210). Any ""overage"" must come from the extra 0.1 
gram pills. 
This formula will tell you the bottle number: 
weight- 210 grams 
0. lgrams
So, if t"
1584,496,"Solutions to Chapter 6 I Math and Logic Puzzles 
6.2 Basketball: You have a basketball hoop and someone says that you can play one of two games. 
Game 1: You get one shot to make the hoop. 
Game 2: You get three shots and you have to make two of three shots. 
If p is the probability of making a part"
1585,487,"winning each game. 
Probability of winning Game 1: 
The probability of winning Game 1 is p, by definition. 
Probability of winning Game 2: 
Lets ( k, n) be the probability of making exactly k shots out of n. The probability of winning Game 2 is the 
probability of making exactly two shots out of thr"
1586,444,"The probability of making exactly two shots is: 
P(making 1 and 2, and missing 3) 
+ P(making 1 and 3, and mis sing 2)
+ P(mis sing 1, and making 2 and 3)
p * p * (1 -p) + p * (1 -p) * p + (1 -p) * p * p 
3(1-p)p2 
Adding these together, we get: 
p3 + 3 ( 1 - p) p2 
p3 + 3p2 - 3p3 
3p2 - 2p3 
Which "
1587,406,"1 > 3p - 2p2 
2p2 - 3p + 1 > 0 
(2p -l)(p - 1) > 0 
Both terms must be positive, or both must be negative. But we know p < 1, so p - 1 < 0. This means 
both terms must be negative. 
2p - 1 < 0 
2p < 1 
p < • 5 
So, we should play Game 1 if0 < p < • 5 and Game 2 if. 5 < p < 1. 
lfp = 0,0.5,�r1,thenP("
1588,491,"Solutions to Chapter 6 ! Math and Logic Puzzles 
6.3 Dominos: There is an 8x8 chessboard in which two diagonally opposite corners have been cut off. 
You are given 31 dominos, and a single domino can cover exactly two squares. Can you use the 31 
dominos to cover the entire board? Prove your answer "
1589,423,"off, so we're down to 62 squares. A set of 31 dominoes should be able to fit there, right? 
When we try to lay down dominoes on row 1, which only has 7 squares, we may notice that one domino 
must stretch into the row 2. Then, when we try to lay down dominoes onto row 2, again we need to stretch 
a "
1590,430,"many times and ways we try to solve this issue, we won't be able to successfully lay down all the dominoes. 
There's a cleaner, more solid proof for why it won't work. The chessboard initially has 32 black and 32 white 
squares. By removing opposite corners (which must be the same color), we're left"
1591,481,"Each domino we set on the board will always take up one white and one black square. Therefore, 31 dominos 
will take up 31 white squares and 31 black squares exactly. On this board, however, we must have 30 black 
squares and 32 white squares. Hence, it is impossible. 
6.4 Ants on a Triangle: There "
1592,493,"that each ant randomly picks a direction, with either direction being equally likely to be chosen, and 
that they walk at the same speed. 
Similarly, find the probability of collision with n ants on an n-vertex polygon. 
pg 123
SOLUTION 
The ants will collide if any of them are moving towards each o"
1593,178,"ability and work backwards from there. 
Since each ant can move in two directions, and there are three ants, the probability is: 
CrackingTheCodinglnterview.com j 6th Edition 291"
1594,401,"Solutions to Chapter 6 I Math and Logic Puzzles 
P (clockwise)= (Y,)' 
P (counter clockwise)= (Y,)' 
P ( same direction)= (Y,)' + (Y,)' = Y.
The probability of collision is therefore the probability of the ants not moving in the same direction: 
P (collision)= 1-P (same direction)= 1-Y. = Y.
To gene"
1595,440,"a collision, but there are 2"" ways they can move in total. Therefore, in general, probability of collision is: 
P ( clockwise) = (X)"" 
P (counter) = (X)"" 
P (same direction)= 2 (X)"" = (X) n-i
P (collision)= 1- P (same direction)= 1- (X) n-i
6.5 Jugs of Water: You have a five-quart jug, a three-quart"
1596,436,"are oddly shaped, such that filling up exactly ""half"" of the jug would be impossible. 
pg 123 
SOLUTION 
If we just play with the jugs, we'll find that we can pour water back and forth between them as follows: 
5 0 Filled 5-quart jug. 
2 3 Filled 3-quart with 5-quart's contents. 
2 0 Dumped 3-quart."
1597,273,"5-quart.
4 Done! We have 4 quarts. 
This question, like many puzzle questions, has a math/computer science root. If the two jug sizes are rela­
tively prime, you can measure any value between one and the sum of the jug sizes. 
292 Cracking the Coding Interview, 6th Edition"
1598,443,"Solutions to Chapter 6 I Math and Logic Puzzles 
6.6 Blue-Eyed Island: A bunch of people are living on an island, when a visitor comes with a strange 
order: all blue-eyed people must leave the island as soon as possible. There will be a flight out at 
8:00pm every evening. Each person can see every"
1599,450,"blue eyes, although they do know that at least one person does. How many days will it take the 
blue-eyed people to leave? 
pg113 
SOLUTION 
Let's apply the Base Case and Build approach. Assume that there are n people on the island and c of them 
have blue eyes. We are explicitly told that c > 0. 
C"
1600,439,"else has blue eyes. Since he knows that at least one person has blue eyes, he must conclude that it is he who 
has blue eyes. Therefore, he would take the flight that evening. 
Case c = 2: Exactly two people have blue eyes. 
The two blue-eyed people see each other, but are unsure whether c is 1 or 2"
1601,493,"person is still there, he must deduce that c = 2, which means that he himself has blue eyes. Both men would 
then leave on the second night. 
Case c > 2: The General Case. 
As we increase c, we can see that this logic continues to apply. If c = 3, then those three people will imme­
diately know that"
1602,488,"person would conclude that c = 3 and that they, therefore, have blue eyes too. They would leave that night. 
This same pattern extends up through any value of c. Therefore, if c men have blue eyes, it will take c nights 
for the blue-eyed men to leave. All will leave on the same night. 
6.7 The Apoc"
1603,407,"else they face massive fines. If all families abide by this policy-that is, they have continue to have 
children until they have one girl, at which point they immediately stop-what will the gender ratio 
of the new generation be? (Assume that the odds of someone having a boy or a girl on any given 
"
1604,377,"pg 123 
SOLUTION 
If each family abides by this policy, then each family will have a sequence of zero or more boys followed by 
a single girl. That is, if ""G"" indicates a girl and ""B"" indicates a boy, the sequence of children will look like one 
of: G; BG; BBG; BBBG; BBBBG; and so on. 
We can solve "
1605,450,"Solutions to Chapter 6 I Math and Logic Puzzles 
Mathematically 
We can work out the probability for each gender sequence. 
P(G) = Yz. That is, 50% of families will have a girl first. The others will go on to have more children. 
P(BG) = X. Of those who have a second child (which is 50%), 50% of the"
1606,498,"And so on. 
We know that every family has exactly one girl. How many boys does each family have, on average? To 
compute this, we can look at the expected value of the number of boys. The expected value of the number 
of boys is the probability of each sequence multiplied by the number of boys in th"
1607,459,"�00 i 
L,i=OY 
You probably won't know this off the top of your head, but we can try to estimate it. Let's try converting the 
above values to a common denominator of 128 (26). 
1/ _ 32/ /4 - /128
2/ _ 32/ /8 - /128
3/ _ 24/ /16 - /128
32 + 32 + 24 + 16 + 10 + 6 
128 
4/ _ 16/ /32 - /128
s/ _ 10/ /6"
1608,489,"but it's not exactly a mathematical concept. It's a clue though and we can turn to logic here. Should it be 1? 
Logically 
If the earlier sum is 1, this would mean that the gender ratio is even. Families contribute exactly one girl and 
on average one boy. The birth policy is therefore ineffective. "
1609,422,"Solutions to ChaptQr 6 I Math and Logic Puzzles 
On the other hand, the families that keep having children contribute (potentially) multiple boys to the 
population. This could offset the impact of the ""one girl"" policy. 
One way to think about this is to imagine that we put all the gender sequence "
1610,468,"In fact, we don't really care about the groupings of families because we're concerned about the population 
as a whole. As soon as a child is born, we can just append its gender (B or G) to the string. 
What are the odds of the next character being a G? Well, if the odds of having a boy and girl is "
1611,491,"half should be Bs, giving an even gender ratio. 
This actually makes a lot of sense. Biology hasn't been changed. Half of newborn babies are girls and half are 
boys. Abiding by some rule about when to stop having children doesn't change this fact. 
Therefore, the gender ratio is 50% girls and 50% b"
1612,499,"3 int girls = 0; 
4 for (int i= 0; i < n; i++) { 
5 int[] genders = runOneFamily(); 
6 girls += genders[0); 
7 boys += genders[l]; 
8 } 
9 return girls I (double) (boys + girls); 
10 } 
11 
12 int[] runOneFamily() { 
13 Random random = new Random(); 
14 int boys = 0; 
15 int girls = 0; 
16 while (gi"
1613,205,"23 int[] genders = {girls, boys}; 
24 return genders; 
25 } 
Sure enough, if you run this on large values of n, you should get something very close to 0.5. 
CrackingTheCodinglnterview.com I 6th Edition 295"
1614,433,"Solutions to Chapter 6 I Math and Logic Puzzles 
6.8 The Egg Drop Problem: There is a building of 100 floors. If an egg drops from the Nth floor or 
above, it will break. If it's dropped from any floor below, it will not break. You're given two eggs. Find 
N, while minimizing the number of drops for"
1615,456,"highest) between the ""breaking floor"" and the next highest non-breaking floor. For example, if Egg 1 is 
dropped from floors 5 and 10 without breaking, but it breaks when it's dropped from floor 15, then Egg 2 
must be dropped, in the worst case, from floors 11, 12, 13, and 14. 
The Approach 
As a f"
1616,447,"If Egg 1 breaks on the last drop (floor 100), then we have at most 19 drops total (floors 10, 20, ... ,90, 100, 
then 91 through 99). 
That's pretty good, but all we've considered is the absolute worst case. We should do some ""load balancing"" 
to make those two cases more even. 
Our goal is to creat"
1617,475,"whether Egg 1 breaks on the first drop or the last drop. 
1. A perfectly load-balanced system would be one in which Drops ( Egg 1) + Drops ( Egg 2) is always
the same, regardless of where Egg 1 breaks.
2. For that to be the case, since each drop of Egg 1 takes one more step, Egg 2 is allowed one few"
1618,411,"Egg 2 is potentially required to take 9 steps. When we drop Egg 1 again, we must reduce potential Egg 2
steps to only 8. That is, we must drop Egg 1 at floor 39.
4. Therefore, Egg 1 must start at floor X, then go up by X-1 floors, then X- 2, ... , until it gets to 100.
5. Solve for X.
X+(X - l)+(X- "
1619,469,"If we round X up to 14, then we would go up by 14, then 13, then 12, and so on. The last increment would 
be 4, and it would happen on floor 99. If Egg 1 broke on any of the prior floors, we know we've balanced 
the eggs such that the number of drops of Egg 1 and Egg 2 always sum to the same thing: "
1620,407,"Either way, the number of drops is no more than 14. 
If we round X down to 13, then we would go up by 13, then 12, then 11, and so on. The last increment 
will be 1 and it will happen at floor 91. This is after 13 drops. Floors 92 through 100 have not been 
covered yet. We can't cover those floors i"
1621,487,"Solutions to Chapter 6 ! Math and Logic Puzzl�s 
""round up"" case). 
Therefore, we should round X up to 14. That is, we go to floor 14, then 27, then 39, .... This takes 14 steps in 
the worse case. 
As in many other maximizing/ minimizing problems, the key in this problem is ""worst case balancing:' "
1622,500,"5 countDrops++; 
6 return floor >= breakingPoint; 
7 } 
8 
9 int findBreakingPoint(int floors) { 
10 int interval= 14; 
11 int previousFloor = 0; 
12 int egg1 = interval; 
13 
14 /* Drop egg1 at decreasing intervals. */ 
15 while (!drop(egg1) && egg1 <= floors) { 
16 interval -= 1; 
17 previousFloor"
1623,472,"24 egg2 += 1; 
25 } 
26 
27 /* If it didn't break, return -1. */ 
28 return egg2 >floors? -1 : egg2; 
29 } 
If we want to generalize this code for more building sizes, then we can solve for x in: 
x(x+lx = number of floors
This will involve the quadratic formula. 
6.9 100 Lockers: There are 100 clos"
1624,474,"it is open or opens it if it is closed). This process continues for 100 passes, such that on each pass i, 
the man toggles every ith locker. After his 100th pass in the hallway, in which he toggles only locker 
#100, how many lockers are open? 
pg 124 
SOLUTION 
We can tackle this problem by thinkin"
1625,481,"Solutions to Chapter 6 I Math and Logic Puzzles 
Question: For which rounds is a door toggled (open or closed)? 
A door n is toggled once for each factor of n, including itself and 1. That is, door 15 is toggled on rounds 1, 
3, 5, and 15. 
Question: When would a door be left open? 
A door is left o"
1626,459,"Question: When would x be odd? 
The value x is odd if n is a perfect square. Here's why: pair n's factors by their complements. For example, 
if n is 36, the factors are (1, 36), (2, 18), (3, 12), (4, 9), (6, 6). Note that (6, 6) only contributes one factor, thus 
giving n an odd number of factors. "
1627,471,"realize that you can take the numbers 1 through 10 and square them: 
1 *1, 2*2, 3*3, ... , 10*10 
Therefore, there are 10 lockers open at the end of this process. 
6. 1 O Poison: You have 1000 bottles of soda, and exactly one is poisoned. You have 10 test strips which
can be used to detect poison. A"
1628,495,"as you'd like (as long as the results are negative). However, you can only run tests once per day and 
it takes seven days to return a result. How would you figure out the poisoned bottle in as few days 
as possible? 
Follow up: Write code to simulate your approach. 
pg 124
SOLUTION 
Observe the wor"
1629,428,"doing something else in the meantime (running additional tests). Let's hold on to that thought, but start off 
with a simple approach just to wrap our heads around the problem. 
Naive Approach (28 days) 
A simple approach is to divide the bottles across the 10 test strips, first in groups of 100. Th"
1630,486,"associated with the positive test strip, ""toss"" (i.e., ignore) all the other bottles, and repeat the process. We 
perform this operation until there is only one bottle left in the test set. 
1. Divide hottlP<; across available test strips, one drop per test strip.
2. After seven days, check the test"
1631,493,"Solutions to Chapter 6 I Math and Logic Puzzles 
we have located the poisoned bottle. If it's greater than one, go to step 1. 
To simulate this, we'll build classes for Bottle and TestStrip that mirror the problem's functionality. 
1 class Bottle { 
2 private boolean poisoned= false; 
3 private int "
1632,510,"8 public boolean isPoisoned() { return poisoned; } 
9 } 
10 
11 class TestStrip { 
12 public static int DAYS_FOR_RESULT = 7; 
13 private Arraylist<Arraylist<Bottle>> dropsByDay 
14 new ArrayList<ArrayList<Bottle>>(); 
15 private int id; 
16 
17 public TestStrip(int id) { this.id id;} 
18 public int "
1633,509,"23 dropsByDay.add(new ArrayList<Bottle>()); 
24 } 
25 } 
26 
27 /* Add drop from bottle on specific day. */ 
28 public void addDropOnDay(int day, Bottle bottle) { 
29 sizeDropsForDay(day); 
30 ArrayList<Bottle> drops = dropsByDay.get(day); 
31 drops.add(bottle); 
32 } 
33 
34 /* Checks if any of the"
1634,460,"38 return true; 
39 } 
40 } 
41 return false; 
42 } 
43 
44 /* Gets bottles used in the test DAYS_FOR_RESULT days ago. */ 
45 public Arraylist<Bottle> getlastWeeksBottles(int day) { 
46 if (day < DAYS_FOR_RESULT) { 
47 return null; 
48 } 
49 return dropsByDay.get(day - DAYS_FOR_RESULT); 
50 } 
51 
5"
1635,460,"Solutions to Chapter 6 Math and Logic Puzzles 
54 int testDay = day - DAYS_FOR_RESULT; 
55 if (testDay < 0 I I testDay >= dropsByDay.size()) { 
56 return false; 
57 } 
58 for (int d = 0; d <= testDay; d++) { 
59 Arraylist<Bottle> bottles = dropsByDay.get(d); 
60 if (hasPoison(bottles)) { 
61 return "
1636,469,"With this infrastructure built, we can now implement code to test our approach. 
1 int findPoisonedBottle(ArrayList<Bottle> bottles, ArrayList<TestStrip> strips) { 
2 int today= 0; 
3 
4 while (bottles.size() > 1 && strips.size() > 0) { 
5 /* Run tests. */ 
5 runTestSet(bottles, strips, today); 
7 
"
1637,479,"13 if (strip.isPositiveOnDay(today)) { 
14 bottles = strip.getLastWeeksBottles(today); 
15 strips.remove(strip); 
16 break; 
17 } 
18 } 
19 } 
20 
21 if (bottles.size()== 1) { 
22 return bottles.get(0).getid(); 
23 } 
24 return -1; 
25 } 
26 
27 /* Distribute bottles across test strips evenly. */ 
2"
1638,430,"31 TestStrip strip = strips.get(index); 
32 strip.addDropOnDay(day, bottle); 
33 index ; (index + 1) % strips.size(); 
34 } 
35 } 
36 
37 /* The complete code can be found in the downloadable code attachment. */ 
Note that this approach makes the assumption that there will always be multiple test st"
1639,403,"Solutions to Chapter 6 I Math and Logic Puzzles 
If we can't assume this, we can implement a fail-safe. If we have just one test strip remaining, we start doing 
one bottle at a time: test a bottle, wait a week, test another bottle. This approach will take at most 28 days. 
Optimized Approach (10 da"
1640,502,"If we divide the bottles up into 10 groups (with bottles O -99 going to strip 0, bottles 100 - 199 going to strip 
1, bottles 200 - 299 going to strip 2, and so on), then day 7 will reveal the first digit of the bottle number. A 
positive result on strip i at day 7 shows that the first digit (1 OO's"
1641,452,"on different days so that we don't confuse the results. 
Strip 0 Oxx xOx xxO 
Strip 1 lxx xlx xxl 
Strip 2 2xx x2x xx2 
Strip 3 3xx x3x xx3 
Strip 4 4xx x4x xx4 
Strip 5 Sxx xSx xxS 
Strip 6 6xx x6x xx6 
Strip 7 ?xx xlx xx? 
Strip 8 8xx x8x xx8 
Strip 9 9xx x9x xx9 
For example, if day 7 showed a po"
1642,509,"This mostly works, except for one edge case: what happens if the poisoned bottle has a duplicate digit? For 
example, bottle #882 or bottle #383. 
In fact, these cases are quite different. If day 8 doesn't have any""new"" positive results, then we can conclude 
that digit 2 equals digit 1. 
The bigger"
1643,480,"They will both have the same pattern of test results. 
We will need to run one additional test. We could run this at the end to clear up ambiguity, but we can also 
run it at day 3, just in case there's any ambiguity. All we need to do is shift the final digit so that it winds up 
in a different pla"
1644,100,"x2x xx2 xxl 
x3x xx3 xx2 
x4x xx4 xx3 
xSx xxS xx4 
CrackingTheCodinglnterview.com I 6th Edition 301"
1645,491,"Solutions to Chapter 6 I Math and Logic Puzzles 
Strip 6 6xx x6x xx6 xxs 
Strip 7 7xx x7x xx7 xx6 
Strip 8 8xx x8x xx8 xx7 
Strip 9 9xx x9x xx9 xx8 
Now, bottle #383 will see (Day 7 = #3, Day 8 -> #8, Day 9 -> [NONE], Day 10 -> #4), while bottle #388 will see 
(Day 7 = #3, Day 8 -> #8, Day 9 -> [NON"
1646,445,"Actually, yes. Bottle #898 would see (Day 7 = #8, Day 8 -> #9, Day 9 -> [NONE], Day 10 -> [NONE]). That's 
okay, though. We just need to distinguish bottle #898 from #899. Bottle #899 will see (Day 7 = #8, Day 8 -> 
#9, Day 9 -> [NONE], Day 10-> #0). 
The ""ambiguous"" bottles from day 9 will always m"
1647,489,"• Otherwise, we know that the third digit equals either the first digit or the second digit and that the third
digit, when shifted, still equals either the first digit or the second digit. Therefore, we just need to figure
out whether the first digit ""shifts"" into the second digit or the other way a"
1648,497,"Implementing this requires some careful work to prevent bugs. 
1 int findPoison edBottle(ArrayLi st<Bottle> bottles, ArrayList<TestStrip> strips) 
{ 
2 if (bottles.size() > 1000 I I strips.size() < 10) return -1; 
3 
4 int tests = 4; II three digits, plus one extra 
5 int nTestStrips = strips.size()"
1649,468,"13 HashSet<Integer> previousResults = new HashSet<Integer>(); 
14 int[] digits = new int[tests]; 
15 for (int day= 0; day < tests; day++) { 
16 int resultDay =day+ TestStrip.DAYS_FOR_RESULT; 
17 digits[day] = getPositi veOnDay(strips, resultDay, previousResults); 
18 previousResults.add(digits[day])"
1650,196,"24 } 
25 
25 /* If day 2 matched day 0 
or day 1, check day 3. Day 3 is the same as day 2, but 
27 * in cremented by 1. */ 
28 if (digits[2] == -1) {
302 Cracking the Coding Interview, 6th Edition"
1651,481,"Solutions to Chapter 6 I Math and Logic Puzzles
29 if (digits[3] == -1) {/* Day 3 didn't give new result*/ 
30 /* Digit 2 equals digit 0 or digit 1. But, digit 2, when incremented also 
31 * matches digit 0 or digit 1. This means that digit 0 incremented matches
32 * digit 1, or the other way around"
1652,487,"37 } 
38 } 
39 
40 return digits[0] * 100 +digits[!]* 10 + digits[2]; 
41 } 
42 
43 /* Run set of tests for this day. */ 
44 void runTestSet(Arraylist<Bottle> bottles, ArrayList<TestStrip> strips, int day) { 
45 if (day > 3) return;// only works for 3 days (digits)+ one extra 
46 
47 for (Bottle bot"
1653,509,"50 testStrip.addDropOnDay(day, bottle); 
51 } 
52 } 
53 
54 /* Get strip that should be used on this bottle on this day. */ 
55 int getTestStripindexForDay(Bottle bottle, int day, int nTestStrips) { 
56 int id= bottle.getid(); 
57 switch (day) { 
58 case 0: return id /100; 
59 case 1: return (id% 10"
1654,423,"67 int getPositiveOnDay(ArrayList<TestStrip> testStrips, int day, 
68 HashSet<Integer> previousResults) { 
69 for (TestStrip testStrip : testStrips) { 
70 int id = testStrip.getid(); 
71 if (testStrip.isPositiveOnDay(day) && !previousResults.contains(id)) { 
72 return testStrip.getid(); 
73 } 
74 } "
1655,216,"Optimal Approach (7 days) 
We can actually optimize this slightly more, to return a result in just seven days. This is of course the 
minimum number of days possible. 
CrackingTheCodinglnterview.com I 6th Edition 303"
1656,420,"Solutions to Chapter 6 I Math and Logic Puzzles 
Notice what each test strip really means. It's a binary indicator for poisoned or unpoisoned. Is it possible to 
map 1000 keys to 10 binary values such that each key is mapped to a unique configuration of values? Yes, 
of course. This is what a binary"
1657,451,"we will add a drop of this bottle's contents to test strip i. Observe that 210 is 1024, so 10 test strips will be 
enough to handle up to 1024 bottles. 
We wait seven days, and then read the results. If test strip i is positive, then set bit i of the result value. 
Reading all the test strips will g"
1658,492,"2 runTests(bottles, strips); 
3 Arraylist<Integer> positive = getPositiveOnDay(strips, 7); 
4 return setBits(positive); 
5 } 
6 
7 /* Add bottle contents to test strips */ 
8 void runTests(Arraylist<Bottle> bottles, ArrayList<TestStrip> testStrips) { 
9 for (Bottle bottle : bottles) { 
10 int id= bo"
1659,447,"15 } 
16 bitindex++; 
17 id »= 1; 
18 } 
19 } 
20 } 
21 
22 /* Get test strips that are positive on a particular day. */ 
23 Arraylist<Integer> getPositiveOnDay(Arraylist<TestStrip> testStrips, int day) { 
24 Arraylist<Integer> positive = new Arraylist<Integer>(); 
25 for (TestStrip testStrip : test"
1660,434,"29 } 
30 } 
31 return positive; 
32 } 
33 
34 /* Create number by setting bits with indices specified in positive. */ 
35 int setBits(ArrayList<Integer> positive) { 
36 int id= 0; 
37 for (Integer bitindex : positive) { 
38 id I= 1 << bitindex; 
39 } 
40 return id; 
41 } 
This approach will work as "
1661,486,"7 
Solutions to Object-Oriented Design 
7.1 Deck of Cards: Design the data structures for a generic deck of cards. Explain how you would 
subclass the data structures to implement blackjack. 
pg127 
SOLUTION 
First, we need to recognize that a ""generic"" deck of cards can mean many things. Generic co"
1662,457,"Let's assume that your interviewer clarifies that the deck is a standard 52-card set, like you might see used 
in a blackjack or poker game. If so, the design might look like this: 
1 public enum Suit { 
2 Club (0), Diamond (1), Heart (2), Spade (3); 
3 private int value; 
4 private Suit(int v) {val"
1663,510,"7 } 
8 
9 public class Deck <T extends Card> { 
10 private ArrayList<T> cards;// all cards, dealt or not 
11 private int dealtlndex = 0; // marks first undealt card 
12 
13 public void setDeckOfCards(ArrayList<T> deckOfCards) { ... } 
14 
15 public void shuffle() { ... } 
16 public int remainingCard"
1664,268,"24 private boolean available = true; 
25 
26 /* number or face that's on card - a number 2 through 10, or 11 for Jack, 12 for 
27 * Queen, 13 for King, or 1 for Ace */
28 protected int faceValue;
29 protected Suit suit;
CrackingTheCodinglnterview.com I 6th Edition 305"
1665,487,"Solutions to Chapter 7 I Object-Oriented Design 
30 
31 public Card(int c, Suit s) { 
32 faceValue = c; 
33 suit = s; 
34 } 
35 
36 public abstract int value(); 
37 public Suit suit() { return suit;} 
38 
39 /* Checks if the card is available to be given out to someone */ 
40 public boolean isAvaila"
1666,506,"43 } 
44 
45 public class Hand <T extends Card> { 
46 protected Arraylist<T> cards = new Arraylist<T>(); 
47 
48 public int score() { 
49 int score = 0; 
50 for (T card : cards) { 
51 score += card.value(); 
52 } 
53 return score; 
54 } 
55 
56 public void addCard(T card) { 
57 cards.add(card); 
58 "
1667,510,"without a specific game attached to them. (You could make a compelling argument that they should be 
implemented anyway, by defaulting to standard poker rules.) 
Now, let's say we're building a blackjack game, so we need to know the value of the cards. Face cards are 10 
and an ace is 11 (most of th"
1668,503,"3 * multiple values. Return the highest possible score that's under 21, or the
4 * lowest score that's over. */
5 public int score() {
6 Arraylist<Integer> scores = possibleScores(); 
7 int maxUnder = Integer.MIN_VALUE; 
8 int minOver = Integer.MAX_VALUE; 
9 for (int score : scores) { 
10 if (score "
1669,108,"18 
return maxUnder Integer.MIN_VALUE ? minOver maxUnder; 
} 
306 Cracking the Coding Interview, 6th Edition"
1670,507,"Solutions to Chapter 7 I Object-Oriented Design 
19 
20 
21 
22 
/* return a list of all possi ble scores this hand could have (evaluating each 
* ace as both 1 and 11 */
23 
24 
25 
26 } 
27 
private Arraylis t<Integer> possibleScores() { ... }
public boolean bust ed() { return score()> 21; } 
publ"
1671,487,"30 public int value() { 
31 if (isAce()) return 1; 
32 else if (faceValue >= 11 && faceValue <= 13) return 10; 
33 else return faceValue; 
34 } 
35 
36 public int minValue() { 
37 if (isAce()) return 1; 
38 else return value(); 
39 } 
40 
41 public int maxValue() { 
42 if (isAce()) return 11; 
43 el"
1672,484,"51 return faceValue >= 11 && faceValue <= 13; 
52 } 
53 } 
This is just one way of handling aces. We could, alternatively, create a class of type Ace that extends 
BlackJackCard. 
An executable, fully automated version of blackjack is provided in the downloadable code attachment. 
7.2 Call Center: I"
1673,460,"respondent can't handle the call, he or she must escalate the call to a manager. If the manager is not 
free or not able to handle it, then the call should be escalated to a director. Design the classes and 
data structures for this problem. Implement a method dispatchCall () which assigns a call to"
1674,108,"We should keep these things within their respective class. 
CrackingTheCodinglnterview.com / 6th Edition 307"
1675,425,"Solutions to Chapter 7 I Object-Oriented Design 
There are a few things which are common to them, like address, name, job title, and age. These things can 
be kept in one class and can be extended or inherited by others. 
Finally, there should be one CallHandler class which would route the calls to "
1676,477,"trade-offs of different solutions with your interviewer. You should usually design for long-term code flex­
ibility and maintenance. 
We'll go through each of the classes below in detail. 
CallHandler represents the body of the program, and all calls are funneled first through it. 
1 public class Ca"
1677,495,"6 private final int NUM_RESPONDENTS = 10; 
7 private final int NUM_MANAGERS = 4; 
8 private final int NUM_DIRECTORS = 2; 
9 
10 /* List of employees, by level. 
11 * employeeLevels[0] respondents 
12 * employeeLevels[l] managers 
13 * employeeLevels[2] directors 
14 */ 
15 List<List<Employee>> emplo"
1678,480,"23 public Employee getHandlerForCall(Call call) { ... } 
24 
25 /* Routes the call to an available employee, or saves in a queue if no employee 
26 * is available. */
27 public void dispatchCall(Caller caller) { 
28 Call call= new Call(caller); 
29 dispatchCall(call); 
30 } 
31 
32 
33 
34 
35 
36 
"
1679,467,"* is available. */
public void dispatchCall(Call call) {
} 
/* Try to route the call to an employee with minimal rank. */ 
Employee emp = getHandlerForCall(call); 
if (emp != null) { 
emp.receiveCall(call); 
call.setHandler(emp); 
} else { 
/* Place the call into corresponding call queue according t"
1680,507,"Solutions to Chapter 7 I Object-Oriented Design 
46 
47 /* An employee got free. Look for a waiting call that employee can serve. Return 
48 * true if we assigned a call, false otherwise. */
49 public boolean assignCall(Employee emp) { ... }
50 } 
Call represents a call from a user. A call has a min"
1681,491,"3 private Rank rank; 
4 
5 /* Person who is calling. */ 
6 private Caller caller; 
7 
8 /* Employee who is handling call. */ 
9 private Employee handler; 
10 
11 public Call(Caller c) { 
12 rank = Rank.Responder; 
13 caller = c; 
14 } 
15 
16 /* Set employee who is handling call. */ 
17 public void "
1682,479,"public void setRank(Rank r) {rank = r; } 
public Rank incrementRank() { ... } 
public void disconnect() { . . . } 
Employee is a super class for the Director, Manager, and Respondent classes. It is implemented as an 
abstract class since there should be no reason to instantiate an Employee type dire"
1683,496,"6 
7 /* Start the conversation*/ 
8 public void receiveCall(Call call) { ... } 
9 
10 /* the issue is resolved, finish the call*/ 
11 public void callCompleted() { ... } 
12 
13 /* The issue has not been resolved. Escalate the call, and assign a new call to 
14 * the employee. */
15 public void esca"
1684,171,"19 
20 /* Returns whether or not the employee is free. */ 
21 public boolean isFree() { return currentCall == null; } 
22 
CrackingTheCodinglnterview.com j 6th Edition 309"
1685,501,"Solutions to Chapter 7 I Object-Oriented Design 
23 public Rank getRank() { return rank;} 
24 } 
25 
The Respondent, Director, and Manager classes are now just simple extensions of the Employee 
class. 
1 class Director extends Employee { 
2 public Director() { 
3 rank= Rank.Director; 
4 } 
5 } 
6 
"
1686,485,"15 rank = Rank.Responder; 
16 } 
17 } 
This is just one way of designing this problem. Note that there are many other ways that are equally good. 
This may seem like an awful lot of code to write in an interview, and it is. We've been much more thorough 
here than you would need. In a real interview"
1687,499,"SOLUTION 
pg/27
In any object-oriented design question, you first want to start off with asking your interviewer some 
questions to clarify design constraints. Is this jukebox playing CDs? Records? MP3s? Is it a simulation on a 
computer, or is it supposed to represent a physical jukebox? Does it ta"
1688,430,"some assumptions. We'll assume that the jukebox is a computer simulation that closely mirrors physical 
jukeboxes, and we'll assume that it's free. 
Now that we have that out of the way, we'll outline the basic system components: 
• Jukebox
CD
• Song
• Artist
Playlist
Display (displays details on th"
1689,504,"Solutions to Chapter 7 I Object-Oriented Design 
• Playlist creation (includes add, delete, and shuffle)
• CD selector
Song selector
Queuing up a song
Get next song from playlist
A user also can be introduced: 
• Adding
• Deleting
• Credit information
Each of the main system components translates ro"
1690,440,"of the system, or between the system and the user, are channeled through here. 
1 public class Jukebox { 
2 private CDPlayer cdPlayer; 
3 private User user; 
4 private Set<CD> cdCollection; 
5 private SongSelector ts; 
6 
7 public Jukebox(CDPlayer cdPlayer, User user, Set<CD> cdCollection, 
8 SongSe"
1691,488,"11 public void setUser(User u) { this. user = u; } 
12 } 
Like a real CD player, the CDP layer class supports storing just one CD at a time. The CDs that are not in 
play are stored in the jukebox. 
1 public class CDPlayer { 
2 private Playlist p; 
3 private CD c; 
4 
5 /*Constructors.*/ 
6 public C"
1692,490,"10 /* Play song*/ 
11 public void playSong(Song s) { ... } 
12 
13 /* Getters and setters*/ 
14 public Playlist getPlaylist() { return p;} 
15 public void setPlaylist(Playlist p) { this.p p; } 
16 
17 public CD getCD() { return c; } 
18 public void setCD(CD c) { this.c = c; } 
19 } 
The Play list ma"
1693,510,"Solutions to Chapter 7 I Object-Oriented Design· 
1 public class Playlist { 
2 private Song song; 
3 private Queue<Song> queue; 
4 public Playlist(Song song, Queue<Song> queue) { 
5 
6 } 
7 public Song getNextSToPlay() { 
8 return queue.peek(); 
9 } 
10 public void queueUpSong(Song s) { 
11 queue.ad"
1694,480,"1 public class CD {/* data for id, artist, songs, etc */} 
2 
3 public class Song {/* data for id, CD (could be null), title, length, etc */} 
4 
5 public class User { 
6 private String name; 
7 public String getName() { return name; } 
8 public void setName(String name) { this.name name; } 
9 publi"
1695,490,"13 public User getUser() { return this;} 
14 public static User addUser(String name, long iD) { ... } 
15 } 
This is by no means the only ""correct"" implementation. The interviewer's responses to initial questions, as 
well as other constraints, will shape the design of the jukebox classes. 
7.4 Park"
1696,499,"a conversation with your interviewer about what types of vehicles it can support, whether the parking lot 
has multiple levels, and so on. 
For our purposes right now, we'll make the following assumptions. We made these specific assumptions to 
add a bit of complexity to the problem without adding t"
1697,279,"The parking lot can park motorcycles, cars, and buses.
• The parking lot has motorcycle spots, compact spots, and large spots.
A motorcycle can park in any spot.
A car can park in either a single compact spot or a single large spot.
312 Cracking the Coding Interview, 6th Edition"
1698,506,"Solutions to Chapter 7 I Object-Oriented Design 
A bus can park in five large spots that are consecutive and within the same row. It cannot park in small 
spots. 
In the below implementation, we have created an abstract class Vehicle, from which Car, Bus, and 
Motorcycle inherit. To handle the diffe"
1699,478,"2 
3 public abstract class Vehicle { 
Large } 
4 protected ArrayList<ParkingSpot> parkingSpots new ArrayList<ParkingSpot>(); 
5 protected String licensePlate; 
6 protected int spotsNeeded; 
7 protected VehicleSize size; 
8 
9 public int getSpotsNeeded() { return spotsNeeded; } 
10 public VehicleSize"
1700,456,"14 
15 
16 
17 
/* Remove car from spot, and notify spot that it's gone */ 
public void clearSpots() { ... } 
18 
19 
20 
21 } 
22 
/* Checks if the spot is big enough for the vehicle (and is available). This 
* compares the SIZE only. It does not check if it has enough spots. */
public abstract boo"
1701,485,"25 spotsNeeded = 5; 
26 size = VehicleSize.Large; 
27 
28 
} 
29 /* Checks if the spot is a Large. Doesn't check num of spots */ 
30 
31 } 
32 
public boolean canFitinSpot(ParkingSpot spot) { } 
33 public class Car extends Vehicle { 
34 public Car() { 
35 spotsNeeded = 1; 
36 size = VehicleSize.Comp"
1702,250,"43 public class Motorcycle extends Vehicle { 
44 public Motorcycle() { 
45 spotsNeeded = 1; 
46 size = VehicleSize.Motorcycle; 
47 } 
48 
49 public boolean canFitinSpot(ParkingSpot spot) { ... } 
50 } 
CrackingTheCodinglnterview.com I 6th Edition 313"
1703,479,"Solutions to Chapter 7 I Object-Oriented Design 
The Parking Lot class is essentially a wrapper class for an array of Levels. By implementing it this way, 
we are able to separate out logic that deals with actually finding free spots and parking cars out from the 
broader actions of the ParkingLot. "
1704,499,"just separate ParkingLot from Level. 
1 public class ParkingLot { 
2 private Level[] levels; 
3 private final int NUM_LEVELS 5; 
4 
5 public ParkingLot() { ... } 
6 
7 /* Park the vehicle in a spot (or multiple spots). Return false if failed. */ 
8 public boolean parkVehicle(Vehicle vehicle) { ... }"
1705,462,"15 private int availableSpots = 0; // number of free spots 
16 private static final int SPOTS_PER_ROW 10; 
17 
18 public Level(int flr, int numberSpots) { ... } 
19 
20 public int availableSpots() { return availableSpots; } 
21 
22 /* Find a place to park this vehicle. Return false if failed. */ 
23"
1706,473,"26 * vehicle.spotsNeeded. */
27 private boolean parkStartingAtSpot(int num, Vehicle v) { ... }
28 
29 /* Find a spot to park this vehicle. Return index of spot, or -1 on failure. */ 
30 private int findAvailableSpots(Vehicle vehicle) { ... } 
31 
32 /* When a car was removed from the spot, increment"
1707,471,"could have implemented this by having classes for LargeSpot, CompactSpot, and MotorcycleSpot 
which inherit from ParkingSpot, but this is probably overkill. The spots probably do not have different 
behaviors, other than their sizes. 
1 public class ParkingSpot { 
2 private Vehicle vehicle; 
3 priva"
1708,116,"9 
10 public boolean isAvailable() { return vehicle == null; } 
11 
•·314 Cracking the Coding Interview, 6th Edition"
1709,481,"Solutions to Chapter 7 I Object-Oriented Design 
12 /* Check if the spot is big enough and is available */ 
13 public boolean canFitVehicle(Vehicle vehicle) { ... } 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 } 
/* Park vehicle in this spot. */ 
public boolean park(Vehicle v) { 
public int getRow() { re"
1710,507,"public void removeVehicle() { ... } 
A full implementation of this code, including executable test code, is provided in the downloadable code 
attachment. 
7.5 Online Book Reader: Design the data structures for an online book reader system. 
SOLUTION 
pg127 
Since the problem doesn't describe much a"
1711,496,"• Searching the database of books.
Reading a book.
Only one active user at a time
• Only one active book by this user.
To implement these operations we may require many other functions, like get, set, update, and so on. 
The objects required would likely include User, Book, and Library. 
The class O"
1712,466,"that would make this class rather hefty. Instead, we've chosen to tear off these components into Library, 
UserManager, and Display classes. 
1 public class OnlineReaderSystem { 
2 private Library library; 
3 private UserManager userManager; 
4 private Display display; 
5 
6 private Book activeBook;"
1713,201,"12 display= new Display(); 
13 } 
14 
15 public Library getLibrary() { return library; } 
16 public UserManager getUserManager() { return userManager;} 
CrackingTheCodinglnterview.com I 6th Edition 315"
1714,429,"Solutions to Chapter 7 I Object-Oriented Design 
17 public Display getDisplay() { return display; } 
18 
19 public Book getActiveBook() { return activeBook; } 
20 public void setActiveBook(Book book) { 
21 activeBook = book; 
22 display.displayBook(book); 
23 } 
24 
25 public User getActiveUser() { "
1715,505,"28 display.displayuser(user); 
29 } 
30 } 
We then implement separate classes to handle the user manager, the library, and the display components. 
1 public class Library { 
2 private HashMap<Integer, Book> books; 
3 
4 public Book addBook(int id, String details) { 
5 if (books.containsKey(id)) { 
6"
1716,508,"14 public boolean remove(int id) { 
15 if (!books.containsKey(id)) { 
16 return false; 
17 } 
18 books.remove(id); 
19 return true; 
20 } 
21 
22 public Book find(int id) { 
23 return books.get(id); 
24 } 
25 } 
26 
27 public class UserManager { 
28 private HashMap<Integer, User> users; 
29 
30 publ"
1717,252,"35 users.put(id, user); 
36 return user; 
37 } 
38 
39 public User find(int id) { return users.get(id); } 
40 public boolean remove(User u) { return remove(u.getID());} 
41 public boolean remove(int id) { 
316 Cracking the Coding Interview, 6th Edition"
1718,508,"Solutions to Chapter 7 I Object-Oriented Design 
42 if (!users.containsKey(id)) { 
43 return false; 
44 } 
45 users.remove(id); 
46 return true; 
47 } 
48 } 
49 
50 public class Display { 
51 private Book activeBook; 
52 private User activeuser; 
53 private int pageNumber = 0; 
54 
55 public void di"
1719,509,"63 
64 refreshTitle(); 
65 refreshDetails(); 
66 refreshPage(); 
67 } 
68 
69 public void turnPageForward() { 
70 pageNumber++; 
71 refreshPage(); 
72 } 
73 
74 public void turnPageBackward() { 
75 pageNumber--; 
76 refreshPage(); 
77 
78 
79 
80 
81 
82 
83 } 
} 
public 
public 
public 
public 
voi"
1720,474,"refreshPage() {/* updated page display*/} 
The classes for User and Book simply hold data and provide little true functionality. 
1 public class Book { 
2 private int bookid; 
3 private String details; 
4 
5 public Book(int id, String det) { 
6 bookid = id; 
7 details = det; 
8 } 
9 
10 public int g"
1721,101,"13 public void setDetails(String d) {details = d; } 
CrackingTheCodinglnterview.com \ 6th Edition 317"
1722,508,"Solutions to Chapter 7 I Object-Oriented Design 
14 } 
15 
16 public class User { 
17 private int userid; 
18 private String details; 
19 private int accountType; 
20 
21 public void renewMembership() { } 
22 
23 public User(int id, String details, int accountType) { 
24 userid = id; 
25 this.detail"
1723,478,"32 public String getDetails() { 
33 return details; 
34 } 
35 
36 public void setDetails(String details) { 
37 this.details = details; 
38 } 
39 public int getAccountType() { return accountType; } 
40 public void setAccountType(int t) { accountType = t; } 
41 } 
The decision to tear off user managem"
1724,508,"making this decision could make the system overly complex. However, as the system grows, and more and 
more functionality gets added to OnlineReaderSystem, breaking off such components prevents this 
main class from getting overwhelmingly lengthy. 
7.6 Jigsaw: Implement an NxN jigsaw puzzle. Design "
1725,390,"pg 728 
SOLUTION 
We have a traditional jigsaw puzzle. The puzzle is grid-like, with rows and columns. Each piece is located in 
a single row and column and has four edges. Each edge comes in one of three types: inner, outer, and flat. 
A corner piece, for example, will have two flat edges and two o"
1726,454,"Solutions to Chapter 7 I Object-Oriented Design 
As we solve the jigsaw puzzle (manually or algorithmically), we'll need to store the position of each piece. 
We could think about the position as absolute or relative: 
Absolute Position: ""This piece is located at position (12, 23):' 
Relative Positi"
1727,488,"piece:' 
For our solution, we will use the absolute position. 
We'll need classes to represent Puzzle, Piece, and Edge. Additionally, we'll want enums for the different 
shapes (inner, outer, flat) and the orientations of the edges (left, top, right, bottom). 
Puzzle will start off with a list of th"
1728,503,"rotate the piece at some point, so the hash table could change. The orientation of the edges will be arbi­
trarily assigned at first. 
Edge will have just its shape and a pointer back to its parent piece. It will not keep its orientation. 
A potential object-oriented design looks like the following:"
1729,399,"6 case LEFT: return RIGHT; 
7 case RIGHT: return LEFT; 
8 case TOP: return BOTTOM; 
9 case BOTTOM: return TOP; 
10 default: return null; 
11 } 
12 } 
13 } 
14 
15 public enum Shape { 
16 INNER, OUTER, FLAT; 
17 
18 public Shape getOpposite() { 
19 switch (this) { 
20 case INNER: return OUTER; 
21 ca"
1730,505,"Solutions to Chapter 7 I Object-Oriented Design 
23 } 
24 } 
25 } 
26 
27 public class Puzzle { 
28 private Linkedlist<Piece> pieces; /* Remaining pieces to put away. */ 
29 private Piece[][] solution; 
30 private int size; 
31 
32 public Puzzle(int size, Linkedlist<Piece> pieces) { ... } 
33 
34 
3"
1731,469,"37 int column, Orientation orientation) { 
38 Piece piece = edge.getParentPiece(); 
39 piece.setEdgeAsOrientation(edge, orientation); 
40 pieces.remove(piece); 
41 solution[row][column] = piece; 
42 } 
43 
44 /* Find the matching piece in piecesToSearch and insert it at row, column. */ 
45 private b"
1732,469,"49 } 
50 
51 public class Piece { 
52 private HashMap<Orientation, Edge> edges new HashMap<Orientation, Edge>(); 
53 
54 public Piece(Edge[J edgelist) { ... } 
55 
56 /* Rotate edges by ""numberRotations"". */ 
57 public void rotateEdgesBy(int numberRotations) { ... } 
58 
59 
60 
61 } 
62 
public boo"
1733,483,"66 public Edge(Shape shape) { ... } 
} 
} 
67 public boolean fitsWith(Edge edge) { ... } 
68 } 
Algorithm to Solve the Puzzle 
Just as a kid might in solving a puzzle, we'll start with grouping the pieces into corner pieces, border pieces, 
and inside pieces. 
Once we've done that, we'll pick an arb"
1734,174,"of pieces to find the matching piece. When we insert the piece into the puzzle, we need to rotate the piece 
to fit correctly. 
320 Cracking the Coding Interview, 6th Edition"
1735,475,"Solutions to Chapter 7 j Object-Oriented Design 
The code below outlines this algorithm. 
1 /* Find the matching piece within piecesToSearch and insert it at row, column. */ 
2 boolean fitNextEdge(LinkedList<Piece> piecesToSearch, int row, int column) { 
3 if (row == 0 && column == 0) {//On top left"
1736,502,"7 } else { 
8 /* Get the right edge and list to match. */ 
9 Piece pieceToMatch = column == 0? solution[row - 1][0] : 
10 solution[row][column - 1]; 
11 Orientation orientationToMatch column == 0? Orientation.BOTTOM 
12 Orientation.RIGHT; 
13 Edge edgeToMatch = pieceToMatch.getEdgeWithOrientation(or"
1737,492,"18 
19 /* Insert piece and edge. */ 
20 Orientation orientation = orientationToMatch.getOpposite(); 
21 setEdgeinSolution(piecesToSearch, edge, row, column, orientation); 
22 } 
23 return true; 
24 } 
25 
26 boolean solve() { 
27 /* Group pieces. */ 
28 Linkedlist<Piece> cornerPieces new Linkedlist<"
1738,508,"31 groupPieces(cornerPieces, borderPieces, insidePieces); 
32 
33 /* Walk through puzzle, finding the piece that joins the previous one. */ 
34 solution = new Piece[size][size]; 
35 for (int row = 0; row < size; row++) { 
36 for (int column = 0; column < size; column++) { 
37 Linkedlist<Piece> piece"
1739,194,"40 return false; 
41 } 
42 } 
43 } 
44 
45 return true; 
46 } 
The full code for this solution can be found in the downloadable code attachment. 
CrackingTheCodinglnterview.com J 6th Edition 321"
1740,486,"Solutions to Chapter 7 I Object-Oriented Design 
7 .7 Chat Server: Explain how you would design a chat server. In particular, provide details about the 
various backend components, classes, and methods. What would be the hardest problems to solve? 
pg 128 
SOLUTION 
Designing a chat server is a huge"
1741,472,"job, as a candidate, is to focus on an aspect of the problem that is reasonably broad, but focused enough 
that you could accomplish it during an interview. It need not match real life exactly, but it should be a fair 
representation of an actual implementation. 
For our purposes, we'll focus on the"
1742,489,"into the networking aspects of the problem, or how the data actually gets pushed out to the clients. 
We will assume that ""friending"" is mutual; I am only your contact if you are mine. Our chat system will 
support both group chat and one-on-one (private) chats. We will not worry about voice chat, v"
1743,443,"Signing online and offiine. 
Add requests (sending, accepting, and rejecting). 
Updating a status message. 
Creating private and group chats. 
Adding new messages to private and group chats. 
This is just a partial list. If you have more time, you can add more actions. 
What can we learn about these"
1744,458,"What are the core components of the system? 
The system would likely consist of a database, a set of clients, and a set of servers. We won't include these 
parts in our object-oriented design, but we can discuss the overall view of the system. 
The database will be used for more permanent storage, s"
1745,432,"For communication between the client and servers, using XML will work well. Although it's not the most 
compressed format (and you should point this out to your interviewer), it's nice because it's easy for both 
computers and humans to read. Using XML will make your debugging efforts easier-and tha"
1746,259,"from machine to machine. When possible, we will try to replicate some data across machines to minimize 
the lookups. One major design constraint here is to prevent having a single point of failure. For instance, 
322 Cracking the Coding Interview, 6th Edition"
1747,509,"Solutions to Chapter 7 I Object-Oriented Design 
if one machine controlled all the user sign-ins, then we'd cut off millions of users potentially if a single 
machine lost network connectivity. 
What are the key objects and methods? 
The key objects of the system will be a concept of users, conversa"
1748,473,"1 /* UserManager serves as a central place for core user actions. */ 
1 public class UserManager { 
2 private static UserManager instance; 
3 /* maps from a user id to a user */ 
4 private HashMap<Integer, User> usersByid; 
5 
6 /* maps from an account name to a user */ 
7 private HashMap<String, Us"
1749,445,"11 
12 public static UserManager getinstance() { 
13 if (instance == null) instance = new UserManager(); 
14 return instance; 
15 } 
16 
17 
18 
19 
20 
21 
22 } 
public void addUser(User fromUser, String toAccountName) { ... } 
public void approveAddRequest(AddRequest req) { ... } 
public void reje"
1750,503,"public void userSignedOff(String accountName) { ... } 
The method rec eivedAddRequest, in the User class, notifies User B that User A has requested 
to add him. User B approves or rejects the request (via UserManager. approveAddRequest or 
rejec tAddRequest), and the UserManager takes care of adding"
1751,500,"1. User A clicks ""add 
user"" on the client and it gets sent to the server.
2. User A calls reque stAddUser(User B ).
3. This method calls UserManager. addUser.
4. UserManager calls both User A. sen tAddRequest and
User B.rec eivedAddRequest.
Again, this is just one way of designing these interaction"
1752,198,"5 /* maps from the other participant's user id to the chat */ 
6 private HashMap<Integer, PrivateChat> privateChats; 
7 
8 /* list of group chats */ 
CrackingTheCodinglnterview.com I 6th Edition 323"
1753,483,"Solutions to Chapter 7 I Object-Oriented Design 
9 private ArrayList<GroupChat> groupChats; 
10 
11 /* maps from the other person's user id to the add request */ 
12 private HashMap<Integer, AddRequest> receivedAddRequests; 
13 
14 /* maps from the other person's user id to the add request */ 
15 pr"
1754,473,"19 
20 private String accountName; 
21 private String fullName; 
22 
23 public User(int id, String accountName, String fullName) { ... } 
24 public boolean sendMessageToUser(User to, String content){ ... } 
25 public boolean sendMessageToGroupChat(int id, String cnt){ ... } 
26 public void setStatus"
1755,474,"29 public void receivedAddRequest(AddRequest req) { ... } 
30 public void sentAddRequest(AddRequest req) { ... } 
31 public void removeAddRequest(AddRequest req) { ... } 
32 public void requestAddUser(String accountName) { ... } 
33 public void addConversation(PrivateChat conversation) { } 
34 publi"
1756,487,"37 public String getFullName() { ... } 
38 } 
The Conversation class is implemented as an abstract class, since all Conversations must be either a 
GroupChat or a Pri vateChat, and since these two classes each have their own functionality. 
1 public abstract class Conversation { 
2 protected Arrayli"
1757,498,"7 public boolean addMessage(Message m) { ... } 
8 public int getid() { ... } 
9 } 
10 
11 public class GroupChat extends Conversation { 
12 public void removeParticipant(User user) { ... } 
13 public void addParticipant(User user) { ... } 
14 } 
15 
16 public class PrivateChat extends Conversation {"
1758,151,"22 private String content; 
23 private Date date; 
24 public Message(String content, Date date) { ... } 
324 Cracking the Coding Interview, 6th Edition"
1759,484,"Solutions to Chapter 7 I Object-Oriented Design 
25 public String getContent() { ... } 
26 public Date getDate() { ... } 
27 } 
AddRequest and UserStatus are simple classes with little functionality. Their main purpose is to group 
data that other classes will act upon. 
1 public class AddRequest { "
1760,491,"13 
public AddRequest(User from, User to, Date date) { ... } 
public RequestStatus getStatus() { ... } 
public User getFromUser() { ... } 
public User getToUser() { ... } 
public Date getDate() { ... } 
14 public class UserStatus { 
15 private String message; 
16 private UserStatusType type; 
17 pub"
1761,464,"20 } 
21 
22 public enum UserStatusType { 
23 Offline, Away, Idle, Available, Busy 
24 } 
25 
26 public enum RequestStatus { 
27 Unread, Read, Accepted, Rejected 
28 } 
The downloadable code attachment provides a more detailed look at these methods, including implemen­
tations for the methods shown "
1762,479,"Q1: How do we know if someone is online-1 mean, really, really know? 
While we would like users to tell us when they sign off, we can't know for sure. A user's connection might 
have died, for example. To make sure that we know when a user has signed off, we might try regularly 
pinging the client t"
1763,93,"they get out of sync? Which one is ""right""? 
CrackingTheCodinglnterview.com \ 6th Edition 325"
1764,463,"Solutions to Chapter 7 I Object-Oriented Design 
Q3: How do we make our server scale? 
While we designed out chat server without worrying-too much- about scalability, in real life this would 
be a concern. We'd need to split our data across many servers, which would increase our concern about 
out-o"
1765,509,"7 .8 Othello: Othello is played as follows: Each Othello piece is white on one side and black on the other. 
When a piece is surrounded by its opponents on both the left and right sides, or both the top and 
bottom, it is said to be captured and its color is flipped. On your turn, you must capture a"
1766,472,"pg128 
SOLUTION 
Let's start with an example. Suppose we have the following moves in an Othello game: 
1. Initialize the board with two black and two white pieces in the center. The black pieces are placed at the
upper left hand and lower right hand corners.
2. Play a black piece at (row 6, column 4"
1767,485,"This sequence of moves leads to the board below. 
000 
The core objects in Othello are probably the game, the board, the pieces (black or white), and the players. 
How do we represent these with elegant object-oriented design? 
Should BlackPiece and WhitePiece be classes? 
At first, we might think w"
1768,466,"between 
colors frequently, so continuously destroying and creating what is really the same object is probably not 
wise. It may be better to just have a Piece class, with a flag in it representing the current color. 
Do we need separate Board and Game classes? 
Strictly speaking, it may not be nece"
1769,46,"326 Cracking the Coding Interview, 6th Edition"
1770,421,"Solutions to Chapter 7 I Object-Oriented Design 
involving placing pieces) and the game (which involves times, game flow, etc.). However, the drawback is 
that we are adding extra layers to our program. A function may call out to a method in Game, only to have 
it immediately call Board. We have mad"
1771,473,"should discuss this with your interviewer. 
Who keeps score? 
We know we should probably have some sort of score keeping for the number of black and white pieces. 
But who should maintain this information? One could make a strong argument for either Game or Board 
maintaining this information, and p"
1772,484,"Piece or Board calling the colorChanged and colorAdded methods within Board. 
Should Game be a Singleton class? 
Implementing Game as a singleton class has the advantage of making it easy for anyone to call a method 
within Game, without having to pass around references to the Game object. 
However,"
1773,510,"One possible design for Othello is below. 
1 public enum Direction { 
2 left, right, up, down 
3 } 
4 
5 public enum Color { 
6 White, Black 
7 } 
8 
9 public class Game { 
10 private Player[] players; 
11 private static Game ins tance; 
12 private Board board; 
13 private final int ROWS= 10; 
14 pr"
1774,278,"20 players[l] = new Player(Color.White); 
21 } 
22 
23 public static Game getinstance() { 
24 if (instance== null) instance = new Game(); 
25 return instance; 
26 } 
27 
28 public Board getBoard() { 
29 return board; 
30 } 
31 } 
CrackingTheCodinglnterview.com j 6th Edition 327"
1775,506,"Solutions to Chapter 7 I Object-Oriented Design 
The Boa rd class manages the actual pieces themselves. It does not handle much of the game play, leaving 
that up to the Game class. 
1 public class Board { 
2 private int blackCount 0; 
3 private int whiteCount 0; 
4 private Piece[][] board; 
r; 
6 
"
1776,510,"} 
public void initialize() { 
/* initialize center black and white pieces */ 
} 
/* Attempt to place a piece of color color at (row, column). Return true if we 
* were successful. */
public boolean placeColor(int row, int column, Color color) {
} 
/* Flips pieces starting at (row, column) and proce"
1777,478,"else return whiteCount; 
/* Update board with additional newPieces pieces of color newColor. Decrease 
* score of opposite color. */
public void updateScore(Color newColor, int newPieces) { ... }
As described earlier, we implement the black and white pieces with the Piece class, which has a simple 
"
1778,485,"4 
5 public void flip() { 
6 if (color == Color.Black) color Color.White; 
7 else color = Color.Black; 
8 } 
9 
10 public Color getColor() { return color; } 
11 } 
The Player holds only a very limited amount of information. It does not even hold its own score, but it 
does have a method one can call"
1779,120,"3 public Player(Color c) { color c;} 
4 
5 public int getScore() { ... } 
328 Cracking the Coding Interview, 6th Edition"
1780,427,"Solutions to Chapter 7 I Object-Oriented Design 
6 
7 public boolean playPiece(int r, int c) { 
8 return Game.getlnstance().getBoard().plac eColor(r, c, color); 
9 } 
10 
11 public Color getColor() { return color; } 
12 } 
A fully functioning (automated) version of this code can be found in the down"
1781,490,"probably doesn't care much whether you chose to implement Game as a singleton or not, but she probably 
does care that you took the time to think about it and discuss the trade-offs. 
7.9 Circular Array: Implement a CircularArray class that supports an array-like data structure which 
can be efficie"
1782,503,"pg 128
SOLUTION 
This problem really has two parts to it. First, we need to implement the CircularArray class. Second, we 
need to support iteration. We will 
address these parts separately. 
Implementing the CircularArray class 
One way to implement the CircularArray class is to actually shift the "
1783,475,"as the start of the circular array. Rather than shifting around the elements in the array, we just increment 
head by shift Right. 
The code below implements this approach. 
1 public class CircularArray<T> { 
2 private T[] items; 
3 private int head= 0; 
4 
5 public Circul arArray(int size) { 
6 ite"
1784,251,"12 } 
13 return (head+ index)% items.length; 
14 } 
15 
16 public void rotate(int shiftRight) { 
17 head= convert(shiftRight); 
18 } 
19 
20 public T get(int i) { 
21 if (i < 0 I I i >= items.length) { 
CrackingTheCodinglnterview.com I 6th Edition 329"
1785,493,"Solutions to Chapter 7 I Object-Oriented Design 
22 throw new java. lang. IndexOutOfBoundsException("" ... ""); 
23 } 
24 return items[convert(i)]; 
25 } 
26 
27 public void set(int i, T item) { 
28 items[convert(i)] = item; 
29 } 
30 } 
There are a number of things here which are easy to make mistake"
1786,505,"• The% operator will return a negative value when we do negValue % posVal. For example, -8 %
3 is -2. This is different from how mathematicians would define the modulus function. We must add
i terns. length to a negative index to get the correct positive result.
We need to be sure to consistently co"
1787,476,"convert. This is a good example of code reuse.
Now that we have the basic code for CircularArray out of the way, we can focus on implementing an 
iterator. 
Implementing the Iterator Interface 
The second part of this question asks us to implement the CircularArray class such that we can do the 
fol"
1788,471,"apply to Java, but similar things can be implemented in other languages. 
To implement the Iterator interface, we need to do the following: 
Modify the CircularArray<T> definition to add implements Iterable<T>. This will also require 
us to add an iterator() method to CircularArray<T>. 
• Create a C"
1789,480,"Once we've done the above items, the for loop will ""magically""work. 
In the code below, we have removed the aspects of CircularArray which were identical to the earlier 
implementation. 
1 public class CircularArray<T> implements Iterable<T> { 
2 
3 public Iterator<T> iterator() { 
4 return new Circ"
1790,106,"9 * start of the raw array. */
10 private int current = -1;
330 Cracking the Coding Interview, 6th Edition"
1791,467,"11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 } 
34 } 
Solutions to Chapter 7 I Object-Oriented Design 
private TI[] _items; 
public CircularArrayiterator(CircularArray<TI> array){ 
items = array.items; 
} 
@Override 
public boolean hasNext() { 
return _c"
1792,495,"return item; 
@Override 
public void remove() { 
throw new UnsupportedOperationExcep tion("" ... ""); 
} 
In the above code, note that the first iteration of the for loop will call ha sNext () and then next (). Be very 
sure that your implementation will return the correct values here. 
When you get a"
1793,165,"can. If you can reason out what sorts of methods one might need, that alone will show a good degree of 
competency. 
CrackingTheCodinglnterview.com I 6th Edition 331"
1794,447,"Solutions to Chapter 7 I Object-Oriented Design 
7.1 O Minesweeper: Design and implement a text-based Minesweeper game. Minesweeper is the classic 
single-player computer game where an NxN grid has B mines (or bombs) hidden across the grid. The 
remaining cells are either blank or have a number behi"
1795,410,"If it is a number, the number is exposed. If it is a blank cell, this cell and all adjacent blank cells (up to 
and including the surrounding numeric cells) are exposed. The player wins when all non-bomb cells 
are exposed. The player can also flag certain places as potential bombs. This doesn't aff"
1796,487,"(Tip for the reader: if you're not familiar with this game, please play a few rounds on line first.) 
This is a fully exposed board with 3 
bombs. This is not shown to the user. 
1 1 1 
1 * 1 
2 2 2
1 * 1 
1 1 1 
1 1 1 
1 * 1 
Clicking on cell (row= 1, col= 0) 
would expose this: 
2 
The player init"
1797,431,"2 2 2 
1 fitcll 1 
1 1 1 
1 1 1 
1 1'11 1 
pg 729 
SOLUTION 
Writing an entire game-even a text-based one-would take far longer than the allotted time you have 
in an interview. This doesn't mean that it's not fair game as a question. It just means that your interviewer's 
expectation will not be th"
1798,480,"on getting the key ideas-or structure-out. 
Let's start with what the classes are. We certainly want a Cell class as well as a Board class. We also prob­
ably want to have a Game class. 
I 
332 
We could potentially merge Board and Game together, but it's probably best to keep them 
separate. Err to"
1799,42,"Cracking the Coding Interview, 6th Edition"
1800,472,"Solutions to Chapter 7 I Object-Oriented Design 
Design: Cell 
Cell will need to have knowledge of whether it's a bomb, a number, or a blank. We could potentially 
subclass Cell to hold this data, but I'm not sure that offers us much benefit. 
We could also have an enum TYPE {BOMB, NUMBER, BLANK} to"
1801,489,"have an isBomb flag. 
It's okay to have made different choices here. These aren't the only good choices. Explain the choices you 
make and their tradeoffs with your interviewer. 
We also need to store state for whether the cell is exposed or not. We probably do not want to subclass 
Cell for Exposed"
1802,501,"the instance of Cell? 
It's better to just have a boolean flag for is Exposed. We'll do a similar thing for isGuess. 
1 public class Cell { 
2 private int row; 
3 private int column; 
4 private boolean isBomb; 
5 private int number; 
6 private boolean isExposed = false; 
7 private boolean isGuess = "
1803,472,"21 
22 
23 
24 
25 
public boolean flip() { 
isExposed = true; 
return !isBomb; 
} 
public boolean toggleGuess() { 
if (!isExposed) { 
isGuess = !isGuess; 
} 
return isGuess; 
} 
26 /* Full code can be found in downloadable code solutions. */ 
27 } 
Design: Board 
Board will need to have an array of"
1804,214,"so we don't have to continuously count it. 
Board will also handle some of the basic algorithms: 
Initializing the board and laying out the bombs. 
Flipping a cell. 
CrackingTheCodinglnterview.com ! 6th Edition 333"
1805,501,"Solutions to Chapter 7 I Object-Oriented Design 
Expanding blank areas. 
It will receive the game plays from the Game object and carry them out. It will then need to return the 
result of the play, which could be any of {clicked a bomb and lost, clicked out of bounds, clicked an already 
exposed are"
1806,488,"successfully made) and a game state (won, lost, playing). We'll use an additional GamePlayResul t to 
return this data. 
We'll also use a GamePlay class to hold the move that the player plays. We need to use a row, column, 
and then a flag to indicate whether this was an actual flip or the user was "
1807,485,"2 private int nRows; 
3 private int nColumns; 
4 private int nBombs = 0; 
5 private Cell[][] cells; 
6 private Cell[] bombs; 
7 private int numUnexposedRemaining; 
8 
9 
10 
public Board(int r, int c, int b) { 
11 private void initializeBoard() { ... } 
} 
12 private boolean flipCell(Cell cell) { .."
1808,488,"16 } 
17 
18 public class UserPlay { 
19 private int row; 
20 private int column; 
21 private boolean isGuess; 
22 /* constructor, getters, setters. */ 
23 } 
24 
25 public class UserPlayResult { 
26 private boolean succ essful; 
27 private Game.GameState resultingState; 
28 /* constructor, getters,"
1809,262,"sends it off to Board. 
1 public class Game { 
2 public enum GameState { WON, LOST, RUNNING} 
3 
4 private Board board; 
5 private int rows; 
6 private int columns; 
7 privatQ int bombs; 
8 private GameState state; 
334 Cracking the Coding Interview, 6th Edition"
1810,409,"9 
10 
11 
12 
13 
14 
15 } 
Solutions to Chapter 7 I Object-Oriented Design 
public Game(int r, int c, int b) { ... } 
public boolean initialize() { ... } 
public boolean st art() { ... } 
private boolean playGame() { ... } // Loops until game is over. 
Algorithms 
This is the basic object-oriented"
1811,459,"of the most interesting algorithms. 
In this case, the three interesting algorithms is the initialization (placing the bombs randomly), setting the 
values of the numbered cells, and expanding the blank region. 
Placing the Bombs 
To place the bombs, we could randomly pick a cell and then place a bo"
1812,428,"We could end up in a situation where we repeatedly pick cells with bombs. 
To get around this, we could take an approach similar to the card deck shuffling problem (pg 531). We 
could place the K bombs in the first K cells and then shuffle all the cells around. 
Shuffling an array operates by iterat"
1813,497,"random index between i and N-1 and swap it with that index. 
To shuffle a grid, we do a very similar thing, just converting the index into a row and column location. 
1 void shuffleBoard() { 
2 int nCells = nRows * nColumns; 
3 Random random = new Random(); 
4 for (int indexl = 0; indexl < nCells; i"
1814,485,"11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 } 
24 } 
} 
int rowl = indexl / nColumns; 
int columnl = (indexl - rowl * nColumns) % nColumns; 
Cell celll = cells[rowl][columnl]; 
/* Get cell at index2. */ 
int row2 = index2 / nColumns; 
int column2 = (index2 - row2 * nColumns) % nColumns; 
Cell"
1815,88,"cell1.setRowAndCo lumn(row2, column2); 
CrackingTheCodinglnterview.com I 6th Edition 335"
1816,488,"Solutions to Chapter 7 I Object-Oriented Design 
Setting the Numbered Cells 
Once the bombs have been placed, we need to set the values of the numbered cells. We could go through 
each cell and check how many bombs are around it. This would work, but it's actually a bit slower than is 
necessary. 
I"
1817,508,"1 /* Set the cells around the bombs to the right number. Although the bombs have 
2 * been shuffled, the reference in the bombs array is still to same object. *I
3 void setNumberedCells() { 
4 int[][] deltas = { II Offsets of 8 surrounding cells 
5 {-1, -1}, {-1, 0}, {-1, 1}, 
6 {0, -1}, {0,1 }, 
7 "
1818,499,"13 int r =r ow+ delta[0]; 
14 int c =c ol+ delta[1]; 
15 if (inBounds(r, c)) { 
16 cells[r][c].incre mentNumber(); 
17 } 
18 } 
19 } 
20 } 
Expanding a Blank Region 
Expanding the blank region could be done either iteratively or recursively. We implemented it iteratively. 
You can think about this a"
1819,500,"cells to a queue, to flip their neighboring cells. 
1 void expandBlank(Cell cell) { 
2 int[][] deltas = { 
3 {-1, -1}, {-1, 0}, {-1, 1}, 
4 { 0 , -1}, { 0, l}, 
5 { 1, -1}, { 1, 0}, { 1, 1} 
6 } ; 
7 
8 Queue<Cell> toExplore new Linkedlist<Cell>(); 
9 toExplore.add(cell); 
10 
11 while (!toExplore.i"
1820,190,"17 
18 if (inBounds(r, c)) { 
19 Cell neighbor = cells[r][c]; 
20 if (flipCell(neighbor) && neighbor.isBlank()) { 
21 toExplore.add(neighbor); 
336 Cracking the Coding Interview, 6th Edition"
1821,504,"Solutions to Chapter 7 I Object-Oriented Design 
22 
23 
24 } 
25 } 
26 } 
} 
} 
You could instead implement this algorithm recursively. In this algorithm, rather than adding the cell to a 
queue, you would make a recursive call. 
Your implementation of these algorithms could vary substantially depe"
1822,474,"pg 129 
SOLUTION 
Many candidates may see this problem and instantly panic. A file system seems so low level! 
However, there's no need to panic. If we think through the components of a file system, we can tackle this 
problem just like any other object-oriented design question. 
A file system, in i"
1823,506,"tics, we've implemented them such that they inherit from the same class, Entry. 
1 public abstract class Entry { 
2 protected Directory parent; 
3 protected long created; 
4 protected long lastUpdated; 
5 protected long lastAccessed; 
6 protected String name; 
7 
8 public Entry(String n, Directory p"
1824,501,"14 } 
15 
15 public boolean delete() { 
17 if (parent == null) return false; 
18 return parent.deleteEntry(this); 
19 } 
20 
21 public abstract int size(); 
22 
23 public String getFullPath() { 
24 if (parent == null) return name; 
25 else return parent. getFullPath () + ""/"" + name; 
26 } 
27 
28 /*"
1825,111,"31 public long getLastAccessedTime() { return lastAccessed; } 
CrackingTheCodinglnterview.com I 6th Edition 337"
1826,489,"Solutions to Chapter 7 I Object-Oriented Design 
32 public void changeName(String n) {name = n;} 
33 public String getName() { return name; } 
34 } 
35 
36 public class File extends Entry { 
37 private String content; 
38 private int size; 
39 
40 public File(String n, Directory p, int sz) { 
41 sup"
1827,507,"47 public void setContents(String c) {content = c; } 
48 } 
49 
50 public class Directory extends Entry { 
51 protected Arraylist<Entry> contents; 
52 
53 public Directory(String n, Directory p) { 
54 super(n, p); 
55 contents = new Arraylist<Entry>(); 
56 } 
57 
58 public int size() { 
59 int size "
1828,445,"69 if (e instanceof Directory) { 
70 count++; // Directory counts as a file 
71 Directory d = (Directory) e; 
72 count += d. numberOfFiles (); 
73 } else if (e instanceof File) { 
74 count++; 
75 } 
76 } 
77 return count; 
78 } 
79 
80 public boolean deleteEntry(Entry entry) { 
81 return contents.re"
1829,435,"Solutions to Chapter 7 I Object-Oriented Design 
88 protected ArrayList<Entry> getContents() { return contents; } 
89 } 
Alternatively, we could have implemented Directory such that it contains separate lists for files and 
subdirectories. This makes the nurnberOfFiles () method a bit cleaner, since"
1830,475,"7.12 Hash Table: Design and implement a hash table which uses chaining (linked lists) to handle 
collisions. 
pg 129 
SOLUTION 
Suppose we are implementing a hash table that looks like Hash<K, V>. That is, the hash table maps from 
objects of type K to objects of type V. 
At first, we might think ou"
1831,440,"4 public V get(K key) { ... } 
5 } 
Note that i terns is an array of linked lists, where i terns [ i] is a linked list of all objects with keys that map 
to index i (that is, all the objects that collided at i). 
This would seem to work until we think more deeply about collisions. 
Suppose we have a"
1832,422,"2 return key.to5tring().length() % items.length; 
3 } 
The keys j irn and bob will map to the same index in the array, even though they are different keys. We need 
to search through the linked list to find the actual object that corresponds to these keys. But how would we 
do that? All we've stored"
1833,499,"One way to do that is to create another object called Ce 11 which pairs keys and values. With this implemen­
tation, our linked list is of type Cell. 
The code below uses this implementation. 
1 public class Hasher<K, V> { 
2 /* Linked list node class. Used only within hash table. No one else should"
1834,201,"6 public LinkedListNode<K, V> prev; 
7 public K key; 
8 public V value; 
9 public LinkedListNode(K k, V v) { 
10 key= k; 
11 value = v; 
12 } 
13 } 
14 
CrackingTheCodinglnterview.com j 6th Edition 339"
1835,510,"Solutions to Chapter 7 I Object-Oriented Design 
15 private ArrayList<LinkedListNode<K, V>> arr; 
16 public Hasher(int capacity) { 
17 /* Create list of linked lists at a particular size. Fill list with null 
18 * values, as it's the only 
way to make the array the desired size. */
19 arr = new Arra"
1836,483,"23 } 
24 } 
25 
26 /* Insert key and value into hash table. */ 
27 public void put(K key, V value) { 
28 LinkedListNode<K, V> node = getNodeForKey(key); 
29 if (node != null) {//Already there 
30 node.value = value; // just update the value. 
31 return; 
32 } 
33 
34 node = new LinkedListNode<K, V>("
1837,478,"39 } 
40 arr.set(index, node); 
41 } 
42 
43 /* Remove node for key. */ 
44 public 
void remove(K key) { 
45 LinkedListNode<K, V> node = getNodeForKey(key); 
46 if (node.prev != null) { 
47 node.prev.next = node.next; 
48 } else { 
49 /* Removing head - update. */ 
50 int hashKey = getindexForKey(ke"
1838,473,"58 
59 /* Get value for key. */ 
60 public V get(K key) { 
61 LinkedListNode<K, V> node = getNodeForKey(key); 
62 return node == null ? null : node.value; 
63 } 
64 
65 /* Get linked list node associated with a given key. */ 
66 private LinkedListNode<K, V> getNodeForKey(K key) { 
67 int index= geti"
1839,404,"Solutions to Chapter 7 I Object-Oriented Design 
71 return current; 
72 } 
73 current= current.next; 
74 } 
75 return null; 
76 } 
77 
78 /* Really naive function to map a key to an index. */ 
79 public int getindexForKey(K key) { 
80 return Math.abs(key.hashCode() % arr.size()); 
81 } 
82 } 
83 
Al"
1840,295,"as the underlying data structure. Retrieving an element will no longer be O( 1) (although, technically, this 
implementation is not 0(1) if there are many collisions), but it prevents us from creating an unnecessarily 
large array to hold items. 
CrackingTheCodinglnterview.com I 6th Edition 341"
1841,499,"8 
Solutions to Recursion and Dynamic Programming 
8.1 Triple Step: A child is running up a staircase with n steps and can hop either 1 step, 2 steps, or 3 
steps at a time. Implement a method to count how many possible ways the child can run up the 
stairs. 
pg134
SOLUTION 
Let's think about this w"
1842,476,"2-step hop, or a 1-step hop.
How many ways then are there to get up to the nth step? We don't know yet, but we can relate it to some 
subproblems. 
If we thought about all of the paths to the nth step, we could just build them off the paths to the three 
previous steps. We can get up to the nth step"
1843,486,"Going to the 
(n - 3)rd step and hopping 3 steps.
Therefore, we just need to add the number of these paths together. 
Be very careful here. A lot of people want to multiply them. Multiplying one path with another would signify 
taking one path and then taking the other. That's not what's happening h"
1844,504,"countWays(n-1) + countWays(n-2) + countWays(n-3) 
The one tricky bit is defining the base case. If we have O steps to go (we're currently standing on the step), 
a re there zero paths to that step or one path? 
That 
is, what is co untWays(0)? Is it 1 orO? 
You could define it either way. There is n"
1845,46,"342 Cracking the Coding Interview, 6th Edition"
1846,445,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
A simple implementation of this code is below. 
1 int countWays(int n) { 
2 if (n < 0) { 
3 return 0; 
4 } else if (n 0) { 
return 5 1;
} else { 6 
7 
8 
return countWays(n-1) + countWays(n-2) + countWays(n-3); 
} 
9 } 
Like the Fibonacci p"
1847,485,"branches out to three more calls. 
Memoization Solution 
The previous solution for co untWays is called many times for the same values, which is unnecessary. We 
can fix this through memoization. 
Essentially, if we've seen this value of n before, return the cached value. Each time we compute a fres"
1848,470,"through n. It's more compact to use an integer array. 
1 int countWays(int n) { 
2 int[] memo = new int[n + 1]; 
3 Arrays.fill(memo, -1); 
4 return countWays(n, memo); 
5 } 
6 
7 int countWays(int n, int[] memo) { 
8 if (n < 0) { 
9 return 0; 
10 } else if (n == 0) { 
11 return 1; 
12 } else if (mem"
1849,427,"16 countWays ( n - 3, memo) ; 
17 return memo[n]; 
18 } 
19 } 
Regardless of whether or not you use memoization, note that the number of ways will quickly overflow the 
bounds of an integer. By the time you get to just n 37, the result has already overflowed. Using a long 
will delay, but not comple"
1850,161,"(although you could, with a Biginteger class). but it's nice to demonstrate that you think about these 
issues. 
CrackingTheCodinglnterview.com I 6th Edition 343"
1851,407,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
8.2 Robot in a Grid: Imagine a robot sitting on the upper left corner of grid with r rows and c columns. 
The robot can only move in two directions, right and down, but certain cells are ""off limits"" such that 
the robot cannot step on them"
1852,440,"the bottom right. 
pg735 
SOLUTION 
If we picture this grid, the only way to move to spot ( r, c) is by moving to one of the adjacent spots: 
( r -1, c) or ( r, c -1). So, we need to find a path to either ( r-1, c) or ( r, c -1). 
How do we find a path to those spots? To find a path to ( r-1, c) or "
1853,482,"( r-2, c) and ( r-1, c -1). or a spot adjacent to ( r, c -1). which are soots ( r- L c -1) and ( r. c -2). 
Observe that we list the point ( r-1, c -1) twice; we'll discuss that issue later. 
I 
Tip: A lot of people use the variable names x and y when dealing with two-dimensional arrays. 
This can a"
1854,474,"first coordinate is usually thought of as the row number, which is in fact they value (it goes verti­
cally!). You should write matrix[y] [x]. Or, just make your life easier by using r (row) and c 
(column) instead. 
So then, to find a path from the origin, we just work backwards like this. Starting"
1855,474,"1 Arraylist<Point> getPath(boolean[][] maze) { 
2 if (maze == null I I maze.length == 0) return null; 
3 ArrayList<Point> path = new Arraylist<Point>(); 
4 if (getPath(maze, maze.length - 1, maze[0].length - 1, path)) { 
5 return path; 
6 } 
7 return null; 
8 } 
9 
10 boolean getPath(boolean[][] maz"
1856,465,"13 return false; 
14 } 
15 
16 boolean isAtOrigin =(row == 0) && (col == 0); 
17 
18 /* If there's a path from the start to here, add my location. */ 
19 if (isAtOrigin I I getPath(maze, row, col - 1, path) I I
20 getPath(maze, row - 1, col, path)) { 
21 Point p = new Point(row, col); 
22 path.ad d("
1857,46,"344 Cracking the Coding Interview, 6th Edition"
1858,504,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
We should look for a faster way. 
Often, we can optimize exponential algorithms by finding duplicate work. What work are we repeating? 
If we walk through the algorithm, we'll see that we are visiting squares multiple times. In fact, we vis"
1859,475,"somehow doing a lot of work during each visit). 
How does our current algorithm work? To find a path to ( r, c), we look for a path to an adjacent coor­
dinate: ( r-1, c) or ( r, c-1). Of course, if one of those squares is off limits, we ignore it. Then, we look 
at their adjacent coordinates: ( r-2"
1860,447,"visited ( r-1, c -1) so that we don't waste our time. 
This is what the dynamic programming algorithm below does. 
1 Arraylist<Point> getPath(boolean[][] maze) { 
2 if (maze == null I I maze.length== 0) return null; 
3 Arraylist<Point> path= new Arraylist<Point>(); 
4 HashSet<Point> failedPoints = n"
1861,496,"6 return path; 
7 } 
8 return null; 
9 } 
10 
11 boolean getPath(boolean[][] maze, int row, int col, Arraylist<Point> path, 
12 HashSet<Point> failedPoints) { 
13 /* If out of bounds or not available, return.*/ 
14 if (col < 0 11 row < 0 11 !maze[row][col]) { 
15 return false; 
16 } 
17 
18 Point p "
1862,482,"23 } 
24 
25 boolean isAtOrigin =(row== 0) && (col== 0); 
26 
27 /* If there's a path from start to my current location, add my location.*/ 
28 if (isAtOrigin I I getPath(maze, row, col - 1, path, failedPoints) I I 
29 getPath(maze, row - 1, col, path, failedPoints)) { 
30 path.add(p); 
31 return tr"
1863,85,"because we hit each cell just once. 
CrackingTheCodinglnterview.com I 6th Edition 345"
1864,437,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
8.3 Magic Index: A magic index in an array A[ 1 .•. n-1] is defined to be an index such that A[ i] 
i. Given a sorted array of distinct integers, write a method to find a magic index, if one exists, in
array A.
FOLLOW UP 
What if the values"
1865,432,"simply iterate through the array, looking for an element which matches this condition. 
1 int magicSlow(int[] array) { 
2 for (int i= 0; i < array.length; i++) { 
3 if (array[i] == i) { 
4 return i; 
5 } 
6 } 
7 return -1; 
8 } 
Given that the array is sorted, though, it's very likely that we're sup"
1866,503,"Pattern Matching approach for generating algorithms, how might we apply binary search here? 
In binary search, we find an element k by comparing it to the middle element, x, and determining if k 
would land on the left or the right side of x. 
Building off this approach, is there a way that we can l"
1867,435,"sinceA[mid] < mid. 
Why couldn't the magic index be on the left side? Observe that when we move from i to i-1, the value 
at this index must decrease by at least 1, if not more (since the array is sorted and all the elements are 
distinct). So, if the middle element is already too small to be a magi"
1868,440,"We continue to apply this recursive algorithm, developing code that looks very much like binary search. 
1 int magicFast(int[] array) { 
2 return magicFast(array, 0, array.length - 1); 
3 } 
4 
5 int magicFast(int[] array, int start, int end) { 
6 if (end< start) { 
7 return -1; 
8 } 
9 int mid= (st"
1869,498,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
13 return magicFas t(array, start, mid - 1); 
14 } else { 
15 return magicFas t(array, mid+ 1, end); 
16 } 
17 }
Follow Up: What if the elements are not distinct? 
If the elements are not distinct, then this algorithm fails. Consider the fo"
1870,488,"Could it be anywhere on the left side? Not exactly. Since A[ 5] = 3, we know that A[ 4] couldn't be a magic 
index. A[ 4] would need to be 4 to be the magic index, but A[ 4] must be less than or equal to A[ 5]. 
In fact, when we see that A[ 5] = 3, we'll need to recursively search the right side as "
1871,510,"A [ 3] is the first element that could be a magic index. 
The general pattern is that we compare mid Index and midValue for equality first. Then, if they are not 
equal, we recursively search the left and right sides as follows: 
• Left side: search indices start through Math. min (midlndex -
1, mid"
1872,472,"2 return magicFas t(array, 0, array.length - 1); 
3 
} 
4 
5 int magicFast(int[] array, int start, int end) { 
6 if (end< start) return -1; 
7 
8 int midindex =(start+ end)/ 2; 
9 int midValue = array[midindex]; 
10 if (midValue == midindex) { 
11 return midindex; 
12 } 
13 
14 /* Search left */ 
15"
1873,233,"18 return left; 
19 } 
20 
21 /* Search right */ 
22 int rightindex = Math.max(midindex + 1, midValue); 
23 int right = magicFas t(array, rightlndex, end); 
24 
25 return right; 
26 } 
CrackingTheCodinglnterview.com I 6th Edition 347"
1874,455,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
Note that in the above code, if the elements are all distinct, the method operates almost identically to the 
first solution. 
8.4 Power Set: Write a method to return all subsets of a set. 
SOLUTION 
We should first have some reasonable exp"
1875,422,"being in there or not. That is, for the first element, there are two choices: it is either in the set or it is not. For 
the second, there are two, etc. So, doing { 2 * 2 * . . . } n times gives us 2"" subsets. 
Assuming that we're going to be returning a list of subsets, then our best case time is a"
1876,431,"contained in half of the subsets (which 2n-1 subsets). Therefore, the total number of elements across all of
those subsets is n 
* 2 n-1. 
We will not be able to beat 0( n2"") in space or time complexity. 
The subsets of {a1, a2, ••• , an} are also called the powersetP({a1, a2, ••• , an}),orjustP(n)."
1877,437,"all subsets of a set like S = {a1, a2, ••• , an}. We can start with the Base Case.
Base Case: n 
= 0. 
There is just one subset of the empty set: {}. 
Case:n = 1. 
There are two subsets of the set {aJ: {}, {aJ. 
Case:n = 2. 
There are four subsets of the set {a1 , aJ: {}, {aJ, {a), {a1 , a2}. 
Case:"
1878,507,"on the prior solutions. 
3 based 
What is the difference between the solution for n 3 and the solution for n = 2? Let's look at this more 
deeply: 
P(2) = { }, {a1}, {a2}, {a1, a2} 
P(3) = { }, {aJ, {a2}, {a3}, {a1, a2}, {a1, a3}, {a2, a3}, {a1, a2, a3} 
The difference between these solutions is tha"
1879,127,"P(2) {} , {a1}, {a2}, {a1, aJ
P(2) + a, = {a3}, {a1, a3}, {a2, a), {a1, a2, a3} 
348 Cracking the Coding Interview, 6th Edition"
1880,474,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
When merged together, the lines above make P ( 3). 
Case:n > 0 
Generating P ( n) for the general case is just a simple generalization of the above steps. We compute 
P ( n-1), clone the results, and then add an to each of these cloned sets"
1881,492,"2 Arraylist<Arraylist<Integer>> allsubsets; 
3 if (set.size()== index) {//Base case - add empty set 
4 allsubsets = new Arraylist<Arraylist<Integer>>(); 
5 allsubsets.add(new Arraylist<Integer>()); // Empty set 
6 } else { 
7 allsubsets = getSubsets(set, index+ 1); 
8 int item= set.get(index); 
9 Ar"
1882,502,"12 Arraylist<Integer> newsubset = new Arraylist<Integer>(); 
13 newsubset.addAll(subset); // 
14 newsubset.add(item); 
15 moresubsets.add(newsubset); 
16 } 
17 allsubsets.addAll(moresubsets); 
18 } 
19 return allsubsets; 
20 } 
This solution will be O(n2n) in time and space, which is the best we can"
1883,497,"Recall that when we're generating a set, we have two choices for each element: (1) the element is in the set 
(the ""yes"" state) or (2) the element is not in the set (the ""no"" state). This means that each subset is a sequence 
of yeses I nos-e.g., ""yes, yes, no, no, yes, no"" 
This gives us 2n possibl"
1884,475,"represented as a binary string. 
Generating all subsets, then, really just comes down to generating all binary numbers (that is, all integers). 
We iterate through all numbers from 0 to 2n (exclusive) and translate the binary representation of the 
numbers into a set. Easy! 
1 Arraylist<Arraylist<In"
1885,246,"3 int max= 1 << set.size(); /* Compute 2An */ 
4 for (int k = 0; k < max; k++ ) { 
5 ArrayList<Integer> subset= convertintToSet(k , set); 
6 allsubsets.add(subset); 
7 } 
8 return allsubsets; 
9 } 
CrackingTheCodinglnterview.com \ 6th Edition 349"
1886,450,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
10 
11 Arraylist<Integer> convertlntToSet(int x, Arraylist<Integer> set) { 
12 Arraylist<Integer> subset = new Arraylist<Integer>(); 
13 int index = 0; 
14 for (int k = x; k > 0; k >>= 1) { 
15 if ((k & 1) == 1) { 
16 subs et.add(set.get(in"
1887,500,"8.5 Recursive Multiply: Write a recursive function to multiply two positive integers without using 
the * operator (or / operator). You can use addition, subtraction, and bit shifting, but you should 
minimize the number of those operations. 
pg 135
SOLUTION 
Let's pause for a moment and think about"
1888,501,"really means to do something, even when it's pretty obvious. 
We can think about multiplying 8x7 as doing 8+8+8+8+8+8+8 (or adding 7 eight times). We can also think 
about it as the number of squares in an 8x7 grid. 
Solution #1 
How would we count the number of squares in this grid? We could just c"
1889,295,"half the squares, we repeat the same process. 
Of course, this ""doubling"" only works if the number is in fact even. When it's not even, we need to do the 
counting/summing from scratch. 
1 int minProduct(int a, int b) { 
z int bigger = a< b? b: a; 
350 Cracking the Coding Interview, 6th Edition"
1890,505,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
3 int smaller = a< b? a: b; 
4 return minProductHelper(smaller, bigger); 
5 } 
6 
7 int minProductHelper(int smaller, int bigger) { 
8 if (smaller == 0) { // 0 x bigger = 0 
9 return 0; 
10 } else if (smaller == 1) { // 1 x bigger bigger 
1"
1891,482,"16 int sidel = minProduct(s, bigger); 
17 int side2 = sidel; 
18 if (smaller% 2 == 1) { 
19 side2 = minProductHelp er(smaller - s, bigger); 
20 } 
21 
22 return sidel + side2; 
23 } 
Can we do better? Yes. 
Solution #2 
If we observe how the recursion operates, we'll notice that we have duplicated w"
1892,484,"+ minProduct(S, 23)
The second call to min Product ( 
4, 23) is unaware of the prior call, and so it repeats the same work. We 
should cache these results. 
1 int minProduct(int a, int b) { 
2 int bigger = a< b? b: a; 
3 int smaller = a< b? a: b; 
4 
5 int memo[]= new int[smaller + 1]; 
6 return min"
1893,259,"11 return 0; 
12 } else if (smaller == 1) { 
13 return bigger; 
14 } else if (memo[smaller] > 0) { 
15 return memo[smaller]; 
16 } 
17 
18 /* Compute half. If uneven, compute other half. If even, double it. */ 
CrackingTheCodinglnterview.com I 6th Edition 351"
1894,414,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
19 int s = smaller >> 1; II Divide by 2 
20 int sidel = minProduct(s, bigger, memo); II Compute half 
21 int si de2 = si del; 
22 if (smaller% 2 == 1) { 
23 side2 = minProduct(smaller - s, bigger, memo); 
24 } 
25 
26 I* Sum and cache.*/ 
2"
1895,507,"29 } 
We can still make this a bit faster. 
Solution#3 
One thing we might notice when we look at this code is that a call to minProduct on an even number is 
much faster than one on an odd number. For example, if we call min Product ( 30, 35), then we'll just 
do minProduct(15, 35) and double the r"
1896,416,"minProduct(31, 35) = 2 * minProduct(15, 35) + 35 
After all, since 31 = 2*15+1, then 31x35 = 2*15*35+35. 
The logic in this final solution is that, on even numbers, we just divide smaller by 2 and double the result 
of the recursive call. On odd numbers, we do the same, but then we also add bi gger "
1897,489,"with increasingly small numbers each time. It will never repeat the same call, so there's no need to cache 
any information. 
1 int minProduct(int a, int b) { 
2 int bigger = a< b? b: a; 
3 int smaller = a< b? a : b; 
4 return minProductHelper(smaller, bigger); 
5 } 
6 
7 int minProductHelper(int sm"
1898,309,"12 int halfProd = minProductHelper(s, bigger); 
13 
14 if (smaller% 2 == 0) { 
15 return halfProd + halfProd; 
16 } else { 
17 return halfProd + halfProd + bigger; 
18 } 
19 } 
This algorithm will run in O( log s) time, wheres is the smaller of the two numbers. 
352 Cracking the Coding Interview, 6t"
1899,489,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
8.6 Towers of Hanoi: In the classic problem of the Towers of Hanoi, you have 3 towers and N disks of 
different sizes which can slide onto any tower. The puzzle starts with disks sorted in ascending order 
of size from top to bottom (i.e., "
1900,459,"(2)
A disk is slid off the top of one tower onto another tower.
(3) A disk cannot be placed on top of a smaller disk.
Write a program to move the disks from the first tower to the last using Stacks. 
SOLUTION 
This problem sounds like a good candidate for the Base Case and Build approach. 
Let's 
st"
1901,425,"1. We simply move Disk 1 from Tower 1 to Tower 3.
Case n = 2. Can we move Disk 1 and Disk 2 from Tower 1 to Tower 3? Yes.
1. Move Disk 1 from Tower 1 to Tower 2
2. Move Disk 2 from Tower 1 to Tower 3
3. Move Disk 1 from Tower 2 to Tower 3
pg 135
Note how in the above steps, Tower 2 acts as a buffer,"
1902,491,"1. We know we can move the top two disks from one tower to another (as shown earlier), so let's assume
we've 
already done that. But instead, let's move them to Tower 2.
2. Move Disk 3 to Tower 3.
3. Move Disk 1 and Disk 2 to Tower 3. We already know how to do this-
just repeat what we did in Step 1"
1903,349,"2. Move Disk 4 to Tower 3.
3. Move Disks 1, 2 and 3 back to Tower 3.
Remember that the labels of Tower 2 and Tower 3 aren't important. They're equivalent towers. So, moving 
disks to Tower 3 with Tower 2 serving as a buffer is equivalent to moving disks to Tower 2 with Tower 3 
serving as a buffer. "
1904,487,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
This approach leads to a natural recursive algorithm. In each part, we are doing the following steps, outlined 
below with pseudocode: 
1 moveDisks(int n, Tower origin, Tower destination, Tower buffer) { 
2 /* Base case */ 
3 if (n <= 0) re"
1905,491,"7 
8 /* move top from origin to destination 
9 moveTop(origin, destination); 
10 
11 /* move top n - 1 disks from buffer to destination, using origin as a buffer. */ 
12 moveDisks(n - 1, buffer, destination, origin); 
13 } 
The following code provides a more detailed implementation of this algorithm"
1906,510,"5 towers[i] = new Tower(i); 
6 } 
7 
8 for (int i= n - 1; i >= 0; i--) { 
9 towers[0].add(i); 
10 } 
11 towers[0].moveDisks(n, towers[2], towers[l]); 
12 } 
13 
14 class Tower { 
1S private Stack<Integer> disks; 
16 private int index; 
17 public Tower(int i) { 
18 disks new Stack<Integer>(); 
19 ind"
1907,231,"28 System.out.println(""Error placing disk""+ d); 
29 } else { 
30 disks.push(d); 
31 } 
32 } 
33 
34 public void moveTopTo(Tower t) { 
35 int top= disks.pop(); 
36 t.add(top);
37 } 
38 
3S4 Cracking the Coding Interview, 6th Edition"
1908,415,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
39 public void moveDisks(int n, Tower destination, Tower buffer) { 
40 if (n > 0) { 
41 moveDisks(n - 1, buffer, destination); 
42 moveTopTo( destination); 
43 buffer.moveDisks(n - 1, destination, this); 
44 } 
45 } 
46 } 
Implementing the "
1909,489,"cleaner in some respects. 
8.7 Permutations without Dups: Write a method to compute all permutations of a string of unique 
characters. 
pg 735 
SOLUTION 
Like in many recursive problems, the Base Case and Build approach will be useful. Assume we have a string S 
represented by the characters a1 a2 "
1910,506,"The only permutation of a1 is the string a1. So: 
P(a1 ) = a1 
Case: permutations of a1 a2 
P(a1a2) = a1a2 and a2a1 
Case: permutations of a1a2a3 
P( a1 a2a) = a1 a2a3, a1a3a2, a2a1a3, a2a3a1, a3a1 a2, a3
a
2a1, 
Case: permutations of a1a2a3a4 
This is the first interesting case. How can we generate"
1911,502,"a2a1a3. 
Therefore, if we took all the permutations of a1a2a
3 and added a4 into all possible locations, we would get all 
permutations of a1a2a3a4. 
-> a1a2a3 
a1a3a2 -> 
a3a1a2 - > 
a2a1a3 ->
a2a3a1 ->
a3a2a, -> 
a4a1a2a3, 
a4a1a3a2, 
a4
a
3a1
a 2, 
a4a2a1a3, 
a4a2a3a1, 
a4a3a2a1 , 
a1
a4a2a3, 
a1"
1912,314,"a1a2a
3a4 
a1a3aza4 
a3a1a2a4 
a2a1a3a4 
a2a3a1a4 
a3a2a,a4 
1 Arraylist<String> getPerms(String str) { 
2 if (str == null) return null; 
3 
4 Arraylist<String> permutations new ArrayList<String>(); 
5 if (str.length() == 0) {//base case 
6 permutations. add('""'); 
CrackingTheCodinglnterview.com I 6"
1913,496,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
7 return permutations; 
8 } 
9 
10 char first= str.charAt(0); // get the first char 
11 String remainder= str.substring(l); // remove the first char 
12 Arraylist<String> words= getPerms(remainder); 
13 for (String word: words) { 
14 for (i"
1914,500,"20 } 
21 
22 /* Insert char ca t index i in word. */ 
23 String insertCharAt(String word, char c, int i) { 
24 String start= word.substring(0, i); 
25 String end= word.substring(i); 
26 return start+ c + end; 
27 } 
Approach 2: Building from permutations of all n-1 character substrings. 
Base Case: "
1915,482,"P( a2a) = a2a3 and a3a2 • 
P(a1a3 ) = a 1 a3 and a3a1 • 
Case: three-character strings 
Here is where the cases get more interesting. How can we generate all permutations of three-character 
strings, such as a1 a2a3, given the permutations of two-character strings? 
Well, in essence, we just need to"
1916,490,"{a1 + P(a2a3 )} -> a1a2a3 , a1a3 a2 
{ a2 + P( a1a)} -> a2 a1a3 , a2 a3a1 
{a3 + P(a1 a)} -> a3 a1 a2 , a3 a2 a1 
Now that we can generate all permutations of three-character strings, we can use this to generate permuta­
tions of four-character strings. 
P(a1a2a3a4) = {a1 + P(a2a3a4)} + {a2 + P(a1a,"
1917,163,"2 int len - remainder.length(); 
) A1Tc1ylist<:Slrl11g> r·e�ui-t ""' new ArrayL1st<Str1ng>(); 
4 
5 /* Base case. */ 
356 Cracking the Coding Interview, 6th Edition"
1918,511,"6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 } 
Solutions to Chapter 8 I Recursion and Dynamic Programming 
if (len == 0) { 
} 
result.add(""""); // Be sure to return empty string! 
return result; 
for (int i= 0; i < len; i++) { 
} 
/* Remove char i and find permutations "
1919,464,"/* Prepend char i to each permutation.*/ 
for (String s : partials) { 
result.add(remainder.charAt(i) + s); 
} 
return result; 
Alternatively, instead of passing the permutations back up the stack, we can push the prefix down the stack. 
When we get to the bottom (base case), prefix holds a full per"
1920,450,"3 getPerms("""", str, result); 
4 return result; 
5 } 
6 
7 void getPerms(String prefix, String remainder, Arraylist<String> result) { 
8 if (remainder.length()== 0) result.add(prefix); 
9 
10 int len = remainder.length(); 
11 for (int i= 0; i < len; i++) { 
12 String before = remainder.substring(0, i"
1921,469,"15 getPerms(prefix + c, before + after, result); 
16 } 
17 } 
For a discussion of the runtime of this algorithm, see Example 12 on page 51. 
8.8 Permutations with Duplicates: Write a method to compute all permutations of a string whose 
characters are not necessarily unique. The list of permutations"
1922,345,"in the word. 
One simple way of handling this problem is to do the same work to check if a permutation has been created 
before and then, if not, add it to the list. A simple hash table will do the trick here. This solution will 
take 
O(n ! ) time in the worst case (and, in fact in all cases). 
Cra"
1923,419,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
While it's true that we can't beat this worst case time, we should be able to design an algorithm to beat 
this in many cases. Consider a string with all duplicate characters, like aaaaaaaaaaaaaaa. This will take 
an extremely long time (si"
1924,456,"there is only one unique permutation. 
Ideally, we would like to only create the unique permutations, rather than creating every permutation and 
then ruling out the duplicates. 
We can start with computing the count of each letter (easy enough to get this-just use a hash table). For a 
string such "
1925,485,"make is whether to use an a, b, or c as the first character. After that, we have a subproblem to solve: find all 
permutations of the remaining characters, and append those to the already picked ""prefix:' 
P(a->2 I b->4 I c->1) ={a + P(a->1 I b->4 I c->1)} + 
{b + P(a->2 I b->3 I c->1)} + 
{c + P(a-"
1926,498,"P(a->2 I b->3 I c->1) {a + P(a->1 I b->3 I c->l)} + 
{b + P(a->2 I b->2 I c->1)} + 
{c + P(a->2 I b->3 I c->0)} 
P(a->2 I b->4 I c->0) ={a + P(a->1 I b->4 I c->0)} + 
{b + P(a->2 I b->3 I c->0)} 
Eventually, we'll get down to no more characters remaining. 
The code below implements this algorithm. 
"
1927,470,"4 printPerms(map, '""', s.length(), result); 
5 return result; 
6 } 
7 
8 HashMap<Character, Integer> buildFreqTable(String s) { 
9 HashMap<Character, Integer> map= new HashMap<Character, Integer>(); 
10 for (char c : s.toCharArray()) { 
11 if (!map.containsKey(c)) { 
12 map.put(c, 0); 
13 } 
14 map."
1928,286,"20 ArrayList<String> result) { 
21 /* Base case. Permutation has been completed. */ 
22 if (remaining== 0) { 
23 result.add(prefix); 
24 return; 
25 } 
26 
27 /* Try remaining letters for next char, and generate remaining permutations. */ 
358 Cracking the Coding Interview, 6th Edition"
1929,492,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
28 for (Character c : map.keySet()) { 
29 int count= map.get(c); 
39 if (count > 0) { 
31 map.put(c, count - 1); 
32 printPerms(map, prefix + c, remaining - 1, result); 
33 map.put(c, count); 
34 } 
35 } 
36 } 
In situations where the strin"
1930,434,"of n pairs of parentheses. 
EXAMPLE 
Input: 3 
Output: (( () ) ) , ( () () ) , ( () ) () , () ( () ) , () () () 
pg 136
SOLUTION 
Our first thought here might be to apply a recursive approach where we build the solution for f(n) by 
adding pairs of parentheses to f (n-1). That's certainly a good ins"
1931,481,"(()) ()() 
(())() () () () 
We can do this by inserting a pair of parentheses inside every existing pair of parentheses, as well as one 
at the beginning of the string. Any other places that we could insert parentheses, such as at the end of the 
string, would reduce to the earlier cases. 
So, we ha"
1932,510,"-> ()(()) /* inser ted pair at beginning of string*/ 
() () -> (())() /* inserted pair after 1st left paren */ 
-> ()(()) /* inserted pair after 2nd left paren */ 
-> () () () /* inserted pair at beginning of string*/ 
But wait-we have some duplicate pairs listed. The string () ( ()) is listed twice"
1933,268,"2 Set<String> set= new HashSet<String>(); 
3 if (remaining== 0) { 
4 set.add(""""); 
5 } else { 
6 Set<String> prev = generateParens(remaining - 1); 
7 for (String str : prev) { 
8 for (int i= 0; i < str.length(); i++) { 
CrackingTheCodinglnterview.com \ 6th Edition 359"
1934,492,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
9 
10 
11 
12 
13 
14 
if (str.charAt(i) == '(') { 
String s= insertlnside(str, i); 
/*Add s to set if it's not already in there. Note: HashSet 
* automatically checks for duplicates before adding, so an explicit
* check is not necessary. *"
1935,423,"24 String left = str.substring(0, leftlndex + 1); 
25 String right = str.substring(leftindex + 1, str.length()); 
26 return left + ""()"" + right; 
27 } 
This works, but it's not very efficient. We waste a lot of time coming up with the duplicate strings. 
We can avoid this duplicate string issue by b"
1936,476,"left and right parens, as long as our expression stays valid. 
On each recursive call, we have the index for a particular character in the string. We need to select either a 
left or a right paren. When can we use a left paren, and when can we use a right paren? 
1. Left Paren: As long as we haven't"
1937,498,"syntax error? We will get a syntax error if there are more right parentheses than left.
So, we simply keep track of the number of left and right parentheses allowed. If there are left parens 
remaining, we'll insert a left paren and recurse. If there are more right parens remaining than left (i.e., "
1938,491,"2 int index) { 
3 if (leftRem < 0 I I rightRem < leftRem) return;// invalid state 
4 
5 if (leftRem == 0 && rightRem == 0) {/*Out of left and right parentheses */ 
6 list.add(String.copyValueOf(str)); 
7 } else { 
8 str[index] = '('; // Add left and recurse 
9 addParen(list, leftRem - 1, rightRem, s"
1939,262,"14 } 
15 
16 ArrayList<String> generateParens(int count) { 
17 char[] str = new char[count *2]; 
18 Arraylist<String> list = new Arraylist<String>(); 
19 addParen(list, count, count, str, 0); 
20 return list; 
21 } 
360 Cracking the Coding Interview, 6th Edition"
1940,508,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
Because we insert left and right parentheses at each index in the string, and we never repeat an index, each 
string is guaranteed to be unique. 
8.10 Paint Fill: Implement the""paint fill"" function that one might see on many image editing p"
1941,498,"pg 136 
SOLUTION 
First, let's visualize how this method works. When we call paintFill (i.e., ""click"" paint fill in the image 
editing application) on, say, a green pixel, we want to""bleed"" outwards. Pixel by pixel, we expand outwards 
by calling paintFill on the surrounding pixel. When we hit a pix"
1942,509,"4 if (screen[r][c] == ncolor) return false; 
5 return PaintFill(screen, r, c, screen[r][c], ncolor); 
6 } 
7 
8 boolean PaintFill(Color[][] screen, int r, int c, Color ocolor, Color ncolor) { 
9 if (r < 0 I I r >= screen.length II c < 0 I I c >= screen[0].length) { 
10 return false; 
11 } 
12 
13 
1"
1943,489,"PaintFill(screen, r, C + 
} 
return true; 
} 
{ 
c, ocolor, ncolor); II up 
c, ocolor, ncolor); II down 
1, ocolor, ncolor); II left 
1, ocolor, ncolor); II right 
If you used the variable names x and y to implement this, be careful about the ordering of the variables in 
screen [y] [x]. Because x r"
1944,510,"place to make a mistake in an interview, as well as in your daily coding. It's typically clearer to use row and 
column instead, as we've done here. 
Does this algorithm seem familiar? It should! This is essentially depth-first search on a graph. At each pixel. 
we are searching outwards to each sur"
1945,492,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
8.11 Coins: Given an infinite number of quarters (25 cents), dimes (1 O cents), nickels (5 cents), and 
pennies (1 cent), write code to calculate the number of ways of representing n cents. 
pg 136 
SOLUTION 
This is a recursive problem, so"
1946,442,"relationship between this problem and its subproblems? 
We know that making change for 100 cents will involve either 0, 1, 2, 3, or 4 quarters. So: 
makeChange(100) = makeChange(100 using 0 quarters)+ 
makeChange(100 using 1 quarter) + 
makeChange(100 using 2 quarters)+ 
makeChange(100 using 3 quart"
1947,507,"using 1 quarter) will equalmakeChange(75 using 0 quarters). This is because,if we must use 
exactly one quarter to make change for 100 cents, then our only remaining choices involve making change 
for the remaining 75 cents. 
We can apply thesame logic tomakeChange(100 using 2 quarters),makeChange(1"
1948,445,"makeChange(75 using 0 quarters)+ 
makeChange(50 using 0 quarters)+ 
makeChange(25 using 0 quarters)+ 
1 
Note that the final statement from above, makeChange(100 using 4 quarters), equals 1. We call 
this ""fully reduced:' 
Now what? We've used up all our quarters, so now we can start applying our ne"
1949,478,"above statement. So, for the first part, we get the following statements: 
makeChange(100 using 0 quarters)= makeChange(100 using 0 quarters, 0 dimes)+ 
makeChange(l00 using 0 quarters, 1 dime) + 
makeChange(100 using 0 quarters, 2 dimes)+ 
makeChange(75 using 0 quarters) 
makeChange(50 using 0 quar"
1950,261,"makeChange(75 using 0 quarters, 2 dimes)+ 
makeChange(75 using 0 quarters, 7 dimes) 
makeChange(50 using 0 quarters, 0 dimes)+ 
makeChange(50 using 0 quarters, 1 dime) + 
makeChange(50 using 0 quarters, 2 dimes)+ 
3 62 Cracking the Coding Interview, 6th Edition"
1951,433,"Solutions to Chapter 8 l Recursion and Dynamic Programming 
makeChange(50 using 0 quarters, 5 dimes) 
make(hange(25 using 0 quarters)= makeChange(25 using 0 quarters, 0 dimes)+ 
makeChange(25 using 0 quarters, 1 dime) + 
makeChange(25 using 0 quarters, 2 dimes) 
Each one of these, in turn, expands o"
1952,459,"structure where each call expands out to four or more calls. 
The base case of our recursion is the fully reduced statement. For example, makeChange(50 using 0 
quarters, 5 dimes) is fully reduced to 1, since 5 dimes equals 50 cents. 
This leads to a recursive algorithm that looks like this: 
1 int "
1953,460,"3 int denomAmount denoms[index]; 
4 int ways = 0; 
5 for (int i= 0; i * denomAmount <= amount; i++) { 
6 int amountRemaining = amount - i * denomAmount; 
7 ways+= makeChange(amountRemaining, denoms, index + 1); 
8 } 
9 return ways; 
10 } 
11 
12 int makeChange(int n) { 
13 int[] denoms = {25, 10, 5,"
1954,462,"several times for the same values of amount and index. 
We can resolve this issue by storing the previously computed values. We'll need to store a mapping from 
each pair ( amount, index) to the precomputed result. 
1 int makeChange(int n) { 
2 int[] denoms = {25, 10, 5, l}; 
3 int[][] map = new int"
1955,491,"8 if (map[amount][index] > 0) {//retrieve value 
9 return map[amount][index]; 
10 } 
11 if (index >= denoms.length - 1) return 1; // one denom remaining 
12 int denomAmount denoms[index]; 
13 int ways = 0; 
14 for (int i= 0; i * denomAmount <= amount; i++) { 
15 //go to next denom, assuming i coins "
1956,108,"18 } 
19 map[amount][index] = ways; 
20 return ways; 
21 } 
CrackingTheCodinglnterview.com I 6th Edition 363"
1957,410,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
Note that we've used a two-dimensional array of integers to store the previously computed values. This is 
simpler, but takes up a little extra space. Alternatively, we could use an actual hash table that maps from 
amount to a new hash tab"
1958,510,"alternative data structures as well. 
8.12 Eight Queens:Write an algorithm to print all ways of arranging eight queens on an 8x8 chess board 
so that none of them share the same row, column, or diagonal. In this case, ""diagonal"" means all 
diagonals, not just the two that bisect the board. 
pg 736
S"
1959,498,"• 
A ""Solved"" Board with 8 Queens 
Picture the queen that is placed last, which we'll assume is on row 8. (This is an okay assumption to make 
since the ordering of placing the queens is irrelevant.) On which cell in row 8 is this queen? There are eight 
possibilities, one for each column. 
So if we"
1960,451,"ways to arrange 8 queens on an 8x8 board with queen at (7, 1) + 
ways to arrange 8 queens on an 8x8 board with queen at (7, 2) + 
ways to arrange 8 queens on an 8x8 board with queen at (7, 3) + 
ways to arrange 8 queens on an 8x8 board with queen at (7, 4) + 
ways to arrange 8 queens on an 8x8 board"
1961,494,"ways to arrange 8 queens on an 8x8 board with queen at (7, 7) 
We can compute each one of these using a very similar approach: 
ways to arrange 8 queens on an 8x8 board with queen at (7, 3) 
ways to with queens at (7, 3) and (6, 0) + 
ways to with queens at (7, 3) and (6, 1) + 
ways to with queens a"
1962,280,"ways to with queens at (7, 3) and (6, 7) 
Note that we don't need to consider combinations with queens at ( 7, 3) and ( 6, 
tion of the requirement that every queen is in its own row, column and diagonal. 
364 Cracking the Coding Interview, 6th Edition 
3), since this is a viola-"
1963,507,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
Implementing this is now reasonably straightforward. 
1 int GRID_SIZE = 8; 
2 
3 void placeQueens(int row, Integer[] columns, Arraylist<Integer[]> results) { 
4 if (row == GRID_SIZE) {//Found valid placement 
5 results.add(columns.clone());"
1964,469,"11 } 
12 } 
13 } 
14 } 
15 
16 /* Check if (rowl, column!) is a valid spot for a queen by checking if there is a 
17 * queen in the same column or diagonal. We don't need to check it for queens in
18 * the same row because the calling placeQueen only attempts to place one queen at
19 * a time. We kn"
1965,509,"22 int column2 = columns[row2]; 
23 /* Check if (row2, column2) invalidates (rowl, columnl) as a 
24 * queen spot. */
25 
26 /* Check if rows have a queen in the same column */ 
27 if (columnl == column2) { 
28 return false; 
29 } 
30 
31 /* Check diagonals: if the distance between the columns equal"
1966,383,"36 int rowDistance = rowl - row2; 
37 if (columnDistance == rowDistance) { 
38 return false; 
39 } 
40 } 
41 return true; 
42 } 
Observe that since each row can only have one queen, we don't need to store our board as a full 8x8 matrix. 
We only need a single array where column [ r] = c indicates th"
1967,474,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
8.13 Stack of Boxes: You have a stack of n boxes, with widths w1, heights hi, and depths di. The boxes 
cannot be rotated and can only be stacked on top of one another if each box in the stack is strictly 
larger than the box above it in wi"
1968,502,"pg 136
SOLUTION 
To tackle this problem, we need to recognize the relationship between the different subproblems. 
Solution#1 
Imagine we had the following boxes: b1 , 
b2 , ••• , bn. The biggest stack that we can build with all the 
boxes equals the max of (biggest stack with bottom b1, biggest sta"
1969,426,"with each, we would find the biggest stack possible. 
But, how would we find the biggest stack with a particular bottom? Essentially the same way. We experi­
ment with different boxes for the second level, and so on for each level. 
Of course, we only experiment with valid boxes. If b5 is bigger tha"
1970,490,"We can perform a small optimization here. The requirements of this problem stipulate that the lower boxes 
must be strictly greater than the higher boxes in all dimensions. Therefore, if we sort (descending order) the 
boxes on a dimension-any dimension-then we know we don't have to look backwards i"
1971,500,"The code below implements this algorithm recursively. 
1 int createSta ck(ArrayList<Box> boxes) { 
2 /* Sort in decending order by height. */ 
3 Collections.sort(boxes, new BoxComparator()); 
4 int maxHeight = 0; 
5 for (int i= 0; i < boxes.size(); i++) { 
6 int height = createSta ck(boxes, i); 
7 m"
1972,425,"13 Box bottom = boxes.get(bottomindex); 
14 int maxHeight = 0; 
15 for (inti= bottomlndex + 1; i < boxes.size(); i++) { 
16 if (boxes.get(i).canBeAbove(bottom)) { 
17 int height= createStack(boxes, i); 
18 maxHeight = Math.max(h eight, maxHeight); 
19 } 
20 } 
21 maxHeight T= bottom.height; 
22 retu"
1973,500,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
26 @Override 
27 public int compare(Box x, Box y){ 
28 return y.height - x.height; 
29 } 
30 } 
The problem in this code is that it gets very inefficient. We try to find the best solution that looks like { b3, 
b4, ••• } even though we may "
1974,506,"1 int createStack( ArrayList<Box> boxes) { 
2 Collections.sort(boxes, new BoxComparator()); 
3 int maxHeight = 0; 
4 int[] stackMap = new int[boxes.size()]; 
5 for (int i= 0; i < boxes.size(); i++) { 
6 int height = createStack(boxes, i, stackMap); 
7 maxHeight = Math.max(maxHeight, height); 
8 } 
9"
1975,412,"14 return stackMap[bottomindex]; 
15 } 
16 
17 Box bottom = boxes.get(bottomindex); 
18 int maxHeight = 0; 
19 for (int i= bottomindex + 1; i < boxes.size(); i++) { 
20 if (boxes.get(i).canBeAbove(bottom)) { 
21 int height= createStack(boxes, i, stackMap); 
22 maxHeight = Math.max(height, maxHeight)"
1976,413,"27 return maxHeight; 
28 } 
Because we're only mapping from an index to a height, we can just use an integer array for our""hash table:' 
Be very careful here with what each spot in the hash table represents. In this code, stackMap [ i] repre­
sents the tallest stack with box i at the bottom. Before "
1977,442,"ensure that box i can be placed on top of the current bottom. 
It helps to keep the line that recalls from the hash table symmetric with the one that inserts. For example, in 
this code, we recall from the hash table with bottomindex at the start of the method. We insert into the 
hash table with bo"
1978,349,"a particular box in the stack. (We will again sort our boxes in descending order by a dimension, such as 
height.) 
First, we choose whether or not to put box O in the stack. Take one recursive path with box Oat the bottom 
and one recursive path without box 0. Return the better of the two options. "
1979,467,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
Then, we choose whether or not to put box 1 in the stack. Take one recursive path with box 1 at the bottom 
and one path without box 1. Return the better of the two options. 
We will again use memoization to cache the height of the tallest "
1980,504,"3 int[] stackMap = new int[boxes.size()]; 
4 return createStack(boxes, null, 0, stackMap); 
5 } 
7 int createStack(ArrayList<Box> boxes, Box bottom, int offset, int[] stackMap) { 
8 if (offset >= boxes.size()) return 0; // Base case 
9 
10 /* height with this bottom*/ 
11 Box newBottom = boxes.get(o"
1981,481,"16 stackMap[offset] += newBottom.height; 
17 } 
18 heightWithBottom = stackMap[offset]; 
19 } 
20 
21 /* without this bottom*/ 
22 int heightWithoutBottom createStack(boxes, bottom, offset+ 1, stackMap); 
23 
24 
25 
26 } 
/* Return better of two options. */ 
return Math.max(heightWithBottom, height"
1982,500,"are symmetric, as they are in lines 15 and 16-18. 
8.14 Boolean Evaluation: Given a boolean expression consisting of the symbols 0 (false), 1 (true), & 
(AND), I (OR), and /\ (XOR), and a desired boolean result value result, implement a function to 
count the number of ways of parenthesizing the exp"
1983,467,"EXAMPLE 
countEval(""l/\01011"", false) -> 2 
countEval(""0&0&0&1All0"", true)-> 10 
SOLUTION 
pg 136 
As in other recursive problems, the key to this problem is to figure out the relationship between a problem 
and its subproblems. 
Brute Force 
Consider an expression like 0""0&0""111 and the target resu"
1984,46,"368 Cracking the Coding Interview, 6th Edition"
1985,425,"Solutions to Chapter 8 J Recursion and Dynamic Programming 
countEval(0A0&0Alll, true)= 
countEval(0/\0&0/\lll where paren around char 1, true) 
+ countEval(0/\0&0/\lll where paren around char 3, true)
+ countEval(0/\0&0/\lll where paren around char S, true)
+ countEval(0/\0&0/\lll where paren aroun"
1986,503,"In order to make that expression true, both the left and right sides must be true. So: 
left= ""0""0"" 
right = ""0/\111"" 
countEval(left & right, true)= countEval(left, true)* countEval(right, true) 
The reason we multiply the results of the left and right sides is that each result from the two sides c"
1987,462,"What happens when we have an ""l""(OR)? Or an""A""(XOR)? 
If it's an OR, then either the left or the right side must be true-or both. 
countEval(left I right, true) countEval(left, true) * countEval(right, false) 
+ countEval(left, false)* countEval(right, true)
+ countEval(left, true) * countEval(right"
1988,485,"+ countEval(left, false) * countEval(right, true)
What if we were trying to make the result false instead? We can switch up the logic from above: 
countEval(left & right, false) countEval(left, true) * countEval(right, false) 
+ countEval(left, false) * countEval(right, true)
countEval(left right, f"
1989,510,"countEval(left, false)* countEval(right, false)
+ countEval(left, true) * countEval(right, true)
Alternatively, we can just use the same logic from above and subtract it out from the total number of ways 
of evaluating the expression. 
totalEval(left) = countEval(left, true)+ countEval(left, false) "
1990,480,"This makes the code a bit more concise. 
1 int countEval(String s, boolean result) { 
2 if (s.length() 0) return 0; 
3 if (s.length() == 1) return stringToBool(s) 
4 
5 int ways= 0; 
6 for (int i= 1; i < s.length(); i += 2) { 
7 char c = s.charAt(i); 
8 String left= s.substring(0, i); 
result ? 1 
9"
1991,140,"13 int leftFalse countEval(left, false); 
14 int rightTrue = countEval(right, true); 
0· , 
CrackingTheCodinglnterview.com I 6th Edition 369"
1992,466,"Solutions to Chapter 8 I Recursion and Dynamic Programming 
15 int rightFalse = countEval(right, false); 
16 int total= (leftTrue + leftFalse) * (rightTrue + rightFalse); 
17 
18 int totalTrue = 0; 
19 if (c == 'A') { II required: one true and one false 
20 totalTrue = leftTrue * rightFalse + leftFa"
1993,452,"23 } else if (c == 'I') { II required: anything but both false 
24 totalTrue = leftTrue * rightTrue + leftFalse * rightTrue + 
25 leftTrue * rightFalse; 
26 } 
27 
28 int subways= result? totalTrue total - totalTrue; 
29 ways+= subways; 
30 } 
31 
32 return ways; 
33 } 
34 
35 boolean stringToBool(S"
1994,506,"{leftTrue, rightTrue, leftFalse, and rightFalse} values upfront, is a small amount of 
extra work in some cases. For example, if we're looking for the ways that an AND(&) can result in true, we 
never would have needed the left Fa 1 se and right Fa 1 se results. Likewise, if we're looking for the wa"
1995,455,"the values. This is probably a reasonable tradeoff to make (especially given the constraints of whiteboard 
coding) as it makes our code substantially shorter and less tedious to write. Whichever approach you make, 
you should discuss the tradeoffs with your interviewer. 
That said, there are more i"
1996,477,"Consider the expression 0/\0&0/\1 I 1 and these recursion paths: 
Add parens around char 1. (0}A(0&0/\1 I 1) 
» Add parens around char 3. ( 0) /\(( 0)&( 0/\111))
• Add parens around char 3. (0/\0)&(0/\1 I 1)
» Add parens around char 1. (( 0}A ( 0) )&( 0/\111)
Although these two expressions are diffe"
1997,371,"countEval (expression, result) for each expression and result. If we see an expression that we've 
calculated before, we just return it from the cache. 
1 int count�val(String s, boolean result, HashMap<String, Integer> memo) { 
2 if (s.length() 0) return 0; 
3 if (s.length() == 1) return stringToBo"
1998,497,"4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 } 
Solutions to Chapter 8 I Recursion and Dynamic Programming 
if (memo.contain sKey(result + s)) return memo.get(result + s); 
int ways 0; 
for (inti= 1; 1 < s.length(); i += 2) { 
c"
1999,474,"int leftFalse = countEval(left, false, memo); 
int rightTrue = countEval(right, true, memo); 
int rightFalse = countEval(right, false, memo); 
int total= (leftTrue + leftFalse) * (rightTrue + rightFalse); 
int totalTrue = 0; 
if ( C == ''"" ) { 
totalTrue = leftTrue * rightFalse + leftFalse * rightTr"
2000,504,"leftTrue * rightFalse; 
int subways = result ? totalTrue total - totalTrue; 
ways += subways; 
memo.put(result + s, ways); 
return ways; 
The added benefit of this is that we could actually end up with the same substring in multiple parts of the 
expression. For example, an expression like 0""1 ""0&0"""
2001,471,"expression after computing it for the left. 
There is one further optimization we can make, but it's far beyond the scope of the interview. There is
a closed form expression for the number of ways of parenthesizing an expression, but you wouldn't be 
expected to know it. It is given by the Catalan n"
2002,202,"leftTrue and leftFalse, we just compute one of those and calculate the other using the Catalan 
numbers. We would do the same thing for the right side. 
Cr ackingTheCodinglnterview.com I 6th Edition 371"
2003,442,"9 
Solutions to System Design and Scalability 
9.1 Stock Data: Imagine you are building some sort of service that will be called by up to 1,000 client 
applications to get simple end-of-day stock price information (open, close, high, low). You may 
assume that you already have the data, and you can "
2004,443,"responsible for the development, rollout, and ongoing monitoring and maintenance of the feed. 
Describe the different methods you considered and why you would recommend your approach. 
Your service can use any technologies you wish, and can distribute the information to the client 
applications in a"
2005,411,"clients. We can assume that we have some scripts that magically collect the information. 
We want to start off by thinking about what the different aspects we should consider in a given proposal 
are: 
• Client Ease of Use: We want the service to be easy for the clients to implement and useful for t"
2006,435,"unnecessary work on ourselves. We need to consider in this not only the cost of implementing, but also
the cost of maintenance.
Flexibility for Future Demands: This problem is stated in a ""what would you do in the real world"" way,
so we should think like we would in a real-world problem. Ideally, we"
2007,417,"• Scalability and Efficiency: We should be mindful of the efficiency of our solution, so as not to overly
burden our service.
With this framework in mind, we can consider various proposals. 
Proposal #1 
One option is that we could keep the data in simple text files and let clients download the data"
2008,226,"backed up, but it would require more complex parsing to do any sort of query. And, if additional data were 
added to our text file, it might break the clients' parsing mechanism. 
372 Cracking the Coding Interview, 6th Edition"
2009,491,"Solutions to Chapter 9 I System Design and Scalability 
Proposal #2 
We could use a standard SQL database, and let the clients plug directly into that. This would provide the 
following benefits: 
Facilitates an easy way for the clients to do query processing over the data, in case there are additio"
2010,472,"• Rolling back, backing up data, and security could be provided using standard database features. We
don't have to ""reinvent the wheel;' so it's easy for us to implement.
Reasonably easy for the clients to integrate into existing applications. SQL integration is a standard
feature in software develo"
2011,445,"backend to support a feed of a few bits of information. 
It's difficult for humans to be able to read it, so we'll likely need to implement an additional layer to view 
and maintain the data. This increases our implementation costs. 
• Security: While a SQL database offers pretty well defined securi"
2012,489,"anything ""malicious;' they might perform expensive and inefficient queries, and our servers would bear
the costs of that.
These disadvantages don't mean that we shouldn't provide SQL access. Rather, they mean that we should 
be aware of the disadvantages. 
Proposal #3 
XML is another great option fo"
2013,449,"l <root> 
2 <date value=""2008-10-12""> 
3 <company name=""foo""> 
4 <open>l26.23</open> 
5 <high>130.27</high> 
6 <low>122.83</low> 
7 <closingPrice>127.30</closingPrice> 
8 </company> 
9 <company name=""bar""> 
10 <open>52.73</open> 
11 <high>60.27</high> 
12 <low>50.29</low> 
13 <closingPrice>54.91</cl"
2014,384,"The advantages of this approach include the following: 
It's very easy to distribute, and it can also be easily read by both machines and humans. This is one 
reason that XML is a standard data model to share and distribute data. 
Most languages have a library to perform XML parsing, so it's reasona"
2015,406,"Solutions to Chapter 9 I System Design and Scalability 
• We can add new data to the XML file by adding additional nodes. This would not break the client's parser
(provided they have implemented their parser in a reasonable way).
• Since the data is being stored as XML files, we can use existing too"
2016,484,"The disadvantages may include: 
• This solution sends the clients all the information, even if they only want part of it. It is inefficient in that
way.
Performing any queries on the data requires parsing the entire file.
Regardless of which solution we use for data storage, we could provide a web s"
2017,419,"easier for clients to integrate the system. 
However-and this is a pro and a con-clients will be limited to grabbing the data only how we expect or 
want them to. By contrast, in a pure SQL implementation, clients could query for the highest stock price, 
even if this wasn't a procedure we ""expected"
2018,498,"bad choice, but you can make a compelling argument for the SQL or XML solution, with or without a web 
service. 
The goal of a question like this is not to see if you get the ""correct"" answer (there is no single correct answer). 
Rather, it's to see how you design a system, and how you evaluate trad"
2019,493,"between two people (e.g., Me-> Bob-> Susan-> Jason-> You). 
pg 145 
SOLUTION 
A good way to approach this problem is to remove some of the constraints and solve it for that situation 
first. 
Step 1: Simplify the Problem-Forget About the Millions of Users 
First, let's forget that we're dealing with"
2020,484,"cate that the two users are friends. 
If I wanted to find the path between two people, I could start with one person and do a simple breadth-first 
search. 
Why wouldn't a depth-first search work well? First, depth-first search would just find a path. It wouldn't 
necessarily find the shortest path."
2021,333,"before finding this relatively immediate connection. 
Alternatively, I could do what's called a bidirectional breadth-first search. This means doing two breadth­
first searches, one from the source and one from the destination. When the searches collide, we know we've 
found a path. 
3 7 4 Cracking "
2022,457,"Solutions to Chapter 9 I System Design and Scalability 
In the implementation, we'll use two classes to help us. BFSData holds the data we need for a breadth-first 
search, such as the isVisi ted hash table and the toVisi t queue. PathNode will represent the path as 
we're searching it, storing each"
2023,502,"2 int destination) { 
3 BFSData sourceData = new BFSData(people.get(source)); 
4 BFSData destData = new BFSData(people.get(destination)); 
5 
6 while (!sourceData.isFinished() && !destData.isFinished()) { 
7 /* Search out from source. */ 
8 Person collision = searchlevel(people, sourceData, destData"
2024,503,"14 collision = searchlevel(people, destData, sourceData); 
15 if (collision != null) { 
16 return mergePaths(sourceData, destData, collision.getID()); 
17 } 
18 } 
19 return null; 
20 } 
21 
22 /* Search one level and return collision, if any. */ 
23 Person searchLevel(HashMap<Integer, Person> peopl"
2025,506,"27 * to add nodes to the end. */
28 int count = primary.toVisit.size();
29 for (int i= 0; i < count; i++) {
30 /*Pull out first node. */ 
31 PathNode pathNode = primary.toVisit.poll(); 
32 int personld = pathNode.getPerson().getID(); 
33 
34 /* Check if it's already been visited. */ 
35 if (secondar"
2026,397,"41 Arraylist<Integer> friends = person.getFriends(); 
42 for (int friendid : friends) { 
43 if (!primary.visited.containsKey(friendid)) { 
44 Person friend= people.get(friendld); 
45 PathNode next = new PathNode(friend, pathNode); 
46 primary.visited.put(friendld, next); 
47 primary.toVisit.add(next"
2027,492,"Solutions to Chapter 9 I System Design and Scalability 
54 /* Merge paths where searches met at connection. */ 
55 Linkedlist<Person> mergePaths(BFSData bfsl, BFSData bfs2, int connection) { 
56 PathNode endl = bfsl.visited.get(connection); // endl -> source 
57 PathNode end2 = bfs2.visited.get(conn"
2028,500,"60 pathTwo.removeFirst(); // remove connection 
61 pathOne.addAll(pathTwo); // add second path 
62 return pathOne; 
63 } 
64 
65 class PathNode { 
66 private Person person = null; 
67 private PathNode previousNode = null; 
68 public PathNode(Person p, PathNode previous) { 
69 person = p; 
70 previou"
2029,490,"76 Linkedlist<Person> path= new Linkedlist<Person>(); 
77 PathNode node = this; 
78 while (node != null) { 
79 if (startsWithRoot) { 
80 path.addlast(node.person); 
81 } else { 
82 path.addFirst(node.person); 
83 } 
84 node = node.previousNode; 
85 } 
86 return path; 
87 } 
88 } 
89 
90 class BFSDat"
2030,417,"94 
95 public BFSData(Person root) { 
96 PathNode sourcePath = new PathNode(root, null); 
97 toVisit.add(sourcePath); 
98 visited.put(root.getID(), sourcePath); 
99 } 
100 
101 public boolean isFinished() { 
102 return toVisit.isEmpty(); 
103 } 
104} 
Many people are surprised that this is faster. S"
2031,186,"• Traditional breadth-first search from S to D: We go through roughly k+k*k nodes: each of S's k friends,
and then each of their k friends.
376 Cracking the Coding Interview, 6th Edition"
2032,438,"Solutions to Chapter 9 I System Design and Scalability 
Bidirectional breadth-first search: We go through 2k nodes: each of S's k friends and each ofD's k friends. 
Of course, 2k is much less than k+k*k. 
Generalizing this to a path of length q, we have this: 
BFS: O(kq) 
Bidirectional BFS: 0( kq12 "
2033,470,"BFS will require looking at 100 million (1004) nodes. A bidirectional BFS will require looking at only 20,000 
nodes (2 x 1002). 
A bidirectional BFS will generally be faster than the traditional BFS. However, it requires actually having 
access to both the source node and the destination nodes, whi"
2034,423,"one machine. That means that our simple Person data structure from above doesn't quite work-our 
friends may not live on the same machine as we do. Instead, we can replace our list of friends with a list of 
their IDs, and traverse as follows: 
1. For each friend ID: int machine index = getMachineID"
2035,495,"The code below outlines this process. We've defined a class Server, which holds a list of all the machines, 
and a class Machine, which represents a single machine. Both classes have hash tables to efficiently lookup 
data. 
1 class Server { 
2 HashMap<Integer, Machine> machines = new HashMap<Intege"
2036,509,"6 return machines.get(machineID); 
7 } 
8 
9 public int getMachineIDForUser(int personID) { 
10 Integer machineID = personToMachineMap.get(personID); 
11 return machineID == null ? -1 : machineID; 
12 } 
13 
14 public Person getPersonWithID(int personID) { 
15 Integer machineID = personToMachineMap."
2037,132,"20 
21 return machine.getPersonWithID(personID); 
22 } 
23 }
24 
25 class Person { 
CrackingTheCodinglnterview.com J 6th Edition 377"
2038,495,"Solutions to Chapter 9 I System Design and Scalability 
26 private Arraylist<Integer> friends = new Arraylist<Integer>(); 
27 private int personID; 
28 private String info; 
29 
30 public Person(int id) { this.personID =id;} 
31 public String getinfo() { return info; } 
32 public void setinfo(String"
2039,459,"35 public void addFriend(int id) { friends.add(id); } 
36 } 
There are more optimizations and follow-up questions here than we could possibly discuss, but here are 
just a few possibilities. 
Optimization: Reduce machine jumps 
Jumping from one machine to another is expensive. Instead of randomly ju"
2040,425,"up all at once. 
Optimization: Smart division of people and machines 
People are much more likely to be friends with people who live in the same country as they do. Rather than 
randomly dividing people across machines, try to divide them by country, city, state, and so on. This will 
reduce the num"
2041,491,"this case? 
Usually, in BFS, we mark a node as visited by setting a visited flag in its node class. Here, we don't want to 
do that. There could be multiple searches going on at the same time, so it's a bad idea to just edit our data. 
Instead, we could mimic the marking of nodes with a hash table t"
2042,445,"How could you take advantage of caching? 
Do you search until the end of the graph (infinite)? How do you decide when to give up? 
In real life, some people have more friends of friends than others, and are therefore more likely to make 
a path between you and someone else. How could you use this da"
2043,377,"9.3 Web Crawler: If you were designing a web crawler, how would you avoid getting into infinite loops? 
pg 745 
SOLUTION 
The first thing to ask ourselves in this problem is how an infinite loop might occur. The simplest answer is 
that, if we picture the web as a graph of links, an infinite loop wi"
2044,506,"Solutions to Chapter 9 I System Design and Scalability 
To prevent infinite loops, we just need to detect cycles. One way to do this is to create a hash table where 
we set hash [ v] to true after we visit page v. 
We can crawl the web using breadth-first search. Each time we visit a page, we gather"
2045,477,"If it's defined based on its URL, we must recognize that URL parameters might indicate a completely 
different page. For example, the page www.careercup.com/page?pid=microsoft-interview­
questions is totally different from the pagewww.careercup. com/page ?pid=google-interview­
questions. But, we can"
2046,464,"careercup.c om?foobar=hello is the same as www.careerc up.com. 
""Okay, then;' you might say, ""let's define it based on its content:'That sounds good too, at first, but it also 
doesn't quite work. Suppose I have some randomly generated content on the careercup.com home page. 
Is it a different page "
2047,490,"gets tricky. 
One way to tackle this is to have some sort of estimation for degree of similarity. If, based on the content 
and the URL, a page is deemed to be sufficiently similar to other pages, we deprioritize crawling its children. 
For each page, we would come up with some sort of signature bas"
2048,441,"priority page to crawl. We then do the following: 
1. Open up the page and create a signature of the page based on specific subsections of the page and its
URL.
2. Query the database to see whether anything with this signature has been crawled recently.
3. If something with this signature has been r"
2049,478,"Under the above implementation, we never ""complete"" crawling the web, but we will avoid getting stuck 
in a loop of pages. If we want to allow for the possibility of ""finishing"" crawling the web (which would 
clearly happen only if the""web""were actually a smaller system, like an intranet), then we c"
2050,238,"more likely resemble a conversation with your interviewer which could take any number of paths. In fact, 
the discussion of this problem could have taken the path of the very next problem. 
CrackingTheCodinglnterview.com \ 6th Edition 379"
2051,488,"Solutions to Chapter 9 I System Design and Scalability 
9.4 Duplicate URLs: You have 10 billion URLs. How do you detect the duplicate documents? In this 
case, assume ""duplicate"" means that the URLs are identical. 
pg 745 
SOLUTION 
Just how much space do 1 O billion UR Ls take up? If each URL is an"
2052,507,"hold that much data in memory. 
But, let's just pretend for a moment that we were miraculously holding this data in memory, since it's useful 
to first construct a solution for the simple version. Under this version of the problem, we would just create a 
hash table where each URL maps to true if it"
2053,416,"time and offers few advantages.) 
Now that we have a solution for the simple version, what happens when we have all 4000 gigabytes of data 
and we can't store it all in memory? We could solve this either by storing some of the data on disk or by 
splitting up the data across machines. 
Solution #1: "
2054,504,"split the list of URLs into 4000 chunks of 1 GB each. An easy way to do that might be to store each URL u in 
a file named <x>. txt where x = hash ( u) % 4000. That is, we divide up the URLs based on their hash 
value (modulo the number of chunks). This way, all UR Ls with the same hash value would "
2055,454,"Solution #2: Multiple Machines 
The other solution is to perform essentially the same procedure, but to use multiple machines. In this solu­
tion, rather than storing the data in file< x>. txt, we would send the URL to machine x. 
Using multiple machines has pros and cons. 
The main pro is that we c"
2056,469,"The disadvantage though is that we are now relying on 4000 different machines to operate perfectly. That 
may not be realistic (particularly with more data and more machines), and we'll need to start considering 
how to handle failure. Additionally, we have increased the complexity of the system sim"
2057,432,"Solutions to Chapter 9 \ System Design and Scalability 
9.5 Cache: Imagine a web server for a simplified search engine. This system has 100 machines to 
respond to search queries, which may then call out using processSearch(string query) 
to another cluster of machines to actually get the result. Th"
2058,446,"th<> sam<> r<>quest. The method processSearch is very expensive. Design a caching mechanism 
to cache the results of the most recent queries. Be sure to explain how you would update the cache 
when data changes. 
pg 745 
SOLUTION 
Before getting into the design of this system, we first have to under"
2059,488,"tions for the purposes of this solution, but you should discuss these details-in depth-with your inter-
viewer. 
Assumptions 
Here are a few of the assumptions we make for this solution. Depending on the design of your system and 
how you approach the problem, you may make other assumptions. Remembe"
2060,484,"machine that was called. 
• The number of queries we wish to cache is large (millions).
• Calling between machines is relatively quick.
The result for a given query is an ordered list of URLs, each of which has an associated 50 character title
and 200 character summary.
The most popular queries are "
2061,479,"System Requirements 
When designing the cache, we know we'll need to support two primary functions: 
Efficient lookups given a key. 
Expiration of old data so that it can be replaced with new data. 
In addition, we must also handle updating or clearing the cache when the results for a query change. "
2062,478,"expire. 
Step 1: Design a Cache for a Single System 
A good way to approach this problem is to start by designing it for a single machine. So, how would you 
create a data structure that enables you to easily purge old data and also efficiently look up a value based 
on a key? 
• A linked list would"
2063,48,CrackingTheCodinglnterview.com \ 6th Edition 381
2064,440,"5olutions to Chapter 9 I System Design and Scalability 
• A hash table allows efficient lookups of data, but it wouldn't ordinarily allow easy data purging.
How can we get the best of both worlds? By merging the two data structures. Here's how this works: 
Just as before, we create a linked list whe"
2065,491,"In addition, we have a hash table that maps from a query to the corresponding node in the linked list. This 
allows us to not only efficiently return the cached results, but also to move the appropriate node to the 
front of the list, thereby updating its ""freshness."" 
For illustrative purposes, abb"
2066,461,"this as well as perform the design for the larger system. 
1 public class Cache { 
2 public static int MAX SIZE= 10; 
3 public Node head, tail; 
4 public HashMap<String, Node> map; 
5 public int size = 0; 
6 
7 public Cache() { 
8 map= new HashMap<String, Node>(); 
9 } 
10 
11 /* Moves node to front"
2067,484,"14 
15 /* Removes node from linked list */ 
16 public void removeFromlinkedlist(Node node) { ... } 
17 
18 /* Gets results from cache, and updates linked list */ 
19 public String[] getResults(String query) { 
20 if (!map.containsKey(query)) return null; 
21 
22 Node node = map.get(query); 
23 moveT"
2068,471,"28 public void insertResults(String query, String[] results) { 
29 if (map.containsKey(query)) {//update values 
30 Node node = map.get(query); 
31 node.results= results; 
32 moveToFront(node); // update freshness 
33 return; 
34 } 
35 
36 Node node = new Node(query, results); 
37 moveToFront(node);"
2069,505,"Solutions to Chapter 9 I System Design and Scalability 
44 } 
45 } 
Step 2: Expand to Many Machines 
Now that we understand how to design this for a single machine, we need to understand how we would 
design this when queries could be sent to many different machines. Recall from the problem statemen"
2070,487,"options to consider. 
Option 7: Each machine has its own cache. 
A simple option is to give each machine its own cache. This means that if""foo""is sent to machine 1 twice in 
a short amount of time, the result would be recalled from the cache on the second time. But, if""foo""is sent 
first to machine "
2071,500,"unfortunately, is somewhat less effective as an optimization tool as many repeat queries would be treated 
as fresh queries. 
Option 2: Each machine has a copy of the cache. 
On the other extreme, we could give each machine a complete copy of the cache. When new items are 
added to the cache, they a"
2072,433,"everywhere. The major drawback however is that updating the cache means firing off data to N different 
machines, where N is the size of the response cluster. Additionally, because each item effectively takes up N
times as much space, our cache would hold much less data. 
Option 3: Each machine stor"
2073,455,"machine i needs to look up the results for a query, machine i would figure out which machine holds this 
value, and then ask this other machine (machine j) to look up the query in j's cache. 
But how would machine i know which machine holds this part of the hash table? 
One option is to assign queri"
2074,478,"So, when a new query comes in to machine i, this machine would apply the formula and call out to machine 
j. Machine j would then return the value from its cache or call processSearch(query) to get the
results. Machine j would update its cache and return the results back to i.
Alternatively, you cou"
2075,188,"the results to machine j for storage. This implementation actually increases the number of machine-to­
machine calls, with few advantages. 
CrackingTheCodinglnterview.com I 6th Edition 383"
2076,464,"Solutions to Chapter 9 I System Design and Scalability 
Step 3: Updating results when contents change 
Recall that some queries may be so popular that, with a sufficiently large cache, they would permanently 
be cached. We need some sort of mechanism to allow cached results to be refreshed, either p"
2077,461,"your interviewer). The primary times would be when: 
1. The content at a URL changes (or the page at that URL is removed).
2. The ordering of results change in response to the rank of a page changing.
3. New pages appear related to a particular query.
To handle situations #1 and #2, we could create "
2078,499,"reside on different machines. However, this solution may require a lot of data. 
Alternatively, if the data doesn't require instant refreshing (which it probably doesn't), we could periodically 
crawl through the cache stored on each machine to purge queries tied to the updated URLs. 
Situation #3 i"
2079,472,"one-word queries. 
A good way to handle Situation #3 (and likely something we'd want to do anyway) is to implement an ""auto­
matic time-out"" on the cache. That is, we'd impose a time out where no query, regardless of how popular it 
is, can sit in the cache for more than x minutes. This will ensure "
2080,429,"tions you make and the situations you optimize for. 
One such optimization is to better support the situation where some queries are very popular. For example, 
suppose (as an extreme example) a particular string constitutes 1 % of all queries. Rather than machine i 
forwarding the request to machin"
2081,453,"then i could store the results in its own cache as well. 
Alternatively, there may also be some possibility of doing some sort of re-architecture of the system to 
assign queries to machines based on their hash value (and therefore the location of the cache), rather than 
randomly. However, this dec"
2082,441,"mechanism purges any data after X minutes. However, we may want to update some data (like current 
news) much more frequently than other data (like historical stock prices). We could implement timeouts 
based on topic or based on URLs. In the latter situation, each URL would have a time out value ba"
2083,374,"of the time outs for each URL. 
These are just a few of the enhancements we can make. Remember that in questions like this, there is no 
single correct way to solve the problem. These questions are about having a discussion with your inter­
viewer about design criteria and demonstrating your general"
2084,487,"Solutions to Chapter 9 I System Design and Scalability 
9.6 Sales Rank: A large eCommerce company wishes to list the best-selling products, overall and by 
category. For example, one product might be the #1056th best-selling product overall but the #13th 
best-selling product under ""Sports Equipment"
2085,441,"Step 1: Scope the Problem 
First, we need to define what exactly we're building. 
We'll assume that we're only being asked to design the components relevant to this question, and not 
the entire eCommerce system. In this case, we might touch the design of the frontend and purchase 
components, but o"
2086,480,"Last week? Or some more complicated function (such as one involving some sort of exponential decay 
of sales data)? This would be something to discuss with your interviewer. We will assume that it is simply 
the total sales over the past week. 
• We will assume that each product can be in multiple c"
2087,411,"Step 2: Make Reasonable Assumptions 
These are the sorts of things you'd want to discuss with your interviewer. Because we don't have an inter­
viewer in front of us, we'll have to make some assumptions. 
We will assume that the stats do not need to be 100% up-to-date. Data can be up to an hour old "
2088,491,"items. That is, few people would care if the #2,809,132th best-selling item should have actually been 
listed as #2,789, 158th instead. 
Precision is important for the most popular items, but a small degree of error is okay for the less popular 
items. 
We will assume that the data should be updated"
2089,498,"like 150 hours, that's okay. 
• We will assume that the categorizations are based strictly on the origin of the transaction (i.e., the seller's
name), not the price or date.
The important thing is not so much which decision you made at each possible issue, but whether it occurred 
to you that these "
2090,217,"Step 3: Draw the Major Components 
We should now design just a basic, naive system that describes the major components. This is where you 
would go up to a whiteboard. 
CrackingTheCodinglnterview.com J 6th Edition 385"
2091,502,"Solutions to Chapter 9 I System Design and Scalability 
purchase 
system 
sales rank 
data database 
In this simple design, we store every order as soon as it comes into the database. Every hour or so, we pull 
sales data from the database by category, compute the total sales, sort it, and store it "
2092,475,"Step 4: Identify the Key Issues 
Analytics are Expensive 
In the naive system, we periodically query the database for the number of sales in the past week for each 
product. This will be fairly expensive. That's running a query over all sales for all time. 
Our database just needs to track the total"
2093,494,"to focus on the sales data analytics. 
Instead of listing every purchase in our database, we'll store just the total sales from the last week. Each 
purchase will just update the total weekly sales. 
Tracking the total sales takes a bit of thought. If we just use a single column to track the total s"
2094,477,"Instead, we'll just use a table like this. 
This is essentially like a circular array. Each day, we clear out the corresponding day of the week. On each 
purchase, we update the total sales count for that product on that day of the week, as well as the total 
count. 
We will also need a separate tab"
2095,496,"Solutions to Chapter 9 I System Design and Scalability 
Database Writes are Very Frequent 
Even with this change, we'll still be hitting the database very frequently. With the amount of purchases that 
could come in every second, we'll probably want to batch up the database writes. 
Instead of immed"
2096,439,"gather the totals, and update the database. 
I 
We should quickly think about whether or not it's feasible to hold this in memory. If there are 10 
million products in the system, can we store each (along with a count) in a hash table?Yes. If each 
product ID is four bytes (which is big enough to ho"
2097,433,"Even with some additional overhead and substantial system growth, we would still be able to fit 
this all in memory. 
After updating the database, we can re-run the sales rank data. 
We need to be a bit careful here, though. If we process one product's logs before another's, and re-run the 
stats in"
2098,424,"than its ""competing"" product). 
We can resolve this by either ensuring that the sales rank doesn't run until all the stored data is processed 
(difficult to do when more and more purchases are coming in), or by dividing up the in-memory cache by 
some time period. If we update the database for all t"
2099,484,"Joins are Expensive 
We have potentially tens of thousands of product categories. For each category, we'll need to first pull the 
data for its items (possibly through an expensive join) and then sort those. 
Alternatively, we could just do one join of products and categories, such that each product"
2100,447,"to get the sales rank for each category. 
Total Sun M()rl · 
sportseq 13 4 4 19 322 32 232 
1423 safety 13 4 4 19 322 32 232 
Rather than running thousands of queries (one for each category), we could sort the data on the category 
first and then the sales volume. Then, if we walked those results, w"
2101,409,"We could also just keep the data in a table like this from the beginning, rather than doing joins. This would 
require us to update multiple rows for each product. 
Database Queries Might Still Be Expensive 
Alternatively, if the queries and writes get very expensive, we could consider forgoing a da"
2102,274,"Under this system, we would write a purchase to a simple text file with the product ID and time stamp. Each 
category has its own directory, and each purchase gets written to all the categories associated with that 
product. 
CrackingTheCodinglnterview.com I 6th Edition 387"
2103,485,"Solutions to Chapter 9 I System Design and Scalability 
We would run frequent jobs to merge files together by product ID and time ranges, so that eventually all 
purchases in a given day (or possibly hour) were grouped together. 
/sportsequipment 
1423,Dec 13 08:23-Dec 13 08:23,1 
4221,Dec 13 15:22-"
2104,478,"How do we get the overall ranking? There are two good approaches: 
• We could treat the general category as just another directory, and write every purchase to that directory.
That would mean a lot of files in this directory.
• Or, since we'll already have the products sorted by sales volume order f"
2105,445,"100% up-to-date. We just need the most popular items to be up-to-date. 
We can merge the most popular items from each category in a pairwise fashion. So, two categories get 
paired together and we merge the most popular items (the first 100 or so). After we have 100 items in this 
sorted order, we s"
2106,498,"One of the advantages of this is that it scales nicely. We can easily divide up the files across multiple servers, 
as they aren't dependent on each other. 
Follow Up Questions 
The interviewer could push this design in any number of directions. 
Where do you think you'd hit the next bottlenecks? Wh"
2107,491,"What if data needed to be more accurate? What if it needed to be accurate within 30 minutes for all
products?
Think through your design carefully and analyze it for the tradeoffs. You might also be asked to go into more 
detail on any specific aspect of the product. 
9.7 Personal Financial Manager: "
2108,169,"make recommendations. 
SOLUTION 
The first thing we need to do is define what it is exactly that we are building. 
388 Cracking the Coding Interview, 6th Edition 
pg 145"
2109,508,"Solutions to Chapter 9 I System Design and Scalability 
Step 1: Scope the Problem 
Ordinarily, you would clarify this system with your interviewer. We'll scope the problem as follows: 
, You create an account and add your bank accounts. You can add multiple bank accounts. You can also 
add them at a"
2110,507,"and other payments), and your current money (what's in your bank account and investments). 
Each payment transaction has a ""category"" associated with it (food, travel, clothing, etc.). 
There is some sort of data source provided that tells the system, with some reliability, which category a 
transac"
2111,511,"Users will use the system to get recommendations on their spending. These recommendations will 
come from a mix of ""typical"" users (""people generally shouldn't spend more than Xo/o of their income 
on clothing""), but can be overridden with custom budgets. This will not be a primary focus right now. "
2112,436,"a certain threshold, hitting a budget max, etc.).
We'll assume that there's no concept of user-specified rules for assigning categories to transactions.
This gives us a basic goal for what we 
want to build. 
Step 2: Make Reasonable Assumptions 
Now that we have the basic goal for the system, we sho"
2113,504,"• Adding or removing bank accounts is relatively unusual.
• The system is write-heavy. A typical user may make several new transactions 
daily, although few users
would access the website more than once a week. In fact, for many users, their primary interaction might
be through email alerts.
• Once "
2114,480,"change. This means that two otherwise identical transactions could be assigned to different categories
if the rules changed in between each transaction's date. We do this because it may confuse users if their
spending per category changes with no action on their part.
The banks probably won't push d"
2115,295,"realistic 
anyway, since we won't get the transaction data instantaneously.) It's probably pretty safe for
them to be up to 24 hours delayed.
It's okay to make different assumptions here, but you should explicitly state them to your interviewer. 
CrackingTheCodinglnterview.com I 6th Edition 389"
2116,482,"Solutions to Chapter 9 I System Design and Scalability 
Step 3: Draw the Major Components 
The most naive system would be one that pulls bank data on each login, categorizes all the data, and then 
analyzes the user's budget. This wouldn't quite fit the requirements, though, as we want email notific"
2117,510,"categorizer 
categorized 
transactions 
budget analyzer 
With this basic architecture, the bank data is pulled at periodic times (hourly or daily). The frequency may 
depend on the behavior of the users. Less active users may have their accounts checked less frequently. 
Once new data arrives, it is"
2118,488,"another datastore. 
The budget analyzer pulls in the categorized transactions, updates each user's budget per category, and 
stores the user's budget. 
The frontend pulls data from both the categorized transactions datastore as well as from the budget datas­
tore. Additionally, a user could also int"
2119,493,"We should now reflect on what the major issues here might be. 
This will be a very data-heavy system. We want it to feel snappy and responsive, though, so we'll want as 
much processing as possible to be asynchronous. 
We will almost certainly want at least one task queue, where we can queue up work"
2120,460,"bank data. It would also include re-trying tasks that failed. 
These tasks will likely have some sort of priority associated with them, as some need to be performed more 
ohen than others. We want to build a task queue system that can prioritize some task types over others, 
while still ensuring tha"
2121,262,"One important part of the system that we haven't yet addressed will be the email system. We could use a 
task to regularly crawl user's data to check if they're exceeding their budget, but that means checking every 
390 Cracking the Coding Interview, 6th Edition"
2122,507,"Solutions to Chapter 9 I System Design and Scalability 
single user daily. Instead, we'll want to queue a task whenever a transaction occurs that potentially exceeds 
a budget. We can store the current budget totals by category to make it easy to understand if a new transac­
tion exceeds the budget."
2123,494,"since. We may want to either remove them from the system entirely or deprioritize their accounts. We'll 
want some system to track their account activity and associate priority with their accounts. 
The biggest bottleneck in our system will likely be the massive amount of data that needs to be pulle"
2124,440,"Categorizer and Budget Analyzer 
One thing to note is that transactions are not dependent on each other. As soon as we get a transaction for 
a user, we can categorize it and integrate this data. It might be inefficient to do so, but it won't cause any 
inaccuracies. 
Should we use a standard databa"
2125,498,"It may be better instead to just store the transactions to a set of flat text files. We assumed earlier that the 
categorizations are based on the seller's name alone. If we're assuming a lot of users, then there will be a lot 
of duplicates across the sellers. If we group the transaction files by s"
2126,499,"categorized data, 
grouped by user 
merge & group by 
user & category 
update budgets 
update categorized 
transactions 
It first gets the raw transaction data, grouped by seller. It picks the appropriate category for the seller (which 
might be stored in a cache for the most common sellers), and th"
2127,83,"into the datastore for this user. 
CrackingTheCodinglnterview.com J 6th Edition 391"
2128,469,"Solutions to Chapter 9 I System Design and Scalability 
user121/ 
13 amazon,shopping,$5.43,Aug 13 
27 
comcast/ 
user922,$9.29,Aug 24 
user248,$40.13,Aug 18 
user922/ 
amazon,shopping,$15.39,Aug 27 
comcast,utilities,$9.29,Aug 24 
user248/ 
comcast,utilities,$40.13,Aug 18 
Then, the budget analyzer "
2129,458,"Most of these tasks will be handled in simple log files. Only the final data (the categorized transactions and 
the budget analysis) will be stored in a database. This minimizes writing and reading from the database. 
User Changing Categories 
The user might selectively override particular transacti"
2130,506,"putation of the budget to decrement the item from the old category and increment the item in the other 
category. 
We could also just recompute the budget from scratch. The budget analyzer is fairly quick as it just needs to 
look over the past few weeks of transactions for a single user. 
Follow Up"
2131,510,"How would you design the recommended budgets feature? 
How would you. change this if the user could develop rules to categorize all transactions from a partic­
ular seller differently than the default? 
9.8 Pastebin: Design a system like Pastebin, where a user can enter a piece of text and get a ran"
2132,314,"The system tracks analytics of how many times each page is accessed.
• Old documents get deleted after not being accessed for a sufficiently long period of time.
• While there isn't true authentication on accessing documents, users should not be able to ""guess"" docu-
392 Cracking the Coding Intervie"
2133,483,"Solutions to Chapter 9 I System Design and Scalability 
ment URLs easily. 
• The system has a frontend as well as an AP\.
The analytics for each URL can be accessed through a ""stats"" link on each page. It is not shown by default,
though.
Step 2: Make Reasonable Assumptions 
• The system gets heavy t"
2134,508,"Step 3: Draw the Major Components 
We can sketch out a simple design. We'll need to keep track of URLs and the files associated with them, as 
well as analytics for how often the files have been accessed. 
How should we store the documents? We have two options: we can store them in a database or we "
2135,442,"A simple design like this might work well: 
URL to File 
Database 
server with files 
server with files 
server with files 
Here, we have a simple database that looks up the location (server and path) of each file. When we have a 
request for a URL, we look up the location of the URL within the data"
2136,419,"each visit (including timestamp, IP address, and location) as a row in a database. When we need to access 
the stats of each visit, we pull the relevant data in from this database. 
Step 4: Identify the Key Issues 
The first issue that comes to mind is that some documents will be accessed much more "
2137,156,"Therefore, we probably want to use a cache to store the most recently accessed documents. This will ensure 
CrackingTheCodinglnterview.com I 6th Edition 393"
2138,474,"Solutions to Chapter 9 I System Design and Scalability 
that items accessed very frequently (or very recently) will be quickly accessible. Since documents cannot be 
edited, we will not need to worry about invalidating this cache. 
We should also potentially consider sharding the database. We can sh"
2139,492,"base which contains this file. 
In fact, we could even take this a step further. We could skip the database entirely and just let a hash of the 
URL indicate which server contains the document. The URL itself could reflect the location of the document. 
One potential issue from this is that if we ne"
2140,465,"increasing integer value, as this would be easy for a user to ""guess:' We want UR Ls to be difficult to access 
without being provided the link. 
One simple path is to generate a random GUID (e.g., Sd50e8ac-57cb-4a0d-8661-bcdee2548979). This is a 
128-bit value that while not strictly guaranteed to "
2141,418,"hash it to a smaller value, but then that increases the odds of collision.
We could do something very similar, though. We could just generate a 10-character sequence of letters 
and numbers, which gives us 3610 possible strings. Even with a billion URLs, the odds of a collision on any 
specific URL "
2142,411,"specific URL is unlikely to collide. However, after storing a billion URLs, we are very likely to have 
a collision at some point. 
Assuming that we aren't okay with periodic (even if unusual) data loss, we'll need to handle these collisions. 
We can either check the datastore to see if the URL exis"
2143,477,"detect whether a file already exists at the destination. 
When a collision occurs, we can just generate a new URL. With 3610 possible URLs, collisions would be rare 
enough that the lazy approach here (detect collisions and retry) is sufficient. 
Analytics 
The final component to discuss is the anal"
2144,504,"We have two options here: 
Store the raw data from each visit. 
• Store just the data we know we'll use (number of visits, etc.).
You can discuss this with your interviewer, but it probably makes sense to store the raw data. We never 
know what features we'll add to the analytics down the road. The "
2145,46,"394 Cracking the Coding Interview, 6th Edition"
2146,469,"Solutions to Chapter 9 l System Design and Sca\abi\ity 
One issue here is that this amount of data could be substantial. We could potentially reduce the space usage 
considerably by storing data only probabilistically. Each URL would have a storage_probabili ty asso­
ciated with it. As the popularit"
2147,484,"up the number of visits for the site, we'll need to adjust the value based on the probability (for example, by 
multiplying it by 10). This will of course lead to a small inaccuracy, but that may be acceptable. 
The log files are not designed to be used frequently. We will want to also store this pr"
2148,504,"separate database. 
12ab31b92p December 2013 242119 
12ab31b92p January 2014 429918 
Every time a URL is visited, we can increment the appropriate row and column. This datastore can also be 
sharded by the URL. 
As the stats are not listed on the regular pages and would generally be of less interest"
2149,268,"Follow-Up Questions 
How would you support user accounts? 
How would you add a new piece of analytics (e.g., referral source) to the stats page? 
How would your design change if the stats were shown with each document? 
CrackingTheCodinglnterview.com / 6th Edition 395"
2150,462,"10 
Solutions to Sorting and Searching 
10.1 Sorted Merge: You are given two sorted arrays, A and B, where A has a large enough buffer at the 
end to hold B. Write a method to merge B into A in sorted order. 
pg149
SOLUTION 
Since we know that A has enough buffer at the end, we won't need to allocat"
2151,507,"all elements in A and in B. 
The only issue with this is that if we insert an element into the front of A, then we'll have to shift the existing 
elements backwards to make room for it. It's better to insert elements into the back of the array, where 
there's empty space. 
The code below does just t"
2152,493,"3 int indexB = lastB - 1; /* Index of last element in array b */ 
4 int indexMerged = lastB + lastA - 1; /* end of merged array*/ 
5 
6 /* Merge a and b, starting from the last element in each */ 
7 while (indexB >= 0) { 
8 /* end of a is > than end of b */ 
9 if (indexA >= 0 && a[indexA] > b[indexB"
2153,215,"15 } 
16 indexMerged--; // move indices 
17 } 
18 } 
Note that you don't need to copy the contents of A after running out of elements in B. They are already in 
place. 
396 Cracking the Coding Interview, 6th Edition"
2154,468,"Solutions to Chapter 10 I Sorting and Searching 
10.2 Group Anagrams: Write a method to sort an array ot strings so that all tne anagrnms are next to 
each other. 
pg 150 
SOLUTION 
This problem asks us to group the strings in an array such that the anagrams appear next to each other. 
Note that no "
2155,472,"words are anagrams of each other? Well, anagrams are words that have the same characters but in different 
orders. It follows then that if we can put the characters in the same order, we can easily check if the new 
words are identical. 
One way to do this is to just apply any standard sorting algor"
2156,501,"are equivalent. 
What's the easiest way of checking if two words are anagrams? We could count the occurrences of the 
distinct characters in each string and return true if they match. Or, we could just sort the string. After all, 
two words which are anagrams will look the same once they're sorted. "
2157,491,"3 char[] content= s.toCharArray(); 
4 Arrays.sort(content); 
5 return new String(content); 
6 } 
7 
8 public int compare(String sl, String s2) { 
9 return sortChars(sl).compareTo(sortChars(s2)); 
10 } 
11 } 
Now, just sort the arrays using this compareTo method instead of the usual one. 
12 Arrays.s"
2158,496,"array. We only need to group the strings in the array by anagram. 
We can do this by using a hash table which maps from the sorted version of a word to a list of its anagrams. 
So, for example, acre will map to the list {acre, race, care}. Once we've grouped all the words into 
these lists by anagra"
2159,169,"3 
4 /* Group words by anagram */ 
5 for (String s : array) { 
6 String key= sortChars(s); 
7 maplist.put(key, s); 
g } 
CrackingTheCodinglnterview.com I 6th Edition 397"
2160,497,"Solutions to Chapter 10 I Sorting and Searching 
9 
10 /* Convert hash table to array*/ 
11 int index = 0; 
12 for (String key: maplist.keySet()) { 
13 Arraylis t<String> lis t= maplis t.get(key); 
14 for (String t : list) { 
15 array[index] = t; 
16 index++; 
17 } 
18 } 
19 } 
20 
21 String sortCha"
2161,488,"28 * Arraylist<Integer>. See appendix for implementation. */ 
You may notice that the algorithm above is a modification of bucket sort. 
10.3 Search in Rotated Array: Given a sorted array of n integers that has been rotated an unknown 
number of times, write code to find an element in the array. You"
2162,431,"Output: 8 (the index of 5 in the array) 
SOLUTION 
If this problem smells like binary search to you, you're right! 
pg 150 
In classic binary search, we compare x with the midpoint to figure out if x belongs on the left or the right 
side. The complication here is that the array is rotated and may h"
2163,470,"Arrayl: {10, 15, 20, 0, 5} 
Array2: {50, 5, 20, 30, 40} 
Note that both arrays have a midpoint of 20, but 5 appears on the left side of one and on the right side of 
the other. Therefore, comparing x with the midpoint is insufficient. 
However, if we look a bit deeper, we can see that one half of th"
2164,329,"search the left or right half. 
For example, if we are searching for 5 in Array 1, we can look at the left element (1 O) and middle element 
(20). Since 10 < 20, the left half must be ordered normally. And, since 5 is not between those, we know that 
we must search the right half. 
398 Cracking the "
2165,505,"Solutions to Chapter 10 / Sorting and Searching 
In Array 2, we can see that since 50 > 20, the right half must be ordered normally. We turn to the middle 
(20) and right (40) element to check if 5 would fall between them. The value 5 would not; therefore, we
search the left half. 
The tricky condit"
2166,495,"Otherwise, we have no choice but to search both halves.
1 int search(int a[], int left, int right, int x) { 
2 int mid= (left+ right)/ 2; 
3 if (x == a[mid]) {//Found element 
4 return mid; 
5 } 
6 if (right< left) { 
7 return -1; 
8 } 
9 
10 /* Either the left or right half must be normally ordered"
2167,452,"13 if (a[left] < a[mid]) {//Left is normally ordered.
14 if (x >= a[left] && x < a[mid]) { 
15 return search(a, left, mid - 1, x); // Search left 
16 } else { 
17 return search(a, mid+ 1, right, x); // Search right 
18 } 
19 } else if (a[mid] < a[left]) {//Right is normally ordered. 
20 if (x > a[mi"
2168,505,"23 return search(a, left, mid - 1, x); // Search left 
24 } 
25 } else if (a[left] == a[mid]) {//Left or right half is all repeats 
26 if (a[mid] != a[right]) {//If right is different, search it 
27 return search(a, mid+ 1, right, x); // search right 
28 } else {//Else, we have to search both halves"
2169,426,"33 return result; 
34 } 
35 } 
36 } 
37 return -1; 
38 } 
This code will run in O(log n) if all the elements are unique. However, with many duplicates, the algo­
rithm is actually O( n). This is because with many duplicates, we will often have to search both the left and 
right sides of the array (o"
2170,249,"lessly. Don't feel bad if you had trouble implementing it without a few bugs. Because of the ease of making 
off-by-one and other minor errors, you should make sure to test your code very thoroughly. 
CrackingTheCodinglnterview.com J 6th Edition 399"
2171,446,"Solutions to Chapter 10 I Sorting and Searching 
10.4 Sorted Search, No Size: You are given an array-like data structure Listy which lacks a size 
method. It does, however, have an elementAt ( i) method that returns the element at index i in 
0( 1) time. If i is beyond the bounds of the data structu"
2172,497,"find the index at which an element x occurs. If x occurs multiple times, you may return any index. 
pg 150 
SOLUTION 
Our first thought here should be binary search. The problem is that binary search requires us knowing the 
length of the list, so that we can compare it to the midpoint. We don't hav"
2173,497,"values until we exceed the size of the list. 
But how much bigger? If we just went through the list linearly-1, then 2, then 3, then 4, and so on-we'd 
wind up with a linear time algorithm. We probably want something faster than this. Otherwise, why would 
the interviewer have specified the list is "
2174,501,"I 
Why O(log n)? Imagine we start with pointer q at q = 1. At each iteration, this pointer q 
doubles, until q is bigger than the length n. How many times can q double in size before it's 
bigger than n? Or, in other words, for what value of k does 2k = n?This expression is equal when 
k = log n, as"
2175,456,"to make one small tweak. If the mid point is -1, we need to treat this as a ""too big""value and search left. This 
is on line 16 below. 
There's one more little tweak. Recall that the way we figure out the length is by calling elementAt and 
comparing it to -1. If, in the process, the element is bigg"
2176,476,"1 int search(Listy list, int value) { 
2 int index= 1; 
3 while (list.elementAt(index) != -1 && list.elementAt(index) < value) { 
4 index *= 2; 
5 } 
6 return binarySearch(list, value, index/ 2, index); 
7 } 
8 
9 int binarySearch(Listy list, int value, int low, int high) { 
10 int mid; 
11 
12 whil"
2177,99,"16 high = mid - 1; 
17 } else if (middle < value) { 
400 Cracking the Coding Interview, 6th Edition"
2178,472,"Solutions to Chapter 10 I Sorting and Searching 
18 low= mid+ 1· '
19 } else { 
20 return mid; 
21 } 
22 } 
23 return -1;
24 } 
It turns out that not knowing the length didn't impact the runtime of the search algorithm. We find the 
length in O( log n) time and then do the search in 0( log n) time. "
2179,453,"method to find the location of a given string. 
EXAMPLE 
Input: ball, {""at"", 
""""} 
Output: 4 
SOLUTION 
"""" """" """" , , , ""ball"", ,,,, , ,,,, , ""car"", """" , """" , ""dad"", """", 
pg 750 
If it weren't for the empty strings, we could simply use binary search. We would compare the string to be 
found, str, wit"
2180,489,"do is fix the comparison against mid, in case mid is an empty string. We simply move mid to the closest 
non-empty string. 
The recursive code below to solve this problem can easily be modified to be iterative. We provide such an 
implementation in the code attachment. 
1 int search(String[] strings"
2181,479,"5 
6 /* If mid is empty, find closest non-empty string. */ 
7 if (strings[mid].isEmpty()) { 
8 int left= mid - 1; 
9 int right= mid+ 1; 
10 while (true) { 
11 if (left< first && right> last) { 
12 return -1; 
13 } else if (right<= last && !strings[right].isEmpty()) { 
14 mid = right; 
break; 15 
16 "
2182,498,"Solutions to Chapter 1 O I Sorting and Searching 
24 
25 /* Check for string, and recurse if necessary */ 
26 if (str.equals(strings[mid])) {//Found it! 
return mid; 27 
28 
29 
30 
31 
32 
} else if (strings[mid].compareTo(str) < 0) {//Search right 
return search(strings, str, mid+ 1, last); 
} els"
2183,468,"37 return -1; 
38 } 
"""") { 
39 return search(strings, str, 0, strings.length - 1); 
40 } 
The worst-case runtime for this algorithm is O ( n). In fact, it's impossible to have an algorithm for this 
problem that is better than O(n) in the worst case. After all, you could have an array of all empty s"
2184,417,"you will need to look at every element in the array. 
Careful consideration should be given to the situation when someone searches for t he empty string. Should 
we find the location (which is an O( n) operation)? Or should we handle this as an error? 
There's no correct answer here. This is an issu"
2185,425,"question will demonstrate that you are a careful coder. 
10.6 Sort Big File: Imagine you have a 20 GB file with one string per line. Explain how you would sort 
the file. 
pg 150 
SOLUTION 
When an interviewer gives a size limit of 20 gigabytes, it should tell you something. In this case, it suggest"
2186,447,"So what do we do? We only bring part of the data into memory. 
We'll divide the file into chunks, which are x megabytes each, where x is the amount of memory we have 
available. Each chunk is sorted separately and then saved back to the file system. 
Once all the chunks are sorted, we merge the chun"
2187,437,"Solutions to Chapter 10 I Sorting and Searching 
10.7 Missing Int: Given an input file with four billion non-negative integers, provide an algorithm to 
generate an integer that is not contained in the file. Assume you have 1 GB of memory available for 
this task. 
FOLLOW UP 
What if you have only 1"
2188,498,"pg750
SOLUTION 
There are a total of 232, or 4 billion, distinct integers possible and 231 non-negative integers. Therefore, we 
know the input file (assuming it is ints rather than longs) contains some duplicates. 
We have 1 GB of memory, or 8 billion bits. Thus, with 8 billion bits, we can map all"
2189,475,"boolean values by using an array of ints (or another data type). Each int represents 32 boolean values.
2. Initialize BV with all Os.
3. Scan all numbers (num) from the file and call BV. set ( num, 1) .
4. Now scan again BV from the 0th index.
5. Return the first index which has a value of 0.
The fo"
2190,509,"3 String filename = 
4 
5 void findOpenNumber() throws FileNotFoundException { 
6 Scanner in = new Scanner(new FileReader(filename)); 
7 while (in.has Nextint()) { 
8 int n = in.nextlnt (); 
9 /* Finds the corresponding number in the bitfield by using the OR operator to 
10 * set the nth bit of a by"
2191,306,"16 for (int j = 0; j < 8; j++) { 
17 /* Retrieves the individual bits of each byte. When 0 bit is found, print 
18 * the corresponding value. */
19 if ((bitfield[i] & (1 << j)) == 0) {
20 System.out.println (i * 8 + j); 
21 return; 
22 
23 } 
24 } 
25 } 
} 
CrackingTheCodinglnterview.com I 6th Editi"
2192,445,"Solutions to Chapter 1 o I Sorting and Searching 
Follow Up: What if we have only 10 MB memory? 
It's possible to find a missing integer with two passes of the data set. We can divide up the integers into 
blocks of some size (we'll discuss how to decide on a size later). Let's just assume that we d"
2193,455,"1000 - 1999, and so on. 
Since all the values are distinct, we know how many values we should find in each block. So, we search 
through the file and count how many values are between O and 999, how many are between 1000 and 
1999, and so on. If we count only 999 values in a particular range, then w"
2194,437,"approach from the first part of this problem. We can ignore any number outside of this specific range. 
The question, now, is what is the appropriate block size? Let's define some variables as follows: 
Let rangeSize be the size of the ranges that each block in the first pass represents. 
. 2""/ Let "
2195,505,"since there are 231 non-negative integers. 
We need to select a value for rangeSize such that the memory from the first pass (the array) and the 
second pass (the bit vector) fit. 
First Pass: The Array 
The array in the first pass can fit in 10 megabytes, or roughly 223 bytes, of memory. Since each"
2196,448,"231 
arraySize = . :C:: 221 
rangeS1ze 
. 2"" rangeS1ze:::: y, 
rangeSize:::: 210 
Second Pass: The Bit Vector 
We need to have enough space to store rangeSize bits. Since we can fit 223 bytes in memory, we can fit 
226 bits in memory. Therefore, we can conclude the following: 
2"" <= rangeSize <= 2u "
2197,490,"less memory will be used at any given time. 
The below code provides one implementation for this algorithm. 
1 
2 
3 
int findOpenNumber(String filename) throws FileNotFoundException { 
int rangeSize = (1 << 20); // 2A20 bits (2A17 bytes) 
4 /* Get count of number of values within each block. */ 
5 "
2198,80,"9 if (blocklndex < 0) return -1; 
404 Cracking the Coding Interview, 6th Edition"
2199,494,"Solutions to Chapter 10 I Sorting and Searching 
10 
11 /* Create bit vector for items within this range. */ 
12 byte[] bitVector = getBitVectorForRange(filename, blockindex, rangeSize);
13 
14 /* Find a zero in the bit vector */ 
15 int offset findZero(bitVector); 
16 if (offset < 0) return -1; 
17"
2200,494,"23 int[] getCountPerBlock(String filename, int rangeSize) 
24 throws FileNotFoundException { 
25 int arraySize = Integer.MAX_VALUE / rangeSize + 1; 
26 int[] blocks = new int[arraySize]; 
27 
28 Scanner in = new Scanner (new FileReader(filename)); 
29 while (in.hasNextint()) { 
30 int value = in.nex"
2201,459,"38 int findBlockWithMissing(int[] blocks, int rangeSize) { 
39 for (int i= 0; i < blocks.length; i++) { 
40 if (blocks[i] < rangeSize){ 
41 return i; 
42 } 
43 } 
44 return -1; 
45 } 
46 
47 /* Create a bit vector for the values within a specific range. */ 
48 byte[] getBitVectorForRange(String file"
2202,497,"51 int endRange = startRange + rangeSize; 
52 byte[] bitVector = new byte[rangeSize/Byte.SIZE]; 
53 
54 Scanner in = new Scanner(new FileReader(filename)); 
55 while (in.hasNextint()) { 
56 int value = in.nextint(); 
57 /* If the number is inside the block that's missing numbers, we record it */ 
58"
2203,98,"62 } 
63 } 
64 in.close(); 
65 return bitVector; 
CrackingTheCodinglnterview.com I 6th Edition 405"
2204,469,"Solutions to Chapter 10 I Sorting and Searching 
66 } 
67 
68 /* Find bit index that is 0 within byte. */ 
69 int findZero(byte b) { 
70 for (int i= 0; i < Byte.SIZE; i++) { 
71 int mask= 1 << i; 
72 if ((b & mas k)== 0) { 
73 return i; 
74 } 
75 } 
76 return -1; 
77 } 
78 
79 /* Find a zero within "
2205,478,"82 if (bitVector[i] != -0) {//If not all ls 
83 int bitindex = findZero(bitVector[i]); 
84 return i * Byte.SIZE+ bitindex; 
85 } 
86 } 
87 return -1; 
88 } 
What if, as a follow up question, you are asked to solve the problem with even less memory? In this case, we 
can do repeated passes using the "
2206,500,"gers are found in each sequence of a thousand elements. Finally, in the third pass, we'd apply the bit vector. 
10.8 Find Duplicates: You have an array with all the numbers from 1 to N, where N is at most 32,000. The 
array may have duplicate entries and you do not know what N is. With only 4 kiloby"
2207,503,"bits is greater than 32000. We can create a bit vector with 32000 bits, where each bit represents one integer. 
Using this bit vector, we can then iterate through the array, flagging each element v by setting bit v to 1. 
When we come across a duplicate element, we print it. 
1 void checkDuplicates "
2208,168,"6 if (bs.get(num0)) { 
7 Syste m.out.println(num); 
8 } else { 
9 bs.sgt(num0); 
10 } 
11 } 
12 } 
13 
14 class BitSet { 
406 Cracking the Coding Interview, 6th Edition"
2209,496,"Solutions to Chapter 10 I Sorting and Searching 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 }
int[] bitset; 
public BitSet(int size) { 
bitset = new int[(size >> 5) + 1); // divide by 32 
} 
boolean get(int pos) { 
int wordNumber = (pos >> 5); // divide by 32 
int bitNumb"
2210,466,"int bitNumber = (pos & 0x1F); // mod 32 
bitset[wordN umber] I= 1 << bitNumber; 
Note that while this isn't an especially difficult problem, it's important to implement this cleanly. This is why 
we defined our own bit vector class to hold a large bit vector. If our interviewer lets us (she may or m"
2211,495,"ascending order, write a method to find an element. 
pg 151 
SOLUTION 
We can approach this in two ways: a more naive solution that only takes advantage of part of the sorting, 
and a more optimal way that takes advantage of both parts of the sorting. 
Solution #1: Naive Solution 
As a first approac"
2212,504,"to mention to your interviewer before you proceed with generating a better algorithm. 
To develop an algorithm, let's start with a simple example. 
15 20 40 85 
20 35 80 95 
30 55 95 105 
40 80 100 120 
Suppose we are searching for the element 55. How can we identify where it is? 
If we look at the "
2213,474,"the minimum element. Additionally, we know that 55 can't be in any columns on the right, since the first 
element of each column must increase in size from left to right. Therefore, if the start of the column is 
greater than the element x that we are searching for, we know that we need to move furt"
2214,508,"Solutions to Chapter 10 I Sorting and Searching 
Observe that we can also make a similar conclusion by looking at the ends of columns or rows. If the end 
of a column or row is less than x, then we know that we must move down (for rows) or to the right (for 
columns) to find x. This is because the e"
2215,408,"If the end of a column is less than x, then x is to the right of the column. 
If the start of a row is greater than x, then x is above that row. 
If the end of a row is less than x, then x is below that row. 
We can begin in any number of places, but let's begin with looking at the starts of columns"
2216,437,"for comparison is array[0] [ c-1], where c is the number of columns. By comparing the start of columns 
to x (which is 55), we'll find that x must be in columns 0, 1, or 2. We will have stopped at array [ 0] [ 2]. 
This element may not be the end of a row in the full matrix, but it is an end of a ro"
2217,500,"downwards. 
We now have a submatrix to consider that looks like the following (the gray squares have been eliminated). 
We can repeatedly apply these conditions to search for 55. Note that the only conditions we actually use 
are conditions 1 and 4. 
The code below implements this elimination algori"
2218,447,"5 if (matrix[row][col] == elem) { 
6 return true; 
7 } else if (matrix[row][col] > elem) 
8 col--; 
9 } else { 
10 row++; 
11 } 
12 } 
13 return false; 
14 } 
{ 
Alternatively, we can apply a solution that more directly looks like binary search. The code is considerably 
more complicated, but it app"
2219,431,"Solutions to Chapter 10 I Sorting and Searching 
15 20 70 85 
213 3S 80 95 
30 55 95 105 
40 80 100 120 
We want to be able to leverage the sorting property to more efficiently find an element. So, we might ask 
ourselves, what does the unique ordering property of this matrix imply about where an el"
2220,435,"the elements in row i between columns O and j - 1 and the elements in column j between rows O and 
i - 1. 
Or, in other words: 
a[i][0] <= a[i][l] <= ... <= a[i][j-1] <= a[i][j] 
a[0][j] <= a[l][j] <= ... <= a[i-l][j] <= a[i][j] 
Looking at this visually, the dark gray element below is bigger than a"
2221,505,"as well as the elements above it. So, by transitivity, the dark gray element is bigger than the entire square. 
This means that for any rectangle we draw in the matrix, the bottom right hand corner will always be the 
biggest. 
Likewise, the top left hand corner will always be the smallest. The colo"
2222,139,"onal, we'll find the elements 35 and 95. What does this tell us about the location of 85? 
CrackingTheCodinglnterview.com I 6th Edition 409"
2223,505,"Solutions to Chapter 10 I Sorting and Searching 
85 can't be in the black area, since 95 is in the upper left hand corner and is therefore the smallest element 
in that square. 
85 can't be in the light gray area either, since 35 is in the lower right hand corner of that square. 
85 must be in one o"
2224,443,"Observe that since the diagonal is sorted, we can efficiently search it using binary search. 
The code below implements this algorithm. 
1 Coordinate findElement(int[][] matrix, Coordinate or1g1n, Coordinate dest, int x){ 
2 if (!origin. inbounds (matrix) 11 ! dest. inbounds (matrix)) { 
3 return nu"
2225,500,"return null; 
9 } 
10 
x) {
11 /* Set start to start of diagonal and end to the end of the diagonal. Since the 
12 * grid may not be square, the end of the diagonal may not equal dest. */
13 Coordinate start= (Coordinate) origin.clone();
14 int diagDist = Math.min(dest.row - origin.row, dest.column "
2226,485,"17 
18 /* Do binary search on the diagonal, looking for the 
first element> x */ 
19 while (start.isBefore(end)) { 
20 p.setToAverage(start, end);
21 if (x > matrix[p.row][p.column]) {
22 start.row = p.row + 1; 
23 start.column = p.column + 1; 
24 } else { 
25 end.row = p.row - 1; 
26 end.column = p"
2227,436,"x); 
32 } 
33 
34 Coordinate partitionAndSearch(int[][] matrix, Coordinate origin, Coordinate dest, 
35 Coordinate pivot, int x) { 
36 Coordinate lowerLeftOrigin = new Coordinate(pivot.row, origin.column); 
37 Coordinate lowerLeftDest = new Coordinate(dest.row, pivot.column - 1); 
38 Coordinate uppe"
2228,237,"40 
41 Coordinate lowerLeft = findElement(matrix, lowerLeftOrigin, lowerLeftDest, x); 
42 if (lowerleft == null) { 
43 return findElement(matrix, upperRightOrigin, upperRightDest, x); 
44 } 
410 Cracking the Coding Interview, 6th Edition"
2229,472,"Solutions to Chapter 1 O I Sorting and Searching 
45 return lowerleft; 
46 } 
47 
48 Coordinate findElement(int[][] matrix, int x) { 
49 Coordinate origin = new Coordinate(0, 0); 
50 coordinate dest = new Coordinate(matrix.length - 1, matrix[0].length - 1); 
51 return findElement(matrix, origin, des"
2230,507,"57 row = r; 
58 column = c; 
59 } 
60 
61 public boolean inbounds(int[][] matrix) { 
62 return row >= 0 && column >= 0 && 
63 row< matrix.length && column< matrix[0].length; 
64 } 
65 
66 public boolean isBefore(Coordinate p) { 
67 return row<= p.row && column<= p.column; 
68 } 
69 
70 public Object"
2231,417,"76 column = (min.column + max.column)/ 2; 
77 } 
78 } 
If you read all this code and thought, ""there's no way I could do all this in an interview!"" you're probably 
right. You couldn't. But, your performance on any problem is evaluated compared to other candidates on 
the same problem. So while you "
2232,381,"when you get a tricky problem like this. 
You help yourself out a bit by separating code out into other methods. For example, by pulling 
parti tionAndSearch out into its own method, you will have an easier time outlining key aspects of the 
code. You can then come back to fill in the body for parti"
2233,511,"Solutions to Chapter 1 o I Sorting and Searching 
10.10 Rank from Stream: Imagine you are reading in a stream of integers. Periodically, you wish 
to be able to look up the rank of a number x (the number of values less than or equal to x). 
Implement the data structures and algorithms to support the"
2234,505,"including x itself). 
EXAMPLE 
Stream(in order of appearance):5, 1, 4, 4, 5, 9, 7, 13, 3 
getRankOfNumber(l) 0 
getRankOfNumber(3) 1 
getRankOfNumber(4) 3 
pg 151 
SOLUTION 
A relatively easy way to implement this would be to have an array that holds all the elements in sorted 
order. When a new ele"
2235,491,"for n, and return the index. 
However, this is very inefficient for inserting elements (that is, the track(int x) function). We need a 
data structure which is good at keeping relative ordering, as well as updating when we insert new elements. 
A binary search tree can do just that. 
Instead of inse"
2236,454,"tree is balanced). 
To find the rank of a number, we could do an in-order traversal, keeping a counter as we traverse. The goal 
is that, by the time we find x, counter will equal the number of elements less than x. 
As long as we're moving left during searching for x, the counter won't change. Why?"
2237,472,"leftmost node. 
When we move to the right though, we skip over a bunch of elements on the left. All of these elements are 
less than x, so we'll need to increment counter by the number of elements in the left subtree. 
Rather than counting the size of the left subtree (which would be inefficient), w"
2238,161,"cates the number of nodes in the left subtree (or, in other words, the rank of the node relative to its subtree). 
412 Cracking the Coding Interview, 6th Edition"
2239,468,"Solutions to Chapter 10 I Sorting and Searching 
23 (0) 
5 (0) 13 (0) 24 (0) 
Suppose we want to find the rank of 24 in the tree above. We would compare 24 with the root 20, and find 
that 24 must reside on the right. The root has 4 nodes in its left subtree, and when we include the root itself, 
th"
2240,466,"update, since we're not""passing over""any smaller nodes. The value of co unter is still 5. 
Next, we compare 24 with node 23, and find that 24 must be on the right. Counter gets incremented by 
just 1 (to 6), since 23 has no left nodes. 
Finally, we find 24 and we return co unter: 6. 
Recursively, th"
2241,479,"3 if xi s on left of node, return getRank(node.left, x) 
4 if xi s on right of node, return node.leftSize() + 1 + getRank(node.right, x) 
5 } 
The full code for this is below. 
1 RankNode root = null; 
2 
3 void track(int number) { 
4 if (root == null) { 
5 root = new RankNode(number); 
6 } else { 
"
2242,275,"15 
16 public class RankNode { 
17 public int left_size = 0; 
18 public RankNode left, right; 
19 public int data = 0; 
20 public RankNode(int d) { 
21 data = d; 
22 } 
23 
24 public void ins ert(int d) { 
25 if (d <= data) { 
CrackingTheCodinglnterview.com \ 6th Edition 413"
2243,466,"Solutions to Chapter 10 I Sorting and Searching 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 } 
} 
if (left != null) left.insert(d); 
else left= new RankNode(d); 
left_size++; 
} else { 
} 
if (right != null) right.insert(d); 
else right = new RankNode(d); "
2244,505,"else return left.getRank(d); 
} else { 
} 
} 
int right_rank =r ight == null? -1 : right.getRank(d); 
if (right_rank == -1) return -1; 
else return left_size + 1 + right_rank; 
The track method and the getRankOfNumber method will both operate in O(log N) on a balanced 
tree and O(N) on an unbalanced"
2245,473,"10.11 Peaks and Valleys: In an array of integers, a ""peak"" is an element which is greater than or equal 
to the adjacent integers and a ""valley"" is an element which is less than or equal to the adjacent 
integers. For example, in the array {5, 8, 6, 2, 3, 4, 6}, {8, 6} are peaks and {5, 2} are valle"
2246,498,"Output: {5, 1, 3, 2, 3} 
pg 151
SOLUTION 
Since this problem asks us to sort the array in a particular way, one thing we can try is doing a normal sort 
and then ""fixing"" the array into an alternating sequence of peaks and valleys. 
Suboptimal Solution 
Imagine we were given an unsorted array and th"
2247,84,"and try to do that. 
• The 0 is okay.
414 Cracking the Coding Interview, 6th Edition"
2248,467,"Solutions to Chapter 10 I Sorting and Searching 
• The 1 is in the wrong place. We can swap it with either the 0 or 4. Let's swap it with the 0.
1 0 4 7 8 9
• The 4 is okay.
• The 7 is in the wrong place. We can swap it with either the 4 or the 8. Let's swap it with the 4.
1 0 7 4 8 9 
- Th<> 9 is i"
2249,432,"matters, but all sorted arrays will have the same relative order. Therefore, we can take this same approach 
on any sorted array. 
Before coding, we should clarify the exact algorithm, though. 
1. Sort the array in ascending order.
2. Iterate through the elements, starting from index 1 (not 0) and j"
2250,481,"small <= medium <= large, swapping these elements will always put medium as a peak: medium
<= small <= large.
This approach will ensure that the peaks are in the right place: indexes 1, 3, 5, and so on. As long as the odd­
numbered elements (the peaks) are bigger than the adjacent elements, then the"
2251,498,"1 void sortValleyPeak(int[] array) { 
2 Arrays.sort(array); 
3 for (int i= 1; i < array.length; i += 2) { 
4 swap(array, i - 1, i); 
5 } 
6 } 
7 
8 
9 
10 
void swap(int[] array, int left, 
int temp = array[left]; 
array[left] = array[right]; 
array[right] = temp; 11 
12 } 
This algorithm runs in O("
2252,318,"unsorted array. 
Let's revisit an example. 
9 1 0 4 8 7 
For each element, we'll look at the adjacent elements. Let's imagine some sequences. We'll just use the 
numbers 0, 1 and 2. The specific values don't matter. 
0 1 2 
0 2 1 
1 0 2 
1 2 0 
2 1 0 
// peak 
// peak 
CrackingTheCodinglnterview.com"
2253,502,"Solutions to Chapter 10 I Sorting and Searching 
2 0 1 
If the center element needs to be a peak, then two of those sequences work. Can we fix the other ones to 
make the center element a peak? 
Yes. We can fix this sequence by swapping the center element with the largest adjacent element. 
0 1 2 ->"
2254,497,"right place. 
I 
We should be a little cautious here. Is it possible that one of these swaps could ""break"" an earlier 
part of the sequence that we'd already processed? This is a good thing to worry about, but it's 
not an issue here. If we're swapping middle with left, then left is currently a vall"
2255,490,"1 void sortValleyPeak(int[] array) { 
2 for (int i= 1; i < array.length; i += 2) { 
3 int biggestindex = maxindex(array, i - 1, i, i + 1); 
4 if (i != biggestindex) { 
S swap(array, i, biggestindex); 
6 } 
7 } 
8 } 
9 
10 int maxindex(int[] array, int a, int b, int c) { 
11 int len = array.length; 
"
2256,298,"15 
Integer.MIN_VALUE; 
Integer.MIN_VALUE; 
Integer.MIN_VALUE; 
16 int max= Math.max(aValue, Math.max(bValue, cValue)); 
17 if (aValue == max) return a; 
18 else if (bValue == max) return b; 
19 else return c; 
20 } 
This algorithm takes O ( n) time. 
416 Cracking the Coding Interview, 6th Edition"
2257,488,"11 
Solutions to Testing 
11.1 Mistake: Find the mistake(s) in the following code: 
unsigned inti; 
for (i = 100; i >= 0; --i) 
printf(""%d\n"", i); 
SOLUTION 
There are two mistakes in this code. 
pg 157
First, note that an unsigned int is, by definition, always greater than or equal to zero. The for"
2258,473,"an additional printf statement after the for loop. 
1 unsigned inti; 
2 for (i = 100; i > 0; --i) 
3 printf(""%d\n"", i); 
One additional correction is to use %u in place of%d, as we are printing unsigned int. 
1 unsigned inti; 
2 for (i = 100; i > 0; --i) 
3 printf(""%u\n"", i); 
This code will now cor"
2259,491,"running it ten times in a debugger, you find it never crashes in the same place. The application is 
single threaded, and uses only the C standard library. What programming errors could be causing 
this crash? How would you test each one? 
pg 157 
SOLUTION 
The question largely depends on the type o"
2260,184,"be fixed for every execution of the program. Examples include user input, a random number generated
by the program, or the time of day.
CrackingTheCodinglnterview.com I 6th Edition 417"
2261,485,"Solutions to Chapter 11 I Testing 
2. Uninitialized Variable: The application could have an uninitialized variable which, in some languages,
may cause it to take on an arbitrary value. The values of this variable could result in the code taking a
slightly different path each time.
3. Memory Leak: Th"
2262,505,"overflow or corruption of data on the stack.
4. External Dependencies: The program may depend on another application, machine, or resource. ff there
are multiple dependencies, the program could crash at any point.
To track down the issue, we should start with learning as much as possible about the a"
2263,412,"to specific components or scenarios. For example, it could be that the application never crashes if it's simply 
launched and left untouched, and that crashes only appear at some point after loading a file. Or, it may be 
that all the crashes take place within the lower level components, such as fil"
2264,423,"resource use very carefully. If there are parts of the program we can disable, do so. Run it on a different 
machine and see if we experience the same issue. The more we can eliminate (or change), the easier we can 
track down the issue. 
Additionally, we may be able to use tools to check for specif"
2265,508,"These problems are as much about your brainstorming ability as they are about your approach. Do you 
jump all over the place, shouting out random suggestions? Or do you approach it in a logical, structured 
manner? Hopefully, it's the latter. 
11.3 Chess Test: We have the following method used in a "
2266,492,"pg157 
SOLUTION 
In this problem, there are two primary types of testing: extreme case validation (ensuring that the program 
doesn't crash on bad input), and general case testing. We'll start with the first type. 
Testing Type #1: Extreme Case Validation 
We need to ensure that the program handles "
2267,205,"• Test with y larger than the height
Test with a completely full board
• Test with an empty or nearly empty board
• Test with far more white pieces than black
418 Cracking the Coding Interview, 6th Edition"
2268,451,"Solutions to Chapter 11 I Testing 
• Test with far more black pieces than white
For the error cases above, we should ask our interviewer whether we want to return false or throw an excep­
tion, and we should test accordingly. 
Testing Type #2: General Testing: 
General testing is much more expansive"
2269,422,"however, perform a reasonable coverage of different boards. 
There are 6 pieces in chess, so we can test each piece against every other piece, in every possible direction. 
This would look something like the below code: 
1 foreach piece a: 
2 for each other type of piece b (6 types + empty space) 
3"
2270,406,"6 Try to move - check return value. 
The key to this problem is recognizing that we can't test every possible scenario, even if we would like to. 
So, instead, we must focus on the essential areas. 
11.4 No Test Tools: How would you load test a webpage without using any test tools? 
SOLUTION 
pg 157"
2271,465,"that may interfere with its performance. Similarly, it can check how an application responds to variations 
in load. 
To perform load testing, we must first identify the performance critical scenarios and the metrics which 
fulfill our performance objectives. Typical criteria include: 
Response time"
2272,493,"In the absence of formal testing tools, we can basically create our own. For example, we could simulate 
concurrent users by creating thousands of virtual users. We would write a multi-threaded program with 
thousands of threads, where each thread acts as a real-world user loading the page. For each"
2273,66,"accepted values. 
CrackingTheCodinglnterview.com / 6th Edition 419"
2274,485,"Solutions to Chapter 11 I Testing 
11.5 Test a Pen: How would you test a pen? 
SOLUTION 
pg 157
This problem is largely about understanding the constraints and approaching the problem in a structured 
manner. 
To understand the constraints, you should ask a lot of questions to understand the ""who, w"
2275,486,"To illustrate the technique in this problem, let us guide you through a mock conversation. 
Interviewer: How would you test a pen? 
Candidate: Let me find out a bit about the pen. Who is going to use the pen? 
• Interviewer: Probably children.
• Candidate: Okay, that's interesting. What will they be"
2276,480,"• Interviewer: On clothing.
• Candidate: Great. What kind of tip does the pen have? Felt? Ballpoint? Is it intended to wash off, or is it
intended to be permanent?
Interviewer: It's intended to wash off.
Many questions later, you may get to this: 
Candidate: Okay, so as I understand it, we have a pe"
2277,410,"Is that correct? 
The candidate now has a problem that is significantly different from what it initially seemed to be. This is 
not uncommon. In fact, many interviewers intentionally give a problem that seems clear (everyone knows 
what a pen is!), only to let you discover that it's quite a differen"
2278,504,"Now that you understand what you're testing, it's time to come up with a plan of attack. The key here is 
structure. 
Consider what the different components of the object or problem, and go from there. In this case, the 
components might be: 
Fact check: Verify that the pen is felt tip and that the "
2279,352,"time)? Does it wash off in hot warm and cold water?
Safety: Is the pen safe (non-toxic) for children?
Unintended uses: How else might children use the pen?They might write on other surfaces, so you need
to check whether the behavior there is correct. They might also stomp on the pen, throw it, and s"
2280,461,"Solutions to Chapter 11 I Testing 
You'll need to make sure that the pen holds up under these conditions. 
Remember that in any testing question, you need to test both the intended and unintended scenarios. 
People don't always use the product the way you want them to. 
11.6 Test an ATM: How would y"
2281,421,"pg 157 
• Who is going to use the ATM? Answers might be ""anyone;' or it might be ""blind people;' or any number
of other answers.
What are they going to use it for? Answers might be ""withdrawing money;' ""transferring money;'
""checking their balance;' or many other answers.
• What tools do we have to "
2282,473,"Once we understand what the system looks like, we'll want to break down the problem into 
different test­
able components. These components include: 
Logging in 
• Withdrawing money
Depositing money
• Checking balance
Transferring money
We would probably want to use a mix of manual and automated tes"
2283,473,"(low balance, new account, nonexistent account, and so on). 
Automated testing is a bit more complex. We'll want to automate all the standard scenarios, as shown 
above, and we also want to look for some very specific issues, such as race conditions. Ideally, we would be 
able to set up a closed sys"
2284,311,"Above all, we need to prioritize security and reliability. People's accounts must always be protected, and we 
must make sure that money is always properly accounted for. No one wants to unexpectedly lose money! A 
good tester understands the system priorities. 
CrackingTheCodinglnterview.com I 6th "
2285,399,"12 
Solutions to C and C++ 
12.1 Last K Lines: Write a method to print the last Klines of an input file using C ++. 
SOLUTION 
pg 163 
One brute force way could be to count the number of lines (N) and then print from N-K to Nth line. But this 
requires two reads of the file, which is unnecessarily c"
2286,427,"once and be able to print the last K lines. 
We can allocate an array for all K lines and the last K lines we've read in the array. , and so on. Each time that 
we read a new line, we purge the oldest line from the array. 
But-you might ask-wouldn't this require shifting elements in the array, which"
2287,486,"With a circular array, we always replace the oldest item when we read a new line. The oldest item is tracked 
in a separate variable, which adjusts as we add new items. 
The following is an example of a circular array: 
step 1 (initially): array {a, b, c, d, 
step 2 (ins ert g): array {g, b, c, d, 
"
2288,495,"2 const int K = 10; 
3 ifstream file (fileName); 
4 string L[K); 
5 int size = 0; 
6 
e, 
e, 
e, 
e, 
f}. p 
f}. p 
f}. p 
f}. p 
7 /* read file line by line into circular array */ 
0 
1 
2 
3 
8 /* peek() so an EOF following a line ending is not considered a separate line */ 
9 while (file.peek() !"
2289,79,"16 int count= min(K, size); 
17 
422 Cracking the Coding Interview, 6th Edition"
2290,426,"Solutions to Chapter 12 I C and C++
18 /* print elements in the order they were read */ 
19 for (inti= 0; i < count; i++) { 
20 cout << L[(start + i) % K] << endl; 
21 } 
22 } 
This solution will require reading in the whole file, but only ten lines will be in memory at any given point. 
12.2 Revers"
2291,510,"terminated string. 
pg 163 
SOLUTION 
This is a classic interview question. The only""gotcha"" is to try to do it in place, and to be careful for the null 
character. 
We will implement this in C.
1 void reverse(char *str) { 
2 char* end= str; 
char tmp; 3 
4 if (str) { 
5 while (*end) {/* find end of"
2292,463,"* pointers meet in middle. */
while (str < end) {
tmp = *str; 
} 
} 
*str++ *end;
*end-- = tmp;
This is just one of many ways to implement this solution. We could even implement this code recursively 
(but we wouldn't recommend it). 
12.3 Hash Table vs STL Map: Compare and contrast a hash table and "
2293,474,"a hash table? 
pg 763
SOLUTION 
In a hash table, a value is stored by calling a hash function on a key. Values are not stored in sorted order. 
Additionally, since hash tables use the key to find the index that will store 
the value, an insert or lookup 
can be done in amortized 0(1) time (assuming "
2294,94,"values whose keys map to a particular index. 
CrackingTheCodinglnterview.com I 6th Edition 423"
2295,508,"Solutions to Chapter 12 I C and C ++ 
An STL map inserts the key/value pairs into a binary search tree based on the keys. There is no need to 
handle collisions, and, since the tree is balanced, the insert and lookup time is guaranteed to be O( log N). 
How is a hash table implemented? 
A hash table"
2296,414,"list at that position. 
Note that the elements in a linked list at a particular index of the array do not have the same key. Rather, 
hashFunction ( key) is the same for these values. Therefore, in order to retrieve the value for a specific 
key, we need to store in each node both the exact key and "
2297,449,"linked list holds two pieces of data: the value and the original key. In addition, we will want to note the 
following design criteria: 
1. We want to use a good hash function to ensure that the keys are well distributed. If they are not well
distributed, then we would get a lot of collisions and th"
2298,487,"them. This often means chaining via a linked list, but it's not the only way.
3. We may also wish to implement methods to dynamically increase or decrease the hash table size
depending on capacity. For example, when the ratio of the number of elements to the table size exceeds
a certain threshold, w"
2299,478,"tion, we want to be careful to not do it too often.
What can be used instead of a hash table, if the number of inputs is small? 
You can use an STL map or a binary tree. Although this takes O ( log ( n)) time, the number of inputs may 
be small enough to make this time negligible. 
12.4 Virtual Func"
2300,509,"a vtable is constructed which stores addresses of the virtual functions of this class. The compiler also adds 
a hidden vptr variable in all such classes which points to the vtable of that class. If a virtual function is not 
overridden in the derived class, the vtable of the derived class stores th"
2301,429,"binding in C++ is performed through the vtable mechanism. 
Thus, when we assign the derived class object to the base class pointer, the vptr variable points to the 
vtable of the derived class. This assignment ensures that the most derived virtual function gets called. 
Consider the following code. "
2302,476,"Solutions to Chapter 12 I C and C ++ 
5 cout << ""Circumference of Base Class\n""; 
6 return 0; 
7 } 
8 }; 
9 
10 class Triangle: public Shape { 
11 public: 
12 int circumference () { 
13 cout« ""Circumference of Triangle Class\n""; 
14 return 3 * edge_length; 
1.5 } 
16 }; 
17 
18 void main() { 
19 Sha"
2303,452,"23 } 
In the previous example, circumference is a virtual function in the Shape class, so it becomes virtual 
in each of the derived classes (Triangle, etc). C++ non-virtual function calls are resolved at compile time 
with static binding, while virtual function calls are resolved at runtime with dy"
2304,482,"you would use each. 
pg 164 
SOLUTION 
A shallow copy copies all the member values from one object to another. A deep copy does all this and also 
deep copies any pointer objects. 
An example of shallow and deep copy is below. 
1 struct Test { 
2 char * ptr; 
3 }; 
4 
5 void shallow_copy(Test & src,"
2305,483,"strcpy(dest.ptr, src.ptr); 
12 } 
Note that shallow_copy may cause a lot of programming runtime errors, especially with the creation and 
deletion of objects. Shallow copy should be used very carefully and only when a programmer really under­
stands what he wants to do. In most cases, shallow copy i"
2306,220,"objects in a shallow copy. 
In real life, shallow copy is rarely used. Deep copy should be used in most cases, especially when the size of 
the copied structure is small. 
CrackingTheCodinglnterview.com \ 6th Edition 42S"
2307,469,"Solutions to Chapter 12 I C and C ++ 
12.6 Volatile: What is the significance of the keyword ""volatile"" in C? 
SOLUTION 
pg 164 
The keyword volatile informs the compiler that the value of variable it is applied to can change from the 
outside, without any update done by the code. This may be done b"
2308,510,"each time from memory. 
A volatile integer can be declared by either of the following statements: 
int volatile x; 
volatile int x; 
To declare a pointer to a volatile integer, we do the following: 
volatile int * x; 
int volatile * x; 
A volatile pointer to non-volatile data is rare, but can be don"
2309,491,"int volatile * volatile x; 
Volatile variables are not optimized, which can be very useful. Imagine this function: 
1 int opt = 1; 
2 void Fn(void) { 
3 start: 
4 if (opt == 1) goto start; 
5 else break; 
6 } 
At first glance, our code appears to loop infinitely. The compiler may try to optimize it "
2310,509,"thus breaking the loop. 
To prevent the compiler from performing such optimization, we want to signal that another element of the 
system could change the variable. We do this using the volatile keyword, as shown below. 
1 volatile int opt = 1; 
2 void Fn(void) { 
3 start: 
4 if (opt == 1) goto star"
2311,46,"426 Cracking the Coding Interview, 6th Edition"
2312,501,"Solutions to Chapter 12 I C and C++
12.7 Virtual Base Class: Why does a destructor in base class need to be declared virtual? 
SOLUTION 
Let's think about why we have virtual methods to start with. Suppose we have the following code: 
1 class Foo { 
2 public: 
3 void f(); 
4 }; 
5 
6 class Bar : pub"
2313,459,"To ensure that p->f () will invoke the most derived implementation off (), we need to declare f () to be 
a virtual function. 
Now, let's go back to our destructor. Destructors are used to clean up memory and resources. If Foo's 
destructor were not virtual, then Foo's destructor would be called, ev"
2314,459,"class is called. 
12.8 Copy Node: Write a method that takes a pointer to a Node structure as a parameter and returns a 
complete copy of the passed in data structure. The Node data structure contains two pointers to 
other Nodes. 
pg 764
SOLUTION 
The algorithm will maintain a mapping from a node ad"
2315,506,"tional depth-first traversal of the structure. Traversals often mark visited nodes-the mark can take many 
forms and does not necessarily need to be stored in the node. 
Thus, we have a simple recursive algorithm: 
1 typedef map<Node*, Node*> NodeMap; 
2 
3 Node * copy_recursive(Node * cur, NodeMap "
2316,76,"11 return i->second; 
12 } 
CrackingTheCodinglnterview.com I 6th Edition 427"
2317,504,"Solutions to Chapter 12 I C and C ++ 
13 
14 Node* node = new Node; 
15 nodeMap[cur] = node; // map current before traversing links 
16 node->ptrl = copy_recursive(cur->ptrl, nodeMap); 
17 node->ptr2 = copy_recursive(cur->ptr2, nodeMap); 
18 return node; 
19 } 
20 
21 Node* copy_structure(Node * roo"
2318,471,"with templates, that simulates a pointer while also providing automatic garbage collection. It 
automatically counts the number of references to a SmartPointer<T*> object and frees the 
object of type T when the reference count hits zero. 
pg 164 
SOLUTION 
A smart pointer is the same as a normal po"
2319,457,"tain a single reference count for all references to a given object. 
This is one of those problems that seems at first glance pretty overwhelming, especially if you're not a C ++ 
expert. One useful way to approach the problem is to divide the problem into two parts: (1) outline the 
pseudocode and "
2320,504,"ence to the object and decremented when we remove a reference. The code should look something like 
the below pseudocode: 
1 template <class T> class SmartPointer { 
2 /* The smart pointer class needs pointers to both the object itself and to the 
3 * ref count. These must be pointers, rather than t"
2321,454,"6 T * obj;
7 unsigned* ref_count;
8 } 
We know we need constructors and a single destructor for this class, so let's add those first. 
1 SmartPointer(T * object) { 
2 /* We want to set the value of T * obj, and set the reference counter to 1. */ 
3 } 
4 
5 SmartPointer(SmartPointer<T>& sptr) { 
6 /*"
2322,281,"8 * and ref_count. Then, because we created a new reference to obj, we need to
9 * increment ref_count. */
10 } 
11 
12 =SmartPointer(SmartPointer<T> sptr) { 
13 /* We are destroying a reference to the object. Decrement ref_count. If 
428 Cracking the Coding Interview, 6th Edition"
2323,488,"Solutions to Chapter 12 \ C and C++
14 * ref count is 0, then free the memory created by the integer and destroy the
15 * object. */
16 } 
There's one additional way that references can be created: by setting one SmartPointer equal to another. 
We'll want to override the equal operator to handle thi"
2324,469,"3 * pointers to obj and ref_count over. Finally, since we created a new
4 * reference, we need to increment ref_count. */
5 } 
Getting just the approach, even without filling in the complicated C++ syntax, would count for a lot. 
Finishing out the code is now just a matter of filling the details. 
1"
2325,473,"6 *ref_count = 1;
7 } 
8 
9 SmartPointer(SmartPointer<T> & sptr) { 
10 ref= sptr.ref; 
11 ref_count = sptr.ref_count; 
12 ++(*ref_count); 
13 } 
14 
15 /* Override the equal operator, so that when you set one smart pointer equal to 
16 * another the old smart pointer has its reference count decremen"
2326,510,"19 if (this == &sptr) return *this; 
20 
21 /* If already assigned to an object, remove one reference. */ 
22 if (*ref_count > 0) { 
23 remove(); 
24 } 
25 
26 ref= sptr.ref; 
27 ref_count = sptr.ref_count; 
28 ++(*ref_count); 
29 return *this; 
30 } 
31 
32 -SmartPointer() {
33 remove();// Remove o"
2327,463,"Solutions to Chapter 12 I C and C ++ 
44 
45 
46 
delete ref; 
free(ref_count); 
ref= NULL; 
47 ref_count = NULL; 
48 } 
49 } 
50 
51 T * ref; 
52 unsigned * ref_count; 
53 } ; 
The code for this problem is complicated, and you probably wouldn't be expected to complete it flawlessly. 
12.1 O Malloc:"
2328,510,"EXAMPLE 
align_malloc (1000, 128) will return a memory address that is a multiple of 128 and that points 
to memory of size 1000 bytes. 
aligned_free() will free memory allocated by align_malloc. 
pg 164 
SOLUTION 
Typically, with malloc, we do not have control over where the memory is allocated wit"
2329,489,"address which is divisible by the desired value. 
Suppose we are requesting a 100-byte chunk of memory, and we want it to start at a memory address 
that is a multiple of 16. How much extra memory would we need to allocate to ensure that we can do so? 
We would need to allocate an extra 15 bytes. Wi"
2330,482,"We could then do something like: 
1 void* aligned_malloc(size_t required_bytes, size_t alignment) { 
2 int offset = alignment - 1; 
3 void* p = (void*) malloc(required_bytes + offset); 
4 void* q = (void*) (((size_t)(p) + offset) & =(alignment - 1)); 
5 return q; 
6 } 
Line 4 is a bit tricky, so let"
2331,491,"this address. ANDing the last four bits of p + 15 with 0000 guarantees that this new value will be divisible 
by 16 (either at the original p or in one of the following 15 addresses). 
This solution is almost perfect except for one big issue: how do we free the memory? 
We've allocated an extra 15 b"
2332,242,"will store this immediately before the aligned memory block. Of course, this means that we now need to 
allocate even more extra memory to ensure that we have enough space to store this pointer. 
430 Cracking the Coding Interview, 6th Edition"
2333,505,"Solutions to Chapter 12 I C and C++
Therefore, to guarantee both an aligned address and space for this pointer, we will need to allocate an addi­
tional alignment -
1 + sizeof(void*) bytes. 
The code below implements this approach. 
1 void* aligned_malloc(size_t required_bytes, size t alignment) { 
"
2334,450,"6 return NULL; 
7 } 
8 p2 = (void*)(((size_t)(pl) + offset) & =(alignment - 1)); 
9 ((void **)p2)[-1] = pl; 
10 return p2; 
11 } 
12 
13 void aligned_free(void *p2) { 
14 
15 
16 
17 } 
/* for consistency, we use the same names as aligned_malloc*/ 
void* pl = ((void**)p2)[-1]; 
free(pl); 
Let's look"
2335,487,"can just look at the index - 1 to retrieve pl. 
In aligned_free, we take p2 as the same p2 returned from aligned_malloc. As before, we know 
that the value of pl (which points to the beginning of the full memory block) was stored just before p2. By 
freeing pl, we deallocate the whole memory block. "
2336,509,"notation arr [ i] [ j]. 
pg 764
SOLUTION 
As you may know, a two-dimensional array is essentially an array of arrays. Since we use pointers with 
arrays, we can use double pointers to create a double array. 
The basic idea is to create a one-dimensional array of pointers. Then, for each array index,"
2337,429,"l int** my2DA1loc(int rows, int cols) { 
2 int** rowptr; 
3 int i; 
4 rowptr = (int**) malloc(rows * sizeof(int*)); 
5 for (i = 0; i < rows; i++) { 
5 rowptr[i] = (int*) malloc(cols * sizeof(int)); 
7 } 
8 return rowptr; 
9 } 
Observe how, in the above code, we've told rowptr where exactly each inde"
2338,434,"Solutions to Chapter 12 I C and C ++ 
To free this memory, we cannot simply call free on rowptr. We need to make sure to free not only the 
memory from the first malloc call, but also each subsequent call. 
1 void my2DDealloc (int** rowptr, int rows) { 
2 for (i = 0; i < rows; i++) { 
3 free(rowptr["
2339,437,"specify where each row is located), we can allocate this in a consecutive block of memory. Conceptually, for 
a two-dimensional array with five rows and six columns, this would look like the following. 
11���:fllllll
If it seems strange to view the 2D array like this (and it probably does), remember"
2340,481,"first five (in this example) elements point elsewhere in the same block of memory. 
To implement this solution, we do the following. 
1 int** my2DA1loc(int rows, int cols) { 
2 int i; 
3 int header = rows * sizeof(int*); 
4 int data = rows * cols * sizeof(int); 
5 int** rowptr = (int**)malloc(header"
2341,466,"10 rowptr[i] = buf + i * cols; 
11 } 
12 return rowptr; 
13 } 
You should carefully observe what is happening on lines 11 through 13. lf there are five rows of six columns 
each, array[0] will point to array[S ], array[ 1] will point to array[ 11 ], and so on. 
Then, when we actually call array[l] ["
2342,305,"we then get the third (zero-indexed) element from it. 
Constructing the array in a single call to malloc has the added benefit of allowing disposal of the array 
with a single free call rather than using a special function to free the remaining data blocks. 
432 Cracking the Coding Interview, 6th Ed"
2343,459,"13 
Solutions to Java 
13.1 Private Constructor: In terms of inheritance, what is the effect of keeping a constructor private? 
pg 767
SOLUTION 
Declaring a constructor private on class A means that you can only access the (private) constructor if you 
could also access A's private methods. Who, oth"
2344,443,"This has direct implications for inheritance, since a subclass calls its parent's constructor. The class A can be 
inherited, but only by its own or its parent's inner classes. 
13.2 Return from Finally: In Java, does the finally block get executed if we insert a return statement 
inside the try blo"
2345,507,"attempt to exit within the try block (via a return statement, a continue statement, a break statement 
or any exception), the finally block will still be executed. 
Note that there are some cases in which the finally block will not get executed, such as the following: 
If the virtual machine exits d"
2346,490,"SOLUTIONS 
pg 767 
Despite their similar sounding names, final, finally and finalize have very different purposes. 
To speak in very general terms, final is used to control whether a variable, method, or class is ""change­
able:' The finally keyword is used in a try/ catch block to ensure that a segm"
2347,502,"Solutions to Chapter 13 I Java
Further detail on these keywords and methods is provided below. 
final 
The final statement has a different meaning depending on its context. 
When 
applied to a variable (primitive): The value of the variable cannot change. 
• When applied to a variable (reference): T"
2348,489,"finally keyword 
There is an optional finally block after the try block or after the catch block. Statements in the 
finally block will always be executed, even if an exception is thrown (except if Java Virtual 
Machine exits 
from the try block). The finally block is often used to write the clean-u"
2349,492,"1 public static String lem() { 
2 System.out.println(""lem""); 
3 return ""return from lem""; 
4 } 
5 
6 public static String foo() { 
7 int X 0j 
8 int y = 5; 
9 try { 
10 System.out.println(""start try""); 
11 int b = y / x; 
12 System.out.println(""end try""); 
13 return ""returned from try""; 
14 } catch "
2350,345,"19 } 
20 } 
21 
22 public static void bar() { 
23 System.out.println(""start bar""); 
24 String v = foo(); 
25 System.out.println(v); 
26 System. out. println(""end bar""); 
27 } 
28 
29 public static void main(String[] args) { 
30 bar(); 
31 } 
The output for this code is the following: 
1 start bar 
4"
2351,440,"2 start try 
3 catch 
4 lem 
5 finally 
6 return from lem \ returned from catch 
7 end bar 
Solutions to Chapter 13 I Java
Look carefully at lines 3 to 5 in the output. The catch block is fully executed (including the function call in 
the return statement), then the finally block, and then the func"
2352,460,"A class can therefore override the finalize () method from the Object class in order to define custom 
behavior during garbage collection. 
1 protected void finalize() throws Throwable { 
2 /* Close open files, release resources, etc */ 
3 } 
13.4 Generics vs. Templates: Explain the difference betwe"
2353,469,"to do something like List<String>. But, how each language does this, and why, varies significantly. 
The implementation of Java generics is rooted in an idea of""type erasure:'This technique eliminates the 
parameterized types when source code is translated to the Java Virtual Machine (JVM) byte code"
2354,485,"3 String str = vector.get(0); 
During compilation, this code is re-written into: 
1 Vector vector = new Vector(); 
2 vector. add (new String(""hello"")); 
3 String str = (String) vector.get(0); 
The use of Java generics didn't really change much about our capabilities; it just made things a bit pretti"
2355,463,"creating a new copy of the template code for each type. Proof of this is in the fact that an instance of 
MyClass<Foo> will not share a static variable with MyClass<Bar>. Two instances ofMyClass<Foo>, 
however, will share a static variable. 
To illustrate this, consider the code below: 
1 /*** MyCla"
2356,509,"Solutions to Chapter 13 I Java
8 /*** MyClass.cpp ***/ 
9 template<typename T> 
10 int MyClass<T>::bar; 
11 
12 template class MyClass<Foo>; 
13 template class MyClass<Bar>; 
14 
15 /*** main.cpp ***/ 
16 MyClass<Foo> * fool 
17 MyClass<Foo> * foo2 
18 MyClass<Bar> * barl 
19 MyClass<Bar> * bar2 
20"
2357,477,"23 int bl barl->val; // will equal 35 
24 int b2 bar2->val; // will equal 35 
In Java, static variables are shared across instances of MyClass, regardless of the different type parameters. 
Java generics and C ++ templates have a number of other differences. These include: 
C ++ templates can use pr"
2358,468,"generics to implement a Ca rd Deck and specify that the type parameter must extend from Ca rdGame. 
In C++, the type parameter can be instantiated, whereas Java does not support this. 
In Java, the type parameter (i.e., the Foo in MyClass< Foo>) cannot be used for static methods and 
variables, sinc"
2359,488,"In Java, all instances of MyClass, regardless of their type parameters, are the same type. The type 
parameters are erased at runtime. In C++, instances with different type parameters are different types. 
Remember: Although Java generics and C ++ templates look the same in many ways, they are very "
2360,442,"pg 167 
SOLUTION 
················'-·«--- .......... .-.. .... h.� •• --.-----·-------
All offer a key->value map and a way to iterate through the keys. The most important distinction between 
these classes is the time guarantees and the ordering of the keys. 
HashMap offers 0(1) lookup and insertio"
2361,469,"• TreeMap offers O(log N) lookup and insertion. Keys are ordered, so if you need to iterate through
the keys in sorted order, you can. This means that keys must implement the Comparable interface.
TreeMap is implemented by a Red-Black Tree. 
LinkedHashMap offers 0(1) lookup and insertion. Keys are o"
2362,46,"436 Cracking the Coding Interview, 6th Edition"
2363,424,"Solutions to Chapter 13 I Java
1 void insertAndPrint(AbstractMap<Integer, String> map) { 
2 int[] array= {1, -1, 0}; 
3 for (int x: array) { 
4 map.put(x, Integer.toString(x)); 
5 } 
6 
7 for (int k: map.keySet()) { 
8 System.out.print(k + "", ""); 
g } 
10 } 
The output for each will look like the re"
2364,473,"the output was, in my own tests, { 0, 1, -1}, but it could be any ordering. There is no guarantee on the 
ordering. 
When might you need ordering in real life? 
Suppose you were creating a mapping of names to Person objects. You might want to periodically 
output the people in alphabetical order by "
2365,441,"""More""function in many applications.
A LinkedHashMap is useful whenever you need the ordering of keys to match the ordering of inser­
tion. This might be useful in a caching situation, when you want to delete the oldest item.
Generally, unless there is a reason not to, you would use HashMap. That is"
2366,496,"then use TreeMap. Otherwise, HashMap is probably best. It is typically faster and requires less overhead. 
13.6 Object Reflection: Explain what object reflection is in Java and why it is useful. 
SOLUTION 
pg 768 
Object Reflection is a feature in Java that provides a way to get reflective informati"
2367,424,"2. Creating a new instance of a class.
3. Getting and setting the object fields directly by getting field reference, regardless of what the access
modifier is.
The code below offers an example of object reflection. 
1 /*Parameters */ 
2 Object[] doubleArgs = new Object[] { 4.2, 3.9 }; 
3 
4 /* Get c"
2368,476,"Solutions to Chapter 13 I Java
7 /* Equivalent: Rectangle rectangle = new Rectangle(4.2, 3.9); */ 
8 Clas s[] doubleArgsClass = new Clas s[] {double.clas s, double.clas s}; 
9 Constr uctor doubleArgsConstr uctor = 
10 rectangleDefinition.getConstructor(doubleArgsClass); 
11 Rectangle rectangle = (Re"
2369,478,"14 Method m = rectangleDefinition.getDeclaredMethod(""area""); 
15 Double area = (Double) m.invoke(rectangle); 
This code does the equivalent of: 
1 Rectangle rectangle = new Rectangle(4.2, 3.9); 
2 Double area = rectangle.area(); 
Why Is Object Reflection Useful? 
Of course, it doesn't seem very usef"
2370,475,"2. It can help you debug or test programs, as you have direct access to methods, constructors, and fields.
3. You can call methods by name when you don't know the method in advance. For example, we may let
the user pass in a class name, parameters for the constructor, and a method name. We can then "
2371,477,"13.7 Lambda Expressions: There is a class Country that has methods getContinent() and 
getPopulation(). Write a function int getPopulation(List<Country> countries, 
String continent) that computes the total population of a given continent, given a list of all 
countries and the name of a continent. "
2372,501,"Then, we need to compute their total population. 
Without lambda expressions, this is fairly straightforward to do. 
1 int getPopulation(List<Country> countries, String continent) { 
2 int sum = 0; 
3 for (Country c : countries) { 
4 if (c.getContinent().equals (continent)) { 
5 sum += c.getPopulati"
2373,174,"1 Stream<Country> northAmerica = countries.stream().filter( 
2 country -> { return country.getContinent().equals (continent);} 
438 Cracking the Coding Interview, 6th Edition"
2374,481,"Solutions to Chapter 13 I Java 
3 ); 
Second, we convert this into a list of populations using map. 
1 Stream<Integer> populations = northAmerica.map( 
2 c -> c.getPopulation() 
3 ); 
Third and finally, we compute the sum using reduce. 
1 int population = populations.reduce(0, (a, b) -> a+ b); 
This"
2375,472,"3 Stream<Country> sublist = countries.str eam().filter( 
4 country -> { return country.getContinent().equals(continent);} 
5 ); 
6 
7 /* Convert to list of populations. */ 
8 Stream<Integer> populations = sublist.map( 
9 c -> c.getPopulation() 
10 ) ; 
11 
12 /* Sum list. */ 
13 int population = pop"
2376,421,"The reduce operation can have logic that maps the population of countries not in the right continent to 
zero. The sum will effectively disregard countries not within continent. 
1 int getPopulation(List<Country> countries, String continent) { 
2 Stream<Integer> populations = countries.stream().map("
2377,456,"4 return populations.reduce(0, (a, b) -> a+ b); 
5 } 
Lambda functions were new to Java 8, so if you don't recognize them, that's probably why. Now is a great 
time to learn about them, though! 
13.8 Lambda Random: Using Lambda expressions, write a function List <Integer> 
getRandomSub set ( List< I"
2378,479,"pg439 
SOLUTION 
It's tempting to approach this problem by picking a subset size from 0 to N and then generating a random 
subset of that size. 
That creates two issues: 
1. We'd 
have to weight those probabilities. If N > 1, there are more subsets of size N/2 than there are of 
subsets of size N (o"
2379,111,"specifically 1 O) than it is to
generate a subset of any size.
CrackingTheCodinglnterview.com I 6th Edition 439"
2380,489,"Solutions to Chapter 13 I Java 
Instead, rather than generating a subset based on sizes, let's think about it based on elements. (The fact 
that we're told to use lambda expressions is also a hint that we should think about some sort of iteration or 
processing through the elements.) 
Imagine we wer"
2381,486,"subsets that contain 1. So, what percent of elements contain 1? 
For any specific element, there are as many subsets that contain the element as do not contain it. Consider 
the following: 
{} 
{2} 
{3} 
{2, 3} 
{1} 
{1, 2} 
{1, 3} 
{l, 2, 3} 
Note how the difference between the subsets on the left "
2382,499,"other by just adding an element. 
This means that we can generate a random subset by iterating through the list and flipping a coin (i.e., 
deciding on a 50/50 chance) to pick whether or not each element will be in it. 
Without lambda expressions, we can write something like this: 
1 List<Integer> g"
2383,435,"5 /* Flip coin. */ 
6 if (random.nextBoolean()) { 
7 subset.add(item); 
8 } 
9 } 
10 return subset; 
11 } 
To implement this approach using lambda expressions, we can do the following: 
1 List<Integer> getRandomSubset(List<Integer> list) { 
2 Random random = new Random(); 
3 List<Integer> subset= li"
2384,419,"5 }).collect(Collectors .tolist()); 
6 return subset; 
7 } 
Or, we can use a predicate (defined within the class or within the function): 
1 Random random = new Random(); 
2 Predicate<Object> flipCoin = o -> { 
3 return random.nextBoolean(); 
4 }; 
5 
6 List<Integer> getRandomSubset(List<Integer> li"
2385,210,"8 collect(Collectors.tolist()); 
9 return subset; 
10 } 
The nice thing about this implementation is that now we can apply the flipCoin predicate in other places. 
440 Cracking the Coding Interview, 6th Edition"
2386,420,"14 
Solutions to Databases 
Questions 1 through 3 refer to the following database schema: 
AptID int BuildingID int RequestID int 
UnitNumber varchar(10) ComplexID int Status varchar(100) 
BuildingID int BuildingName varchar(100) AptID int 
Address varchar(500) Description varchar(500) 
Complexes Ap"
2387,502,"ComplexName I varchar(100) AptID int TenantName varchar(100) 
Note that each apartment can have multiple tenants, and each tenant can have multiple apartments. Each 
apartment belongs to one building, and each building belongs to one complex. 
14.1 Multiple Apartments: Write a SQL query to get a lis"
2388,414,"Tenants. 
1 SELECT TenantName 
2 FROM Tenants 
3 INNER JOIN 
4 (SELECT TenantID FROM AptTenants GROUP BY TenantID HAVING count(*) > 1) C 
5 ON Tenants.TenantID = C.TenantID 
Whenever you write a GROUP BY clause in an interview (or in real life), make sure that anything in the 
SELECT clause is eithe"
2389,478,"Solutions to Chapter 14 I Databases
14.2 Open Requests: Write a SQL query to get a list of all buildings and the number of open requests 
(Requests in which status equals'Open'). 
pg 773
SOLUTION 
This problem uses a straightforward join of Requests and Apartments to get a list of building IDs and 
"
2390,481,"2 FROM Buildings 
3 LEFT JOIN 
4 (SELECT Apartments.BuildingID, count(*) as 'Count' 
5 FROM Requests INNER JOIN Apartments 
6 ON Requests.AptID = Apartments.AptID 
7 WHERE Requests.Status = 'Open' 
8 GROUP BY Apartments.BuildingID) ReqCounts 
9 ON ReqCounts.BuildingID = Buildings.BuildingID 
Queries"
2391,476,"14.3 Close All Requests: Building #11 is undergoing a major renovation. Implement a query to close all 
requests from apartments in this building. 
pg 173
SOLUTION 
UPDATE queries, like SELECT queries, can have WHERE clauses. To implement this query, we get a list of all 
apartment IDs within buildi"
2392,406,"14.4 Joins: What are the different types of joins? Please explain how they differ and why certain types 
are better in certain situations. 
pg 173
SOLUTION 
JOIN is used to combine the results of two tables. To perform a JOIN, each of the tables must have at 
least one field that will be used to fin"
2393,400,"records will go into the result set. 
Let's take for example two tables: one table lists the ""regular"" beverages, and another lists the calorie-free 
beverages. Each table has two fields: the beverage name and its product code. The ""code""field will be used 
to perform the record matching. 
Regular B"
2394,452,"Solutions to Chapter 14 I Databases
Calorie-Free Beverages: 
Diet Coca-Cola COCACOLA 
Fresca FRESCA 
Diet Pepsi PEPSI 
Pepsi Light PEPSI 
Purified Water Water 
If we wanted to join Beverage with Calorie-Free Bevera ges, we would have many options. These 
are discussed below. 
INNER JOIN:The result s"
2395,503,"• OUTER JOIN: An OUTER JOIN will always contain the results of INNER JOIN, but it may also contain
some records that have no matching record in the other table. OUTER JOINs are divided into the
following subtypes:
» LEFT OUTER JOIN, or simply LEFT JOIN:The result will contain all records from the le"
2396,498,"be listed, because it was in the left table.
» RIGHT OUTER JOIN, or simply RIGHT JOIN:This type of join is the opposite ofLEFT JOIN. It
will contain every record from the right table; the missing fields from the left table will be NULL.
Note that if we have two tables, A and B, then we can say that "
2397,452,"» FULL OUTER JOIN: This type of join combines the results of the LEFT and RIGHT JOINS. All
records from both tables will be included in the result set, regardless of whether or not a matching
record exists in the other table. If no matching record was found, then the corresponding result
fields will"
2398,499,"SOLUTION 
pg 773 
Denormalization is a database optimization technique in which we add redundant data to one or more 
tables. This can help us avoid costly joins in a relational database. 
By contrast, in a traditional normalized database, we store data in separate logical tables and attempt to 
min"
2399,240,"in Courses would store the teacherID for a Course but not the teacherName. When we need to 
retrieve a list of all Courses with the Teacher name, we would do a join between these two tables. 
CrackingTheCodinglnterview.com \ 6th Edition 443"
2400,503,"Solutions to Chapter 14 I Databases 
In some ways, this is great; if a teacher changes his or her name, we only have to update the name in one 
place. 
The drawback, however, is that if the tables are large, we may spend an unnecessarily long time doing joins 
on tables. 
Denormalization, then, stri"
2401,422,"tages of fewer joins. 
Updates and inserts are more expensive. 
Denormalization can make update and insert code 
harder to write. 
Data may be inconsistent. Which is the ""correct"" 
value for a piece of data? 
Data redundancy necessitates more storage. 
Retrieving data is faster since we do fewer joi"
2402,449,"fewer tables. 
In a system that demands scalability, like that of any major tech companies, we almost always use elements 
of both normalized and denormalized databases. 
14.6 Entity-Relationship Diagram: Draw an entity-relationship diagram for a database with companies, 
people, and professionals ("
2403,416,"People and Professionals (or we could say that a Professional is derived from People). 
Each Professional has additional information such as degree and work experiences in addition to the 
properties derived from People. 
A Professional works for one company at a time (probably-you might want to val"
2404,342,"Professionals and Companies. This""Works For""relationship can store attributes such as an employee's 
start date and salary. These attributes are defined only when we relate a Professional with a Company. 
A Person can have multiple phone numbers, which is why Phone is a multi-valued attribute. 
444 "
2405,415,"Degree 
Solutions to Chapter 14 I Databases
ISA 
Professional ,__�N��� 
Experience 
Date of 
Joining 
Works For 
Salary 
1 Companies 
Address 
14.7 Design Grade Database: Imagine a simple database storing information for students' grades. 
Design what this database might look like and provide a SQL "
2406,507,"pg 173
SOLUTION 
In a simplistic database, we'll have at least three objects: Students, Courses, and CourseEnrollment. 
Students will have at least a student name and ID and will likely have other personal information. 
Courses will contain the course name and ID and will likely contain the course d"
2407,174,"StudentName 
Address 
Courses 
CourseID 
Course Name 
Profes sor ID 
int 
varchar(100) 
varchar(S00) 
int 
varchar(100) 
int 
CrackingTheCodinglnterview.com I 6th Edition 445"
2408,492,"Solutions to Chapter 14 I Databases
CourseID int 
StudentID int 
Grade float 
Term int 
This database could get arbitrarily more complicated if we wanted to add in professor information, billing 
information, and other data. 
Using the Microsoft SQL Server TOP • • • PERCENT function, we might (incor"
2409,428,"3 FROM CourseEnrollment 
4 GROUP BY CourseEnrollment.StudentID 
5 ORDER BY AVG(CourseEnrollment.Grade) 
The problem with the above code is that it will return literally the top 10% of rows, when sorted by GPA. 
Imagine a scenario in which there are 100 students, and the top 15 students all have 4.0 "
2410,475,"include the students who tied for the top 10% -- even if this means that our honor roll includes more than 
1 0% of the class. 
To correct this issue, we can build something similar to this query, but instead first get the GPA cut off. 
1 DECLARE @GPACutOff float; 
2 SET @GPACutOff = (SELECT min(GPA"
2411,440,"6 ORDER BY GPA desc) Grades); 
Then, once we have @GPACutOff defined, selecting the students with at least this GPA is reasonably 
straightforward. 
1 SELECT StudentName, GPA 
2 FROM (SELECT AVG(CourseEnrollment.Grade) AS GPA, CourseEnrollment.StudentID 
3 FROM CourseEnrollment 
4 GROUP BY CourseEnr"
2412,446,"6 INNER JOIN Students ON Honors.StudentID = Student.StudentID 
Be very careful about what implicit assumptions you make. If you look at the above database description, 
what potentially incorrect assumption do you see? One is that each course can only be taught by one 
professor. At some schools, co"
2413,412,"make is less important than just recognizing that you made assumptions. Incorrect assumptions, both in 
the real world and in an interview, can be dealt with as long as they are acknowledged. 
Remember, addi tionally, that there's a trade-off between flexibility and complexity. Creating a system in "
2414,363,"complexity. If we tried to make our database flexible to every possible situation, we'd wind up with some­
thing hopelessly complex. 
Make your design reasonably flexible, and state any other assumptions or constraints. This goes for not just 
database design, but object-oriented design and programm"
2415,428,"15 
Solutions to Threads and Locks 
15.1 Thread vs. Process: What's the difference between a thread and a process? 
SOLUTION 
Processes and threads are related to each other but are fundamentally different. 
pg 179
A process can be thought of as an instance of a program in execution. A process is an"
2416,473,"address space, and one process cannot access the variables and data structures of another process. If a 
process wishes to access another process' resources, inter-process communications have to be used. These 
include pipes, files, sockets, and other forms. 
A thread exists within a process and sha"
2417,490,"cannot directly access the memory of another process. Each thread still has its own registers and its own 
stack, but other threads can read and write the heap memory. 
A thread is a particular execution path of a process. When one thread modifies a process resource, the 
change is immediately visib"
2418,481,"pg 179
A context switch is the time spent switching between two processes (i.e., bringing a waiting process into 
execution and sending an executing process into waiting/terminated state). This happens in multitasking. 
The operating system must bring the state information of waiting processes into "
2419,239,"the swapping processes. The context switch time is the difference in the timestamps between the two 
processes. 
Let's take an easy example: Assume there are only two processes, P 1 and P 2•
CrackingTheCodinglnterview.com I 6th Edition 447"
2420,506,"Solutions to Chapter 15 I Threads and Locks
p is executing and P is waiting for execution. At some point, the operating system must swap P 1 and P 2 -
1 2 
let's assume it happens at the Nth instruction of P 1. If tx,k indicates the timestamp in microseconds of the 
kth instruction of process x, the"
2421,504,"stamp of every instruction in the process. 
Another issue is that swapping is governed by the scheduling algorithm of the operating system and 
there may be many kernel level threads which are also doing context switches. Other processes could be 
contending for the CPU or the kernel handling interr"
2422,490,"context switch time would be overstated. 
In order to overcome these obstacles, we must first construct an environment such that after P 1 executes, 
the task scheduler immediately selects P 2 to run. This may be accomplished by constructing a data channel, 
such as a pipe, between P 1 and P 2 and h"
2423,505,"awaits the data token. When P 1 executes, it delivers the token over the data channel to P 2 and immediately 
attempts to read a response token. However, since P 2 has not yet had a chance to run, no such token is avail­
able for P 1 and the process is blocked. This relinquishes the CPU. 
A context "
2424,495,"runs, the roles of P 1 and P 2 are swapped. P 2 is now acting as the sender and P 1 as the blocked receiver. The 
game ends when P 2 returns the token to P 1• 
To summarize, an iteration of the game is played with the following steps: 
1. P 2 blocks awaiting data from P 1• 
2. P1 marks the start tim"
2425,410,"6. P 2 sends a response token to P 1• 
7. P 2 attempts read a response token from P 1• This induces a context switch.
8. P 1 is scheduled and receives the token.
9. P1 marks the end time. 
The key is that the delivery of a data token induces a context switch. Let T and T be the time it takes tod r 
"
2426,500,"step 2, P 1 records the timestamp of the delivery of the token, and at step 9, it records the timestamp of the 
response. The amount of time elapsed, T, between these events may be expressed by: 
T = 2 * (Td + T c + T r ) 
This formula arises because of the following events: P 1 sends a token (3), t"
2427,458,"Solutions to Chapter 15 I Threads and Locks
P1 will be able to easily compute T, since this is just the time between events 3 and 8. So, to solve for Tc' we 
must first determine the value of T d + T r· 
How can we do this? We can do this by measuring the length of time it takes P 1 to send and rece"
2428,430,"will not block to receive it. 
The game is played a number of iterations to average out any variability in the elapsed time between steps 
2 and 9 that may result from unexpected kernel interrupts and additional kernel threads contending for the 
CPU. We select the smallest observed context switch t"
2429,505,"For example, we make the assumption that P 2 is selected to run once a data token becomes available. 
However, this is dependent on the implementation of the task scheduler and we cannot make any guar­
antees. 
That's okay; it's important in an interview to recognize when your solution might not be "
2430,420,"chopsticks to eat, and always picks up the left chopstick before the right one. A deadlock could 
potentially occur if all the philosophers reached for the left chopstick at the same time. Using threads 
and locks, implement a simulation of the dining philosophers problem that prevents deadlocks. 
p"
2431,483,"ourselves with deadlocks. We can implement this solution by having Philosopher extend Thread, and 
Chopstick call lock. lock() when it is picked up and lock. unlock() when it is put down. 
1 class Chopstick { 
2 private Lock lock; 
3 
4 public Chopstick() { 
5 lock = new Reentrantlock(); 
6 } 
7 
8 "
2432,227,"18 private int bites = 10; 
19 private Chopstick left, right; 
20 
21 
22 
23 
public Philosopher(Chopstick left, Chopstick right) { 
this.left = left; 
24 } 
this.right= right; 
CrackingTheCodinglnterview.com I 6th Edition 449"
2433,416,"Solutions to Chapter 15 I Threads and Locks
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 } 
public void eat() { 
pickup(); 
chew(); 
putDown(); 
} 
public void pickUp() { 
left.pickup(); 
right. pickUp(); 
} 
public void chew() {} 
public void pu"
2434,473,"} 
for (int i= 0; i < bites; i++) { 
eat(); 
} 
Running the above code may lead to a deadlock if all the philosophers have a left chopstick and are waiting 
for the right one. 
Solution #1: All or Nothing 
To prevent deadlocks, we can implement a strategy where a philosopher will put down his left c"
2435,382,"5 return lock.trylock(); 
6 } 
7 } 
8 
9 public class Philosopher extends.Thread { 
10 /* same as before */ 
11 
12 public void eat() { 
13 if (pickUp()) { 
14 chew(); 
15 putDown(); 
16 } 
17 } 
18 
19 public boolean pickUp() { 
20 /* attempt to pick up */ 
21 if (!left.pickup()) { 
22 return false"
2436,414,"Solutions to Chapter 15 I Threads and Locks 
25 left.putDown(); 
26 return false; 
27 } 
28 return true; 
29 } 
30 } 
In the above code, we need to be sure to release the left chopstick if we can't pick up the right one-and to 
not call putDown () on the chopsticks if we never had them in the first "
2437,498,"pick up their left chopstick, be unable to pick up the right one, and then put back down the left one-only 
to have the process repeated again. 
Solution #2: Prioritized Chopsticks 
Alternatively, we can label the chopsticks with a number from 0 to N - 1. Each philosopher attempts to 
pick up the lo"
2438,501,"does this in reverse. This will break the cycle. 
1 public class Philosopher extends Thread { 
2 private int bites = 10; 
3 private Chopstick lower, higher; 
4 private int index; 
5 public Philosopher(int i, Chopstick left, Chopstick right) { 
6 index = i; 
7 if (left.getNumber() < right.getNumber()"
2439,365,"17 pickup(); 
18 chew(); 
19 putDown(); 
20 } 
21 
22 public void pickUp() { 
23 lower.pickup(); 
24 higher.pickup(); 
25 } 
26 
27 public void chew() { ... } 
28 
29 public void putDown() { 
30 higher.putDown(); 
31 lower.putDown(); 
32 } 
33 
34 public void run() { 
35 for (int i= 0; i < bites; i+"
2440,408,"Solutions to Chapter 1 S I Threads and Locks
37 } 
38 } 
39 } 
40 
41 public class Chopstick { 
42 private Lock lock; 
43 private int number; 
44 
45 public Chopstick(int n) { 
46 lock= new Reentrantlock(); 
47 this.number = n; 
48 } 
49 
50 public void pickup() { 
51 lock.lock(); 
52 } 
53 
54 publ"
2441,510,"57 
58 public int getNumber() { 
59 return number; 
60 } 
61 } 
With this solution, a philosopher can never hold the larger chopstick without holding the smaller one. This 
prevents the ability to have a cycle, since a cycle means that a higher chopstick would ""point""to a lower one. 
15.4 Deadlock-F"
2442,457,"declare upfront what locks it will need. We can then verify if a deadlock would be created by issuing these 
locks, and we can fail if so. 
With these constraints in mind, let's investigate how we can detect deadlocks. Suppose this was the order 
of locks requested: 
A= {1, 2, 3, 4} 
B = {1, 3, 5}
C"
2443,478,"Blocks 3, waits on 5 
C locks 5, waits on 2 
We can think about this as a graph, where 2 is connected to 3, 3 is connected to 5, and 5 is connected to 
2. A deadlock is represented by a cycle. An edge (w, v) exists in the graph if a process declares that it
will request lock v immediately after lock"
2444,76,"of the edge does not matter. 
452 Cracking the Coding Interview, 6th Edition"
2445,470,"Solutions to Chapter 1 S I Threads and Locks
This class will need a declare method, which threads and processes will use to declare what order they 
will request resources in. This declare method will iterate through the declare order, adding each contig­
uous pair of elements (v, w) to the graph. A"
2446,447,"We have one final component to discuss: how do we detect a cycle? We can detect a cycle by doing a 
depth-first search through each connected component (i.e., each connected part of the graph). Complex 
algorithms exist to find all the connected components of a graph, but our work in this problem do"
2447,498,"first search touches all of these edges at some point, then we know that we have fully searched for a cycle. 
The pseudocode for this special case cycle detection looks like this: 
1 boolean checkForCycle(locks[] locks) { 
2 touchedNodes = hash table(lock -> boolean) 
3 initialize touchedNodes to fa"
2448,430,"7 
8 } 
9 } 
10 } 
return true; 
11 return false; 
12 } 
13 
14 boolean hasCycle(node x, touchedNodes) { 
15 touchedNodes[r] = true; 
16 if (x.state == VISITING) { 
17 return true; 
18 } else if (x.state == FRESH) { 
19 ... (see full code below) 
20 } 
21 } 
In the above code, note that we may do se"
2449,488,"The code below provides further details. For simplicity, we assume that all locks and processes (owners) are 
ordered sequentially. 
1 class LockFactory { 
2 private static LockFactory instance; 
3 
4 private int numberOfLocks = 5; /*default */ 
5 private LockNode[] locks; 
6 
7 /* Maps from a proce"
2450,292,"10 
11 private LockFactory(int count) { ... } 
12 public static LockFactory getinstance() { return instance; } 
13 
14 public static synchronized LockFactory initialize(int count) { 
15 if (instance == null) instance = new LockFactory(count); 
CrackingTheCodinglnterview.com / 6th Edition 453"
2451,510,"Solutions to Chapter 15 I Threads and Locks 
16 return instance; 
17 } 
18 
19 public boolean hasCycle(HashMap<Integer, Boolean> touchedNodes, 
20 int[] resourcesinOrder) { 
21 /* check for a cycle*/ 
22 for (int resource : resourcesinOrder) { 
23 if (touchedNodes.get(resource) == false) { 
24 LockN"
2452,479,"34 * will need the locks in. Verify that this order does not create a deadlock (a
35 * cycle in a directed graph)*/
36 public boolean declare(int ownerid, int[] resourcesinOrder) {
37 HashMap<Integer, Boolean> touchedNodes = new HashMap<Integer, Boolean>(); 
38 
39 /* add nodes to graph*/ 
4-0 int i"
2453,498,"43 LockNode prev = locks[resourcesinOrder[index - 1)]; 
44 LockNode curr = locks [ resourcesinOrder [index]]; 
45 prev.joinTo(curr); 
46 touchedNodes.put(resourcesinOrder[index], false); 
47 } 
48 
49 /* if we created a cycle, destroy this resource list and return false*/ 
50 if (hasCycle(touchedNod"
2454,481,"54 
55 } 
p.remove(c);
56 return false; 
57 } 
58 
59 /* No cycles detected. Save 
the order that was declared, so that we can 
60 * verify that the process is really calling the locks in the order it said
61 * it would. */
62 LinkedList<LockNode> list= new Linkedlist<LockNode>();
63 for (int i= 0; "
2455,77,"68 
69 return true; 
70 } 
71 
454 Cracking the Coding Interview, 6th Edition"
2456,504,"Solutions to Chapter 15 I Threads and Locks 
72 /* Get the lock, verifying first that the process is really calling the locks in 
73 * the order it said it would. */
74 public Lock getLock(int ownerid, int resourceID) {
75 Linkedlist<LockNode> list= lockOrder.get(ownerid); 
76 if (list == null) retu"
2457,492,"83 return null; 
84 } 
85 } 
86 
87 public class LockNode { 
88 public enum VisitState { FRESH, VISITING, VISITED}; 
89 
90 private ArrayList<LockNode> children; 
91 private int lockid; 
92 private Lock lock; 
93 private int maxLocks; 
94 
95 public LockNode(int id, int max) { ... } 
96 
97 /* Join "
2458,509,"100 
101 /* Check for a cycle by doing a depth-first-search. */ 
102 public boolean hasCycle(HashMap<Integer, Boolean> touchedNodes) { 
103 VisitState[] visited= new VisitState[maxLocks]; 
104 for (int i= 0; i < maxlocks; i++) { 
105 visited[i] = VisitState.FRESH; 
106 } 
107 return hasCycle(visited"
2459,467,"113 touchedNodes.put(lockid, true); 
114 } 
115 
116 if (visited[lockid] == VisitState.VISITING) { 
117 /* We looped back to this node while still visiting it, so we know there's 
118 * a cycle. */
119 return true;
120 } else if (visited[lockid] == VisitState.FRESH) { 
121 visited[lockid] = VisitSta"
2460,105,"125 } 
126 } 
127 visited[lockid] = VisitState.VISITED; 
CrackingTheCodinglnterview.com I 6th Edition 4SS"
2461,503,"Solutions to Chapter 15 I Threads and Locks
128 } 
129 return false; 
130 } 
131 
132 public Lock getlock() { 
133 if (lock== null) lock= new Reentrantlock(); 
134 return lock; 
135 } 
136 
137 public int getld() { return lockld; } 
138 } 
As always, when you see code this complicated and lengthy, y"
2462,455,"15.5 Call In Order: Suppose we have the following code: 
public class Foo { 
public Foo() { ... } 
public void first() { ... } 
public void second() { ... } 
public void third() { ... } 
} 
The same instance of Foo will be passed to three different threads. ThreadA will call first threadB 
will call"
2463,506,"pg 180 
SOLUTION 
The general logic is to check if first() has completed before executing second(), and if second() 
has completed before calling third (). Because we need to be very careful about thread safety, simple 
boolean flags won't do the job. 
What about using a lock to do something like th"
2464,307,"8 
9 
lockl new Reentrantlock(); 
lock2 new Reentrantlock(); 
10 lockl.lock(); 
11 lock2.lock(); 
12 } catch( ... ) { ... } 
13 } 
14 
15 public void first() { 
16 try { 
17 
18 lockl.unlock(); // mark finished with first() 
19 } catch ( ... ) { . . . } 
20 } 
456 Cracking the Coding Interview, 6th "
2465,425,"21 
22 
23 
public void second() { 
try { 
Solutions to Chapter 15 I Threads and Locks
24 
25 
lockl.lock(); // wait until finished with first() 
lockl.unlock(); 
26 
27 
28 
29 
lock2.unlock(); // mark finished with second() 
} catch ( ... ) 
{ ... } 
30 
31 
32 
33 
} 
public void third() { 
try {"
2466,505,"36 
37 
38 
39 } 
} catch ( ... ) { . . . } 
} 
This code won't actually quite work due to the concept of lock ownership. One thread is actually performing 
the lock (in the FooBad constructor), but different threads attempt to unlock the locks. This is not allowed, 
and your code will raise an exce"
2467,493,"1 public class Foo { 
2 public Semaphore seml, sem2; 
3 
4 public Foo() { 
5 try { 
6 
7 
8 
seml new Semaphore(l); 
sem2 new Semaphore(l); 
9 seml.acquire(); 
10 sem2.acquire(); 
11 } catch ( ... ) { . . . } 
12 } 
13 
14 public void first() { 
15 try { 
16 
17 seml.release(); 
18 } catch ( ... ) {"
2468,114,"28 } 
29 
30 public void third() { 
31 try { 
32 sem2.acquire(); 
CrackingTheCodinglnterview.com I 6th Edition 457"
2469,465,"Solutions to Chapter 15 I Threads and Locks
33 sem2.release(); 
34 
35 } catch ( .•. ) { . • • } 
36 } 
37 } 
15.6 Synchronized Methods: You are given a class with synchronized method A and a normal 
method B. If you have two threads in one instance of a program, can they both execute A at the 
same"
2470,503,"nized methods on the same object instance at the same time. 
So, the answer to the first part really depends. If the two threads have the same instance of the object, then 
no, they cannot simultaneously execute method A. However, if they have different instances of the object, 
then they can. 
Conc"
2471,469,"methods within that instance. 
In the second part, we're asked if threadl can execute synchronized method A while thread2 is 
executing non-synchronized method B. Since B is not synchronized, there is nothing to block threadl 
from executing A while thread2 is executing B. This is true regardless of"
2472,480,"instance of that object. Other threads can execute non-synchronized methods on that instance, or they can 
execute any method on a different instance of the object. 
15.7 FizzBuzz: In the classic problem FizzBuzz, you are told to print the numbers from 1 to n. However, 
when the number is divisible "
2473,420,"Implement a multithreaded version of FizzBuzz with four threads. One thread checks for divisibility 
of 3 and prints""Fizz''. Another thread is responsible for divisibility of 5 and prints""Buzz''. A third thread 
is responsible for divisibility of 3 and 5 and prints ""FizzBuzz''. A fourth thread does "
2474,481,"Single Threaded 
Although this problem (in the single threaded version) shouldn't be hard, a lot of candidates overcompli­
cate it. They look for something ""beautiful""that reuses the fact that the divisible by 3 and 5 case (""FizzBuzz"") 
seems to resemble the individual cases (""Fizz"" and ""Buzz""). 
In"
2475,444,"Solutions to Chapter 15 \ Threads and Locks
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 } 
for (inti= 1; i <= n; i++) { 
} 
if (i % 3 == 0 && i % 5 == 0) { 
System.out.println(""FizzBuzz""); 
} else if (i % 3 == 0) { 
System.out.println(""Fizz""); 
} else if (i % 5 == 0) { 
System.out.println(""Buzz""); 
} els"
2476,504,"3 before the check for divisibility by 3 and 5, it won't print the right thing. 
Multithreaded 
To do this multithreaded, we want a structure that looks something like this: 
FiizBuzz Thread 
if i div by 3 && 5 
print FizzBuzz 
increment i 
repeat until i > n 
if i div by only 5 
print Buzz 
increme"
2477,448,"if i div by only 3 
print Fizz 
increment i 
repeat until i > n 
if i not div by 3 or 5 
print i 
increment i 
repeat until i > n 
6 System.out.println(/* print something*/); 
7 current++; 
8 } 
9 } 
We'll need to add some synchronization in the loop. Otherwise, the value of current could change 
be"
2478,458,"tionally, incrementing is not thread-safe. 
To actually implement this concept, there are many possibilities. One possibility is to have four entirely 
separate thread classes that share a reference to the current variable (which can be wrapped in an object). 
The loop for each thread is substantial"
2479,509,"Solutions to Chapter 1 S I Threads and Locks 
current % 3 == 0 true true false false 
current% 5 == 0 true false true false 
to print FizzBuzz Fizz Buzz current 
For the most part, this can be handled by taking in ""target"" parameters and the value to print. The output for 
the Number thread needs to"
2480,503,"extend FizzBuzzThread and override the print method. 
1 Thread[] threads = {new FizzBuzzThread(true, true, n, ""FizzBuzz""), 
2 new FizzBuzzThread(true, false, n, ""Fizz""), 
3 new FizzBuzzThread(false, true, n, ""Buzz""), 
4 new NumberThread(false, false, n)}; 
5 for (Thread thread : threads) { 
6 thread"
2481,509,"12 private int max; 
13 private boolean div3, div5; 
14 private String toPrint; 
15 
16 public FizzBuzzThread(boolean div3, boolean divs, int max, String toPrint) { 
17 this.div3 = div3; 
18 this.divs= divs; 
19 this.max = max; 
20 this.toPrint = toPrint; 
21 } 
22 
23 public void print() { 
24 Syst"
2482,243,"35 
36 
37 
38 
39 
40 
41 
42 
43 
} 
}
} 
} 
if 
}
}
return; 
( (current % 3 
(current % 5 
print(); 
current++; 
0) 
0) 
div3 && 
divs) { 
44 public class NumberThread extends FizzBuzzThread { 
460 Cracking the Coding Interview, 6th Edition"
2483,502,"Solutions to Chapter 15 I Threads and Locks
45 public NumberThread(boolean div3, boolean div5, int max) { 
46 super(div3, divs, max, null); 
47 } 
48 
49 public void print() { 
S0 System.out.println(current); 
51 } 
52 } 
Observe that we need to put the comparison of current and max before the if st"
2484,508,"can pass in a validate method and a print method as parameters. 
1 
2 
3 
4 
5 
6 
7 
8 
int n = 100; 
Thread[] threads = { 
new FBThread(i -> 
new FBThread(i -> 
new FBThread(i -> 
new FBThread(i -> 
for (Thread thread 
thread. start(); 
9 } 
10 
i % 3 == 0 && i % 5 
i % 3 0 && i % 5 
i % 3 != 0 &&"
2485,504,"13 protected static int current= 1; 
14 private int max; 
15 private Predicate<Integer> validate; 
16 private Function<Integer, String> printer; 
17 int X = 1; 
18 
19 public FBThread(Predicate<Integer> validate, 
i -> ""FizzBuzz"", n), 
i -> ""Fizz"", n), 
i -> 11 Buzz"", n), 
i -> Integer.toString(i), "
2486,338,"27 while (true) { 
28 synchronized (lock) { 
29 if (current > max) { 
30 return; 
31 } 
32 if (validate.test(current)) { 
33 System.out.println(printer.apply(current)); 
34 current++; 
35 
36 
37 } 
38 } 
39 } 
} 
} 
There are of course many other ways of implementing this as well. 
n)}; 
CrackingTh"
2487,492,"16 
Solutions to Moderate 
16.1 Number Swapper: Write a function to swap a number in place (that is, without temporary variables). 
pg 787
SOLUTION 
----·--·····-···------·- .... ,,·---·-····-··--·----······-
-·--···· ----••••••""-- ··•••-.,.-- , ,· ,v ____ ••«•··--
This is a classic interview proble"
2488,502,"the value of a0 - b0• 
Let's picture these on a number line for the case where a > b. 
diff 
0 
First, we briefly set a to di ff, which is the right side of the above number line. Then, when we add b and 
di ff (and store that value in b), we get a0• We now have b = a0 and a = di ff. All that's left"
2489,455,"3 b =a + b; // b 
= 5 + 4 = 9 
4 a = b - a; // a = 9 - 5 
We can implement a similar solution with bit manipulation. The benefit of this solution is that it works for 
more data types than just integers. 
1 // Example for a= 101 (in binary) and b = 110 
2 a a Ab; // a 101A110 011 
3 b = aAb; // b = "
2490,330,"can correctly swap two bits, then we know the entire operation works correctly. 
Let's take two bits, x and y, and walk through this line by line. 
1. x = x A y 
This line essentially checks if x and y have different values. It will result in 1 if and only if x ! = y.
2. 
y = X A y 
462 Cracking the"
2491,472,"Solutions to Chapter 16 I Moderate
Or:y = {0 if originally same, 1 if different} A {original y} 
Observe that XORing a bit with 1 always flips the bit, whereas XO Ring with O will never change it. 
Therefore, if we do y 
= 1 A { original y} when x ! = y, then y will be flipped and therefore have 
x'"
2492,495,"3.
X = X A Y 
Or:x {0 if originally same, 1 if different}"" {original x} 
At this point, y is equal to the original value of x. This line is essentially equivalent to the line above 
it, 
but for different variables. 
If we do x 1 A { original x} when the values are different, x will be flipped. 
If "
2493,461,"16.2 Word Frequencies: Design a method to find the frequency of occurrences of any given word in a 
book. What if we were running this algorithm multiple times? 
pg 181
SOLUTION 
Let's start with the simple case. 
Solution: Single Query 
In this case, we simply go through the book, word by word, and"
2494,510,"in the book. 
1 int getFrequency(String[] book, String word) { 
2 word= word.trim().tolowerCase(); 
3 int count= 0; 
4 for (String w: book) { 
5 if (w.trim().toLowerCase().equals(word)) { 
5 count++; 
7 } 
8 } 
9 return count; 
10 } 
We have also converted the string to lowercase and trimmed it. You"
2495,343,"to do pre-processing on the book. We can create a hash table which maps from a word to its frequency. The 
frequency of any word can be easily looked up in O ( 1) time. The code for this is below. 
1 HashMap<String, Integer> setupDictionary(String[] book) { 
2 HashMap<String, Integer> table = 
Crack"
2496,485,"Solutions to Chapter 16 I Moderate
3 new HashMap<String, Integer>(); 
4 for (String word : book) { 
5 word= word.toLowerCase(); 
6 if (word. trim() ! = """") { 
7 if (! table.containsKey(word)) { 
8 table.put(word, 0); 
9 } 
10 table.put(word, table.get(word) + 1); 
11 } 
12 } 
13 return table; 
14 } "
2497,505,"19 if (table.containsKey(word)) { 
20 return table.get(word); 
21 } 
22 return 0; 
23 } 
Note that a problem like this is actually relatively easy. Thus, the interviewer is going to be looking heavily 
at how careful you are. Did you check for error conditions? 
16.3 Intersection: Given two straight"
2498,507,"For two infinite lines to intersect, they only have to have different slopes. If they have the same slope, then 
they must be the exact same line (same y-intercept). That is: 
slope 1 != slope 2 
OR 
slope 1 slope 2 AND intersect 1 == intersect 2 
For two straight lines to intersect, the condition a"
2499,478,"AND 
intersection is within line segment 2 (x and y coordinates) 
What if the two segments represent the same infinite line? In this case, we have to ensure that some portion 
of their segments overlap. If we order the line segments by their x locations (start is before end, point 1 is 
before point"
2500,132,"start2 is between startl and endl 
We can now go ahead and implement this algorithm. 
464 Cracking the Coding Interview, 6th Edition"
2501,505,"Solutions to Chapter 16 I Moderate 
1 Point intersection(Point startl, Point endl, Point start2, Point end2) { 
2 /* Rearranging these so that, in order of x values: start is before end and 
3 * point 1 is before point 2. This will make some of the later logic simpler. */
4 if (startl.x > endl.x) sw"
2502,496,"10 
11 /* Compute lines (including slope 
and y-intercept). */ 
12 Line linel new Line(startl, endl); 
13 Line line2 = new Line(start2, end2); 
14 
15 /* If the lines are parallel, they intercept only if they have the same y 
16 * intercept and start 2 is on line 1. */
17 if (linel.slope == line2.sl"
2503,480,"23 } 
24 
25 /* Get intersection coordinate. */ 
26 double x 
= (line2.yintercept - linel.yintercept) / (linel.slope - line2.slope); 
27 double y = x * linel.slope + linel.yintercept; 
28 Point intersection = new Point(x, y); 
29 
30 /* Check if within line segment range. */ 
31 if (isBetween(startl"
2504,480,"36 } 
37 
38 /* Checks if middle is between start and end. */ 
39 boolean isBetween(double start, double middle, double end) { 
40 if (start > end) { 
41 return end<= middle && middle<= start; 
42 } else { 
43 return start<= middle && middle<= end; 
44 } 
45 } 
46 
47 /* Checks if middle is between "
2505,228,"50 isBetween(start.y, middle.y, end.y); 
51 } 
52 
;3 /* Swap coordinates of point one and two. */ 
54 void swap(Point one, Point two) { 
55 double x one.x; 
S5 double y = one.y; 
CrackingTheCodinglnterview.com I 6th Edition 465"
2506,505,"Solutions to Chapter 16 I Moderate
57 
58 
59 } 
60 
one.setlocation(two.x, two.y); 
two.setlocation(x, y); 
61 public class Line { 
62 public double slope, yintercept; 
63 
64 public Line(Point start, Point end) { 
65 double deltaY = end.y - start.y; 
66 double deltaX = end.x - start.x; 
67 slope ="
2507,422,"72 public double x, y; 
73 public Point(double x, double y) { 
74 this.x x; 
75 this.y = y; 
76 } 
77 
78 public void setlocation(double x, double y) { 
79 this.x x; 
80 this.y = y; 
81 } 
82 } 
For simplicity and compactness (it really makes the code easier to read), we've chosen to make the variab"
2508,449,"of this choice. 
16.4 Tic Tac Win: Design an algorithm to figure out if someone has won a game of tic-tac-toe. 
SOLUTION 
pg 181 
At first glance, this problem seems really straightforward. We're just checking a tic-tac-toe board; how hard 
could it be? It turns out that the problem is a bit more co"
2509,425,"There are a few major design decisions to consider: 
1. Will has Won be called just once or many times (for instance, as part of a tic-tac-toe website)? If the latter
is the case, we may want to add pre-processing time to optimize the runtime of ha sWon.
2. Do we know the last move that was made?
3."
2510,299,"as an NxN solution?
4. In general, how much do we prioritize compactness of code versus speed of execution vs. clarity of
code? Remember: The most efficient code may not always be the best. Your ability to understand and
maintain the code matters, too.
466 Cracking the Coding Interview, 6th Edition"
2511,481,"Solutions to Chapter 16 I Moderate 
Solution #1: If haswon is called many times 
There are only 39, or about 20,000, tic-tac-toe boards (assuming a 3x3 board). Therefore, we can represent 
our tic-tac-toe board as an int, with each digit representing a piece (0 means Empty, 1 means Red, 2 means 
Blu"
2512,491,"1 Piece hasWon(int board) { 
2 return winnerHashtable[board]; 
3 } 
To convert a board (represented by a char array) to an int, we can use what is essentially a ""base 3"" repre­
sentation. Each board is represented as 3°v 0 + 31v 1 + Yv 2 + . . . + 38v 8, where vi is a 0 if the space is 
empty, a 1 i"
2513,482,"4 int sum = 0; 
5 for (int i= 0; i < board.length; i++) { 
6 for (int j = 0; j < board[i].length; j++) { 
7 /* Each value in enum has an integer associated with it. We 
8 * can just use that. */
9 int value board[i][j].ordinal();
10 
11 } 
12 } 
sum = sum * 3 + value;
13 return sum; 
14 } 
Now looki"
2514,466,"haven't saved ourselves any time compared with the other solutions. But, if we can store the board this way 
from the very beginning, then the lookup process will be very efficient. 
Solution #2: If we know the last move 
If we know the very last move that was made (and we've been checking for a win"
2515,480,"1 Piece hasWon(Piece[][] board, int row, int column) { 
2 if (board.length != board[0].length) return Piece.Empty; 
3 
4 Piece piece = board[row][column]; 
5 
6 if (piece == Piece.Empty) return Piece.Empty; 
7 
8 if (hasWonRow(board, row) I I hasWonColumn(board, column)) { 
9 return piece; 
10 } 
11"
2516,72,"17 return piece; 
18 } 
CrackingTheCodinglnterview.com J 6th Edition 467"
2517,476,"Solutions to Chapter 16 I Moderate
19 
20 return Piece.Empty; 
21 } 
22 
23 boolean hasWonRow(Piece[][] board, int row) { 
24 for (int c = 1; c < board[row].length; c++) { 
25 if (board[row][c] != board[row][0]) { 
26 return false; 
27 } 
28 } 
29 return true; 
30 } 
31 
32 boolean hasWonColumn(Piec"
2518,507,"35 return false; 
36 } 
37 } 
38 return true; 
39 } 
40 
41 boolean hasWonDiagonal(Piece[][] board, int direction) { 
42 int row = 0; 
43 int column = direction == 1? 0: board.length - 1; 
44 Piece first= board[0][column]; 
45 for (int i= 0; i < board.length; i++) { 
46 if (board[row][column] != fir"
2519,454,"in a later function. 
Solution #3: Designing for just a 3x3 board 
If we really only want to implement a solution for a 3x3 board, the code is relatively short and simple. The 
only complex part is trying to be clean and organized, without writing too much duplicated code. 
The code below checks eac"
2520,317,"2 for (int i= 0; i < board.length; i++) { 
3 /* Check Rows */ 
4 if (hasWinner(board[i][0], board[i][l], board[i][2])) { 
5 return board[i][0]; 
6 
7 
8 
9 
10 
11 
468 
} 
/* Check Columns */ 
if (hasWinner(board[0][i], board[l][i], board[2][i])) { 
return board[0][i]; 
} 
Cracking the Coding Inter"
2521,434,"12 } 
13 
14 /* Check Diagonal */ 
Solutions to Chapter 16 I Moderate
15 if (hasWinner(board[0][0], board[l][l], board[2][2])) { 
16 return board[0][0]; 
17 } 
18 
19 if (hasWinner(board[0][2], board[l][l], board[2][0])) { 
26 return board[0][2]; 
21 } 
22 
23 return Piece.Empty; 
24 } 
25 
26 boole"
2522,492,"28 return false; 
29 }
30 return pl== p2 && p2 == p3; 
31 } 
This is an okay solution in that it's relatively easy to understand what is going on. The problem is that the 
values are hard coded. It's easy to accidentally type the wrong indices. 
Additionally, it won't be easy to scale this to an NxN"
2523,505,"The most obvious way is through a series of nested for-loops. 
1 Piece hasWon(Piece[][] board) { 
2 int size = board.length; 
3 if (board[0].length != size) return Piece.Empty; 
4 Piece first; 
5 
6 /* Check rows. */ 
7 for (int i= 0; i < size; i++) { 
8 first = board[i][0]; 
9 if (first == Piece.Em"
2524,264,"15 } 
16 } 
17 } 
18 
19 /* Check columns. */ 
20 for (int i= 0; i < size; i++) { 
21 first - board[0][i]; 
22 if (first== Piece.Empty) continue; 
23 for (int j = 1; j < size; j++) { 
24 if (board[j][i] != first) { 
CrackingTheCodinglnterview.com I 6th Edition 469"
2525,510,"Solutions to Chapter 16 I Moderate 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 } 
} 
} 
break; 
} else if (j == size - 1) {//Last element 
return first; 
} 
/* Check diagonals. */ 
first= board[0][0]; 
if (first != P"
2526,507,"} 
first= board[0][size - 1]; 
if (first != Piece.Empty) { 
} 
for (int i= 1; i < size; i++) { 
if (board[i][size - i - 1] != first) { 
break; 
} else if (i == size - 1) {//Last element 
return first; 
} 
} 
return Piece.Empty; 
This is, to the say the least, pretty ugly. We're doing nearly the same"
2527,500,"decrements the rows and columns. The hasWon function now just needs the starting position and the 
amount to increment the row and column by. 
1 class Check { 
2 public int row, column; 
3 private int rowincrement, columnincrement; 
4 public Check(int row, int column, int row!, int coll) { 
5 this.r"
2528,127,"13 column += column!ncrement; 
14 } 
15 
16 public boolean inBounds(int size) { 
470 Cracking the Coding Interview, 6th Edition"
2529,482,"Solutions to Chapter 16 I Moderate
17 return row>= 0 && column>= 0 && row< size && column< size; 
18 } 
19 }
20 
21 Piece hasWon(Piece[][] board) { 
22 if (board.length != board[0].length) return Piece.Empty; 
23 int size = board.length; 
24 
25 /* Create list of things to check. */ 
26 Arraylist<Ch"
2530,492,"29 instructions.add(new Check(i, 0, 0, 1)); 
30 } 
31 instructions.add(new Check(0, 0, 1, 1)); 
32 instructions.add(new Check(0, size - 1, 1, -1)); 
33 
34 /* Check them. */ 
35 for (Check instr : instructions) { 
36 Piece winner= hasWon(board, instr); 
37 if (winner != Piece.Empty) { 
38 return win"
2531,443,"46 while (instr.inBounds(board.length)) { 
47 if (board[instr.row][instr.column] != first) { 
48 return Piece.Empty; 
49 } 
50 instr.increment(); 
51 } 
52 return first; 
53 } 
The Cheek function is essentially operating as an iterator. 
Iterator 
Another way of doing it is, of course, to actually b"
2532,471,"3 int size = board.length; 
4 
5 Arraylist<Positionlterator> instructions= new Arraylist<Positionlterator>(); 
6 for (int i= 0; i < board.length; i++) { 
7 instructions.add(new Positionlterator(new Position(0, i), 1, 0, size)); 
8 instructions.add(new Positionlterator(new Position(i, 0), 0, 1, size)"
2533,148,"12 
13 for (Positionlterator iterator : instructions) { 
14 Piece winner= hasWon(board, iterator); 
CrackingTheCodinglnterview.com I 6th Edition 471"
2534,501,"Solutions to Chapter 16 I Moderate 
15 if (winner != Piece.Empty) { 
16 return winner; 
17 } 
18 } 
19 return Piece.Empty; 
20 } 
21 
22 Piece hasWon(Piece[][] board, Positioniterator iterator) { 
23 Position firstPosition = iterator.next(); 
24 Piece first= board[firstPosition.row][firstPosition.co"
2535,490,"28 return Piece.Empty; 
29 } 
30 } 
31 return first; 
32 } 
33 
34 class Positioniterator implements Iterator<Position> { 
35 private int rowincrement, co1Increment, size; 
36 private Position current; 
37 
38 public Positioniterator(Position p, int rowincrement, 
39 int co1Increment, int size) { 
4"
2536,480,"44 } 
45 
46 @Override 
47 public boolean hasNext() { 
48 return current.row + rowincrement < size && 
49 current.column + co1Increment < size; 
50 } 
51 
52 @Override 
53 public Position next() { 
54 current = new Position(current.row + rowincrement, 
55 current.column + co1Increment); 
56 return c"
2537,310,"63 this.row = row; 
64 this.column = column; 
65 } 
66 } 
All of this is potentially overkill, but it's worth discussing the options with your interviewer. The point of this 
problem is to assess your understanding of how to code in a clean and maintainable way. 
472 Cracking the Coding Interview, 6"
2538,471,"Solutions to Chapter 16 I Moderate 
16.5 Factorial zeros: Write an algorithm which computes the number of trailing zeros in n factorial. 
pg 787 
SOLUTION 
A simple approach is to compute the factorial, and then count the number of trailing zeros by continu­
ously dividing by ten. The problem with t"
2539,447,"Consider a factorial like 19 ! : 
19! = 1*2*3*4*5*6*7*8*9*10*11*12*13*14*15*16*17*18*19 
A trailing zero is created with multiples of 10, and multiples of 10 are created with pairs of 5-multiples and 
2-multiples.
For example, in 19!, the following terms create the trailing zeros: 
19! 
= 2 * ... * "
2540,507,"always be more multiples of 2 than 5, though, so simply counting the number of multiples of 5 is sufficient. 
One ""gotcha"" here is 15 contributes a multiple of 5 (and therefore one trailing zero), while 25 contributes 
two (because 25 = 5 * 5). 
There are two different ways to write this code. 
The "
2541,501,"2 * 25-> 2, etc. */
3 int factors0f5(int i) { 
4 int count= 
0; 
5 while (i % 5 == 0) { 
6 count++; 
7 i /= 5; 
8 } 
9 return count;
10 } 
11 
12 int countFactZeros(int 
num) { 
13 int count= 0; 
14 for (int i= 2; i <= num; i+ +) { 
15 count += factorsOfS(i); 
16 } 
17 return count; 
18 } 
This isn'"
2542,262,"number of multiples of 25 (/'is), then 125, and so on . 
To count how many multiples of mare in n, we can just divide n by m. 
1 int countFactZeros(int num) { 
2 lnt count= 0; 
3 if (num < 0) { 
4 return -1; 
5 } 
CrackingTheCodinglnterview.com I 6th Edition 473"
2543,496,"Solutions to Chapter 16 Moderate
6 for (int i= 5; num / i > 0; i *= 5) { 
7 count+= num / i; 
8 } 
9 return count; 
10 } 
This problem is a bit of a brainteaser, but it can be approached logically (as shown above). By thinking 
through what exactly will contribute a zero, you can come up with a solu"
2544,451,"array) with the smallest (non-negative) difference. Return the difference. 
EXAMPLE 
Input: {l, 3, 15, 11, 2}, {23, 127, 235, 19, 8} 
Output: 3. That is, the pair (11, 8). 
SOLUTION 
Let's start first with a brute force solution. 
Brute Force 
pg 181 
The simple brute force way is to just iterate th"
2545,474,"1 int findSmallestDifference(int[] arrayl, int[] array2) { 
2 if (arrayl.length == 0 I I array2.length == 0) return -1; 
3 
4 int min = Integer.MAX_VALUE; 
5 for (inti= 0; i < arrayl.length; i++) { 
6 for (int j = 0; j < array2.length; j++) { 
7 if (Math.abs(arrayl[i] - array2[j]) < min) { 
8 min = "
2546,460,"zero, since this is the smallest difference possible. However, depending on the input, this might actually be 
slower. 
This will only be faster if there's a pair with difference zero early in the list of pairs. But to add this optimiza­
tion, we need to execute an additional line of code each time."
2547,274,"With or without this ""optimization;' the algorithm will take O(AB) time. 
Optimal 
A more optimal approach is to sort the arrays. Once the arrays are sorted, we can find the minimum differ­
ence by iterating through the array. 
474 Cracking the Coding Interview, 6th Edition"
2548,506,"Solutions to Chapter 16 I Moderate
Consider the following two arrays: 
A: {l, 2, 11, 15} 
B: {4, 12, 19, 23, 127, 235} 
Try the following approach: 
1. Suppose a pointer a 
points to the beginning of A and a pointer b points to the beginning of B. The
current difference between a and bi s 3. Store t"
2549,464,"larger. Therefore, we want to move a.
3. Now a points to 2 and b (still) points to 4. This difference is 2, so we should update min. Move a, since
it is smaller.
4. Now a points to 11 and b points to 4. Move b.
5. Now a points to 11 and b points to 12. Update min to 1. Move b.
And so on. 
1 int find"
2550,452,"= 0; 
5 int b = 0;
6 int difference = 
Integer.MAX_VALUE; 
7 while (a < arrayl.length && b < array2.length) { 
8 if (Math.abs(arrayl[a] - array2[b]) < difference) { 
9 difference = Math.abs(arrayl[a] - array2[b]); 
10 } 
11 
12 /* Move smaller value. */ 
13 if (arrayl[a) < array2[b]) { 
14 a++; 
15 "
2551,468,"difference. Therefore, the overall runtime is O(A log A + B log B). 
16.7 Number Max: Write a method that finds the maximum of two numbers. You should not use if-else 
or any other comparison operator. 
pg 787
SOLUTION 
A common way of implementing a max function is to look at the sign of a - b. In "
2552,187,"We can then implement the code as follows: 
0. Let q be the inverse of k.
1 /* Flips a 
1 to a 0 and a 0 to a 1 */ 
2 int flip(int bit) { 
CrackingTheCodinglnterview.com I 6th Edition 47S"
2553,503,"Solutions to Chapter 16 I Moderate
3 return lAbit; 
4 } 
5 
6 I* Returns 1 if a is positive, and 0 if a is negative *I
7 int sign(int a) { 
8 return flip((a >> 31) & 0xl); 
9 } 
10 
11 int getMaxNaive(int a, int b) { 
12 int k = sign(a - b); 
13 int q = flip(k); 
14 return a* k + b * q; 
15 }
This c"
2554,429,"in a negative value. 
We can implement a solution to this problem by using the same approach. Our goal is to maintain the 
condition where k is 1 when a > b. We will need to use more complex logic to accomplish this. 
When does a - b overflow? It will overflow only when a is positive and b is negati"
2555,509,"different signs. Note that if a and b have different signs, then we want k to equal sign (a). 
The logic looks like: 
1 if a and b have different signs: 
2 
3 
4 
5 
6 
I I if 
I I if 
II so 
let k 
else 
a> 0, then b < 0, and k
a< 0, then b > 0, and k 
either way, k sign(a) 
sign(a) 
1. 
0. 
7 let "
2556,488,"2 int c = a - b; 
3 
4 int sa sign(a); 
5 int sb sign(b); 
II if a>= 
II if b >= 
0, then 1 else 0 
0, then 1 else 0 
6 int SC sign(c); II depends on whether or not a - b overflows 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 } 
/* Goal: define a value k which is 1 if a> b and 0 
* (if a"
2557,249,"if a< b. 
II If a and b have the same sign, then k sign(a - b) 
int use_sign_of_c = flip(sa A sb); 
int k use_sign_of_a * sa + use_sign_of_c * sc; 
int q flip(k); /I opposite of k 
return a* k + b * q; 
476 Cracking the Coding Interview, 6th Edition"
2558,505,"Solutions to Chapter 16 I Moderate
Note that for clarity, we split up the code into many different methods and variables. This is certainly not the 
most compact or efficient way to write it, but it does make what we're doing much cleaner. 
16.8 English Int: Given any integer, print an English phras"
2559,486,"in how you approach the problem-and to make sure you have good test cases. 
We can think about converting a number like 19,323,984 as converting each of three 3-digit segments of 
the number, and inserting ""thousands"" and ""millions"" in between as appropriate. That is, 
convert(19,323,984) = convert("
2560,507,"2 ""Eight"", ""Nine"", ""Ten"", ""Eleven"", ""Twelve"", ""Thirteen"", ""Fourteen"", ""Fifteen"", 
3 ""Sixteen"", ""Seventeen"", ""Eighteen"", ""Nineteen""}; 
4 String[] tens ={"""", """", ""Twenty"", ""Thirty"", ""Forty"", ""Fifty"", ""Sixty"", ""Seventy"", 
5 ""Eighty"", ""Ninety""}; 
6 String[] bigs ={"""", ""Thousand"", ""Million"", ""Billion""}; "
2561,488,"14 return negative +""""+ convert(-1 * num); 
15 } 
16 
17 
18 
Linkedlist<String> parts 
int chunkCount = 0; 
new Linkedlist<String>(); 
19 
20 while (num > 0) { 
21 if (num % 1000 != 0) { 
22 String chunk= convertChunk(num % 1000) +"" ""+ bigs[chunkCount]; 
23 parts.addFirst(chunk); 
24 } 
25 num /= 1"
2562,207,"33 Linkedlist<String> parts = new Linkedlist<String>(); 
34 
35 /* Convert hundreds place */ 
36 if (number>= 100) { 
37 parts.addlast(smalls[number / 100]); 
CrackingTheCodinglnterview.com I 6th Edition 477"
2563,442,"Solutions to Chapter 16 I Moderate
38 parts.addLast(hundred); 
39 number%= 100; 
40 } 
41 
42 /* Convert tens place */ 
43 if (number >= 10 && number <= 19) { 
44 parts.addlast(smalls[nu mber]); 
45 } else if (number >= 20) { 
46 parts.addlas t(tens[number / 10]); 
47 number%= 10; 
48 } 
49 
50 /* C"
2564,480,"53 } 
54 
55 return listToString(parts); 
56 } 
57 /* Convert a linked list of strings to a string, dividing it up with spaces. */ 
58 String listToString(LinkedList<String> parts) { 
59 StringBuilder sb = new StringBuilder(); 
60 while (parts.size() > 1) { 
61 sb.append(parts.pop()); 
62 sb.append("
2565,466,"16.9 Operations: Write methods to implement the multiply, subtract, and divide operations for integers. 
The results of all of these are integers. Use only the add operator. 
pg 182 
SOLUTION 
The only operation we have to work with is the add operator. In each of these problems, it's useful to thin"
2566,501,"add or operations we've already completed). 
Subtraction 
How can we phrase subtraction in terms of addition? This one is pretty straightforward. The operation a 
- b is the same thing as a + ( -1) * b. However, because we are not allowed to use the * (multiply)
operator, we must implement a negate "
2567,106,"5 while (a!= 
0) { 
6 neg+= newSign; 
7 a+ = newSign; 
8 } 
478 Cracking the Coding Interview, 6th Edition"
2568,509,"9 return neg; 
10 } 
11 
Solutions to Chapter 16 I Moderate
12 /* Subtract two numbers by negating b and adding them*/ 
13 int minus(int a, int b) { 
14 return a+ negate(b); 
15 } 
The negation of the value k is implemented by adding -1 k times. Observe that this will take O ( k) time. 
If optimizin"
2569,454,"this value de 1 ta. We want a to reach exactly zero. When reducing a by the next de 1 ta would change the 
sign of a, we reset delta back to 1 and repeat the process. 
For example: 
a: 29 28 26 22 14 13 11 7 6 4 0 
delta: -1 -2 -4 -8 -1 -2 -4 -1 -2 -4 
The code below implements this algorithm. 
1 in"
2570,411,"6 boolean differentSigns =(a+ delta> 0) !=(a> 0); 
7 if (a+ delta != 0 && differentSigns) {//If delta is too big, reset it. 
8 delta= newSign; 
9 } 
10 neg+= delta; 
11 a+= delta; 
12 delta+= delta;// Double the delta 
13 } 
14 return neg; 
15 } 
Figuring out the runtime here takes a bit of calculat"
2571,509,"lute values of a and delta always add up to the same number. The values of delta and a will converge at 
Yi. Since de 1 ta is being doubled each time, it will take O ( log a) steps to reach half of a. 
We do O(log a) rounds. 
1. Reducing a to Yi takes 0( log a) time.
2. Reducing Yi to % takes O( log"
2572,144,"expression. 
Recall two rules of logs: 
, log(xy) = log x + log y 
• log( 7Y) = log x - log y .
CrackingTheCodinglnterview.com I 6th Edition 479"
2573,493,"Solutions to Chapter 16 I Moderate 
If we apply this to the above expression, we get: 
l. O(log a + log( Yi) + log( X) + •.. )
2. O(log a+ (log a - log 2) + (log a - log 4) + (log a - log 8) + ...
3. o( (log a)*(log a) - (log 2 + log 4 + log 8 + ... + log a)) //O(log a) terms
4. O((log a)*(log a) - "
2574,428,"6. O((log a)2) // drop second term from step 5
Therefore, the runtime is O( ( log a )2).
This math is considerably more complicated than most people would be able to do (or expected to do) in an 
interview. You could make a simplification: You do O( log a) rounds and the longest round takes O(log 
a"
2575,459,"happens to be the true time.
There are some faster solutions too. For example, rather than resetting delta to 1 at each round, we could 
change delta to its previous value. This would have the effect of delta ""counting up"" by multiples of two, 
and then ""counting down"" by multiples of two. The runti"
2576,504,"the problem. You could certainly discuss those implementations with your interviewer though. 
Multiplication 
The connection between addition and multiplication is equally straightforward. To multiply a by b, we just 
add a to itself b times. 
1 I* Multiply a by b by adding a to itself b times *I
2 "
2577,465,"8 sum+= a; 
9 } 
10 if (b < 0) { 
11 sum= negate(sum); 
12 } 
13 return sum; 
14 } 
15 
16 I* Return absolute value *I
17 int abs(int a) { 
18 if (a< 0) { 
19 return negate(a); 
20 } else { 
21 return a; 
22 } 
23 } 
The one thing we need to be careful of in the above code is to properly handle mult"
2578,92,"multiply(a, b) <-- abs(b) *a* (-1 if b < 0). 
480 Cracking the Coding Interview, 6th Edition"
2579,461,"Solutions to Chapter 16 / Moderate 
We also implemented a simple abs function to help.
Division 
Of the three operations, division is certainly the hardest. ""The good thing is that we can use the multiply, 
subtract, and negate methods now to implement divide. 
We are trying to compute x where X = %"
2580,501,"We could implement this by multiplying b by progressively higher values, until we reach a. That would be 
fairly inefficient, particularly given that our implementation of multiply involves a lot of adding. 
Alternatively, we can look at the equation a = xb to see that we can compute x by adding b t"
2581,499,"asked to implement, is supposed to truncate the result. 
The code below implements this algorithm. 
1 int divide(int a, int b) throws java.lang.ArithmeticExce ption { 
2 if (b == 0) { 
3 throw new java.lang.Arithmet icExcep tion(""ERROR""); 
4 } 
int absa 
int absb 
abs(a); 
abs(b); 
int product = 0; "
2582,403,"16 return x; 
17 } else { 
18 return negate(x); 
19 } 
20 } 
In tackling this problem, you should be aware of the following: 
A logical approach of going back to what exactly multiplication and division do comes in handy. 
Remember that. All (good) interview problems can be approached in a logical, "
2583,475,"This is a great problem to demonstrate your ability to write clean code-specifically, to show your ability 
to reuse code. For example, if you were writing this solution and didn't put negate in its own method, 
you should move it into its own method once you see that you'll use it multiple times. 
"
2584,485,"Solutions to Chapter 16 I Moderate
16.10 Living People: Given a list of people with their birth and death years, implement a method to 
compute the year with the most number of people alive. You may assume that all people were born 
between 1900 and 2000 (inclusive). If a person was alive during any"
2585,499,"counts for both 1908 and 1909. 
pg 782 
SOLUTION 
The first thing we should do is outline what this solution will look like. The interview question hasn't speci­
fied the exact form of input. In a real interview, we could ask the interviewer how the input is structured. 
Alternatively, you can expli"
2586,470,"objects: 
1 public class Person { 
2 public int birth; 
3 public int death; 
4 public Person(int birthYear, int deathYear) { 
5 birth birthYear; 
6 death= deathYear; 
7 } 
8 } 
We could have also given Person a getBirthVear() and getDeathYear() objects. Some would 
argue that's better style, but for"
2587,463,"integer array for birth years and an integer array for death years (with an implicit association of bir ths [ i] 
and deaths [ i] being associated with the same person). You don't get a lot of chances to demonstrate 
great coding style, so it's valuable to take the ones you get. 
With that in mind, "
2588,490,"the most number of people alive. Therefore, we go through each year and check how many people are alive 
in that year. 
1 int maxAliveYear(Person[] people, int min, int max) { 
2 int maxAlive = 0; 
3 int maxAliveYear = min; 
4 
s for (int year= min; year<= max; year++) { 
6 int alive = 0; 
7 for (Pe"
2589,105,"13 maxAlive = alive; 
14 maxAliveYear = year; 
15 } 
16 } 
482 Cracking the Coding Interview, 6th Edition"
2590,440,"17 
18 return maxAliveYear; 
19 } 
Solutions to Chapter 16 I Moderate
Note that we have passed in the values for the min year(l 900) and max year (2000). We shouldn't hard code 
these values. 
The runtime of this is O (RP), where R is the range of years (100 in this case) and P is the number of peop"
2591,458,"year. Then, we iterate through the list of people and increment the array for each year they are alive. 
1 int maxAliveYear(Person[] people, int min, int max) { 
2 int[] years = createYearMap(people, min, max); 
3 int best = getMaxlndex(years); 
4 return best + min; 
5 } 
6 
7 /* Add each person's y"
2592,481,"10 for (Person person : people) { 
11 incrementRange(years, person.birth - min, person.death - min); 
12 } 
13 return years; 
14 } 
15 
16 /* Increment array for each value between left and right. */ 
17 void incrementRange(int[] values, int left, int right) { 
18 for (int i= left; i <= right; i++) "
2593,441,"25 int max = 0; 
26 for (int i= 1; i < values.length; i++) { 
27 if (values[i] > values[max]) { 
28 max = i; 
29 } 
30 } 
31 return max; 
32 } 
Be careful on the size of the array in line 9. If the range of years is 1900 to 2000 inclusive, then that's 101 
years, not 100. That is why the array has s"
2594,364,"We create an R-sized array, where R is the min and max years. 
Then, for P people, we iterate through the years (Y) that the person is alive. 
Then, we iterate through the R-sized array again. 
The total runtime is O(PY + R). In the worst case, Y is Rand we have done no better than we did in the 
fi"
2595,509,"Solutions to Chapter 16 I Moderate 
More Optimal 
Let's create an example. (In fact, an example is really helpful in almost all problems. Ideally, you've already 
done this.) Each column below is matched, so that the items correspond to the same person. For compact­
ness, we'll just write the last t"
2596,483,"and every death removes a person. 
Since we don't actually need to match up the births and deaths, let's sort both. A sorted version of the years 
might help us solve the problem. 
birth: 01 10 10 12 13 20 23 75 83 90 
death: 15 72 82 90 94 98 98 98 98 99 
We can try walking through the years. 
At y"
2597,498,"At year 15, one person dies. We are now down to two people alive. 
And so on. 
If we walk through the two arrays like this, we can track the number of people alive at each point. 
1 int maxAliveYear(Person[] people, int min, int max) { 
2 int[] births getSortedYears(people, true); 
3 int[] deaths = "
2598,509,"maxAliveYear = min; 
11 /* Walk through arrays. */ 
12 while (birth!ndex < births.length) { 
13 if (births[birthindex] <= deaths[death!ndex]) { 
14 currentlyAlive++; // include birth 
15 if (currentlyAlive > maxAlive) { 
16 maxAlive = currentlyAlive; 
17 maxAliveYear = births[birthindex]; 
18 } 
19 "
2599,182,"23 } 
24 } 
25 
26 return maxAliveYear; 
27 } 
28 
29 /* Copy birth years or death years (depending on the value of copyBirthVear into 
484 Cracking the Coding Interview, 6th Edition"
2600,505,"Solutions to Chapter 16 l Moderate
30 * integer 
array, then sort array. */
31 
int[] getSorted Years(Person[1 people, boolean copyBirthYear) { 
32 int[] years = new int[people.length]; 
33 for (inti= 0; i < people.length; i++) { 
34 years[i] = copyBirthYear? people[i].birth people[i].death; 
35 } 
"
2601,468,"(<=). The scenario we need to worry about is that you see a birth and death in the same year. (It doesn't 
matter whether the birth and death is from the same person.) 
When we see a birth and death from the same year, we want to include the birth before we include the 
death, so that we count this "
2602,467,"to be after the currentAlive++, so that it takes into account the updated total. But it needs to be before 
birth Index++, or we won't have the right year. 
This algorithm will take O ( P log P) time, where P is the number of people. 
More Optimal (Maybe) 
Can we optimize this further? To optimize t"
2603,444,"death: 15 90 98 72 98 82 98 98 99 94 
Earlier, we had logic that said that a birth is just adding a person and a death is just subtracting a person. 
Therefore, let's represent the data using the logic: 
01: +1 10: +1 10: +1 12: +1 13: +1 
15: -1 20: +1 23: +1 72: -1 75: +1 
82: -1 83: +1 90: +1 90:"
2604,483,"changed in that year. To create this array, we walk through the list of people and increment when they're 
born and decrement when they die. 
Once we have this array, we can walk through each of the years, tracking the current population as we go 
(adding the value at array[year] each time). 
This l"
2605,510,"and decrement operations will cancel out to give O population change. According to the wording of the 
problem, this person should be counted as living in that year. 
In fact, the""bug"" in our algorithm is broader than that. This same issue applies to all people. People who die 
in 1908 shouldn't be "
2606,105,"1 int maxAliveYear(Person[] people, int min, int max) { 
CrackingTheCodinglnterview.com I 6th Edition 485"
2607,510,"Solutions to Chapter 16 I Moderate
2 /* Build population delta array. */ 
3 int[] populationDeltas = getPopulationDeltas(people, min, max); 
4 int maxAliveYear = getMaxAliveYear(populationDeltas); 
5 return maxAliveYear + min; 
5 } 
7 
8 /* Add birth and death years to deltas array. */ 
9 int[] getP"
2608,506,"13 populationDeltas[birth]++; 
14 
15 int death= person.death - min; 
16 populationDeltas[death + 1]--; 
17 } 
18 return populationDeltas; 
19 } 
20 
21 /* Compute running sums and return index with max. */ 
22 int getMaxAliveYear(int[] deltas) { 
23 int maxAliveYear = 0; 
24 int maxAlive = 0; 
25 i"
2609,458,"29 maxAliveYear = year; 
30 maxAlive = currentlyAlive; 
31 } 
32 } 
33 
34 return maxAliveYear; 
35 } 
This algorithm takesO(R + P) time, where R is the range of years and Pis the number of people. Although 
O(R + P) might be faster than O(P log P) for many expected inputs, you cannot directly compa"
2610,472,"There are two types of planks, one of length shorter and one of length longer. You must use 
exactly K planks of wood. Write a method to generate all possible lengths for the diving board. 
pg 782
SOLUTION 
One way to approach this is to think about the choices we make as we're building a diving boa"
2611,229,"choosing which plank we will put on next. Once we've put on K planks, we have a complete diving board 
and we can add this to the list (assuming we haven't seen this length before). 
486 Cracking the Coding Interview, 6th Edition"
2612,481,"Solutions to Chapter 16 / Moderate
We can follow this logic to write recursive code. Note that we don't need to track the sequence of planks. All 
we need to know is the current length and the number of planks remaining. 
1 HashSet<Integer> alllengths(int k, int shorter, int longer) { 
2 HashSet<Int"
2613,462,"8 HashSet<Integer> lengths) { 
9 if (k == 0) { 
10 lengths.add(total); 
11 return; 
12 } 
13 getAlllengths(k - 1, total+ shorter, shorter, longer, lengths); 
14 getAllLengths(k - 1, total+ longer, shorter, longer, lengths); 
15 } 
We've added each length to a hash set. This will automatically preven"
2614,461,"depth of K. 
Memoization Solution 
As in many recursive algorithms (especially those with exponential runtimes), we can optimize this through 
memorization (a form of dynamic programming). 
Observe that some of the recursive calls will be essentially equivalent. For example, picking plank 1 and 
the"
2615,464,"can do this using a HashSet with a key of (total, plank count). 
I 
Many candidates will make a mistake here. Rather than stopping only when they've seen 
(total, plank count), they'll stop whenever they've seen just total before. This is 
incorrect. Seeing two planks of length 1 is not the same thi"
2616,499,"about what you choose for your key. 
The code for this approach is very similar to the earlier approach. 
1 HashSet<Integer> alllengths(int k, int shorter, int longer) { 
2 HashSet<Integer> lengths = new HashSet<Integer>(); 
3 HashSet<String> visited= new HashSet<String>(); 
4 getAlllengths(k, 0, sh"
2617,140,"10 if (k == 0) { 
11 lengths.add(total); 
12 return; 
13 } 
14 String key k + "" "" + total; 
CrackingTheCodinglnterview.com I 6th Edition 487"
2618,489,"Solutions to Chapter 16 I Moderate
15 if (visited.contains(key)) { 
16 return; 
17 } 
18 getAllLengths(k - 1, total+ shorter, shorter, longer, lengths, visited); 
19 getAllLengths(k - 1, total+ longer, shorter, longer, lengths, visited); 
20 visited.add(key); 
21 } 
For simplicity, we've set the key"
2619,412,"are drawbacks as well. It's worth discussing this tradeoff with your interviewer. 
The runtime of this algorithm is a bit tricky to figure out. 
One way we can think about the runtime is by understanding that we're basically filling in a table of SUMS 
x PLANK COUNTS. The biggest possible sum is K *"
2620,428,"Therefore, the runtime will be no worse than O(K2 * LONGER). 
Of course, a bunch of those sums will never actually be reached. How many unique sums can we get? 
Observe that any path with the same number of each type of planks will have the same sum. Since we can 
have at most K planks of each type,"
2621,468,"really KxK, and the runtime is O ( K2). 
Optimal Solution 
If you re-read the prior paragraph, you might notice something interesting. There are only K distinct sums 
we can get. Isn't that the whole point of the problem-to find all possible sums? 
We don't actually need to go through all arrangemen"
2622,495,"{O of type A, K of type B}, {1 of type A, K-1 of type B}, {2 of type A, K-2 of type B}, ... 
This can be done in just a simple for loop. At each ""sequence'; we just compute the sum. 
1 HashS et<Integer> alllengths(int k, int shorter, int longer) { 
2 Hash Set<Integer> lengths = new HashSe t<Integer>"
2623,451,"6 lengths.add(length); 
7 } 
8 return lengths; 
9 } 
We've used a Hash Set here for consistency with the prior solutions. This isn't really necessary though, since 
we shouldn't get any duplicates. We could instead use an Arraylist. If we do this, though, we just need to 
handle an edge case where t"
2624,454,"Solutions to Chapter 16 I Moderate 
16.12 XML Encoding: Since XML is very verbose, you are given a way of encoding it where each tag gets 
mapped to a pre-defined integer value. The language/grammar is as follows: 
Element --> Tag Attributes END Children END 
Attribute --> Tag Value 
END --> 0 
Tag "
2625,461,"mapping of family -> 1, person ->2, firstName -> 3, lastName -> 4, state 
-> 5). 
<family lastName=""McDowell"" state=""CA""> 
<person firstName=""Gayle"">Some Message</ person> 
</ family> 
Becomes: 
1 4 McDowell 5 CA 0 2 3 Gayle 0 Some Message 0 0 
Write code to print the encoded version of an XML eleme"
2626,506,"simple. We can implement this by applying a tree-like approach. 
We repeatedly call encode () on parts of the XML structure, handling the code in slightly different ways 
depending on the type of the XML element. 
1 void encode(Element root, StringBuilder sb) { 
2 encode(root.getNameCode(), sb); 
3 "
2627,379,"9 } else { 
10 for (Element e : root.children) { 
11 encode(e, sb); 
12 } 
13 } 
14 encode(""0"", sb); 
15 } 
16 
17 void encode(String v, StringBuilder sb) { 
18 sb.append(v); 
19 sb.append("" ""); 
20 } 
21 
22 void encode(Attribute attr, StringBuilder sb) { 
23 encode(attr.getTagCode(), sb); 
24 enco"
2628,503,"Solutions to Chapter 16 I Moderate
27 String encodeToString(Element root) { 
28 StringBuilder sb = new StringBuilder(); 
29 encode(root, sb); 
30 return sb.toString(); 
31 } 
Observe in line 17, the use of the very simple encode method for a string. This is somewhat unnecessary; all 
it does is inse"
2629,495,"encoding by forgetting to append the empty string. 
16.13 Bisect Squares: Given two squares on a two-dimensional plane, find a line that would cut these two 
squares in half. Assume that the top and the bottom sides of the square run parallel to the x-axis. 
pg 182 
SOLUTION 
Before we start, we sho"
2630,480,"starts and ends at the edges of the squares? 
We will assume, since it makes the problem a bit more interesting, that we mean the third option: that the 
line should end at the edges of the squares. In an interview situation, you should discuss this with your 
interviewer. 
This line that cuts two s"
2631,510,"equation to calculate the start and end points of the line segment. 
In the below code, we will assume the origin ( 0, 0) is in the upper left-hand corner. 
1 public class Square { 
2 
3 public Point middle() { 
4 return new Point((this.left +this.right)/ 2.0, 
5 (this.top+ this.bottom)/ 2.0); 
6 } "
2632,507,"10 * out until the edge of the square. */
11 public Point extend(Point midl, Point mid2, double size) { 
12 /* Find what direction the line mid2 -> midl goes. */ 
13 double xdir midl.x < mid2.x? -1 1; 
14 double ydir = midl.y < mid2.y? -1: 1; 
15 
16 /* If midl and mid2 have the same x value, then t"
2633,158,"20 } 
21 
22 
23 
24 
25 
490 
double slope = (midl.y - mid2.y) / (midl.x - mid2.x); 
double xl 0; 
double yl = 0; 
Cracking the Coding Interview, 6th Edition"
2634,475,"Solutions to Chapter 16 \ Moderate 
26 /* Calculate slope using the equation (yl - y2) / (xl - x2). 
27 * Note: if the slope is ""steep"" (>1) then the end of the line segment will
28 * hit size/ 
2 units away from the middle on the y axis. If the slope is
29 * ""shallow"" ( <1) the end of the line segm"
2635,451,"33 yl = midl.y + ydir * size/ 2.0; 
34 } else if (Math.abs(slope) < 1) {//shallow slope 
35 xl = midl.x + xdir * size/ 2.0; 
36 yl = slope * (xl - midl.x) + midl.y; 
37 } else {//steep slope 
38 yl = midl.y + ydir * size/ 2.0; 
39 xl = (yl - midl.y) /slope + midl.x; 
40 } 
41 return new Point(xl, yl"
2636,501,"46 * the squares */
47 Point pl = extend(this.middle(), other.middle(), this.size); 
48 Point p2 = extend(this.middle(), other.middle(), -1 * this.size); 
49 Point p3 = extend(other.middle(), this.middle(), 
other.size); 
50 Point p4 = extend(other.middle(), this.middle(), -1 * other.size); 
51 
52 "
2637,422,"54 *
a tie breaker. */
55 Point start = pl;
56 Point end= pl;
57 Point[] points = {p2, p3, p4}; 
58 for (int i= 0; i < points.length; i++) { 
59 if (points[i].x < start.x I I 
60 (points[i].x == start.x && points[i].y < start.y)) { 
61 start = points[i]; 
62 } else if (points[i].x > end.x I I
63 (po"
2638,455,"65 } 
66 } 
67 
68 return new Line(start, end); 
6
9 } 
The main goal of this problem is to see how careful you are about coding. It's easy to glance over the special 
cases (e.g., the two squares having the same middle). You should make a list of these special cases before 
you start the problem an"
2639,456,"Solutions to Chapter 16 I Moderate
16.14 Best Line: Given a two-dimensional graph with points on it, find a line which passes the most 
number of points. 
pg 183 
SOLUTION 
This solution seems quite straightforward at first. And it is-sort of. 
We just""draw"" an infinite line (that is, not a line seg"
2640,498,"We will represent a line as a slope and y-intercept (as opposed to a pair of points), which allows us to easily 
check to see if the line from ( xl, yl) to ( x2, y2) is equivalent to the line from ( x3, y3) to ( x4, 
y4). 
To find the most common line then, we just iterate through all lines segments"
2641,421,"and y-intercept. We are then, furthermore, hashing the lines based on these values (specifically, based on 
the slope). The problem is that floating point numbers cannot always be represented accurately in binary. 
We resolve this by checking if two floating point numbers are within an epsilon value"
2642,468,"the same value. To solve this, we will round the slope down to the next epsilon and use this flooredSlope 
as the hash key. Then, to retrieve all lines that are potentially equal, we will search the hash table at three 
spots: flooredSlope, flooredSlope - epsilon, and flooredSlope + epsilon. This wi"
2643,497,"2 Line findBestLine(GraphPoint[] points) { 
3 HashMapList<Double, Line> linesBySlope = getListOfLines(points); 
4 return getBestLine(linesBySlope); 
5 } 
6 
7 /* Add each pair of points as a line to the list. */ 
8 HashMapList<Double, Line> getListOfLines(GraphPoint[] points) { 
9 HashMapList<Double"
2644,494,"12 Line line= new Line(points[i], points[j]); 
13 double key= Line.floorToNearestEpsilon(line.slope); 
14 linesBySlope.put(key, line); 
15 } 
16 } 
17 return linesBySlope; 
18 } 
19 
20 /* Return the line with the most equivalent other lines. */ 
21 Line getBestLine(HashMapList<Double, Line> linesBy"
2645,464,"Solutions to Chapter 16 l Moderate 
28 ArrayList<Line> lines = linesBySlope.get(slope); 
29 for (Line line : lines) { 
30 I* count lines that are equivalent to current line * I
31 int count = countEquivalentLines(linesBySlope, line); 
32 
33 I* if better than current line, replace it *I
34 if (count"
2646,478,"39 } 
40 } 
41 } 
42 return bestLine; 
43 } 
44 
45 I* Check hashmap for lines that are equivalent. Note that we need to check one 
46 * epsilon above and below the actual slope since we're defining two lines as
47 * equivalent if they're within an epsilon of each other. *I
48 int countEquivalentLin"
2647,485,"51 count+= countEquivalentLines(linesBySlope.get(key - Line.epsilon), line); 
52 count += countEquivalentLines(linesBySlope.get(key + Line.epsilon), line); 
53 return count; 
54 } 
55 
56 I* Count lines within an array of lines which are ""equivalent"" (slope and 
57 * y-intercept are within an epsilo"
2648,470,"60 
61 int count = 0; 
62 for (Line parallelLine : lines) { 
63 if (parallelLine.isEquivalent(line)) { 
64 count++; 
65 } 
66 } 
67 return count; 
68 } 
69 
70 public class Line { 
71 public static double epsilon= .0001; 
72 public double slope, intercept; 
73 private boolean infinite_slope = false;"
2649,277,"77 slope= (p.y - q.y) I (p.x - q.x); II compute slope 
78 intercept= p.y - slope * p.x; II y intercept from y=mx+b 
79 } else { 
80 infinite_slope = true; 
81 intercept = p.x; II x-intercept, since slope is infinite 
82 } 
83 } 
CrackingTheCodinglnterview.com I 6th Edition 493"
2650,510,"Solutions to Chapter 16 I Moderate
84 
85 public static double floorToNearestEpsilon(double d) { 
86 int r = (int) (d / epsilon); 
87 return ((double) r) * epsilon; 
88 } 
89 
90 public boolean isEquivalent(double a, double b) { 
91 return (Math.abs(a - b) < epsilon); 
92 } 
93 
94 public boolean is"
2651,499,"98 return true; 
99 } 
100 return false; 
101 } 
102} 
103 
104 /* HashMapList<String, Integer> is a HashMap that maps from Strings to 
105 * ArrayList<Integer>. See appendix for implementation. */ 
We need to be careful about the calculation of the slope of a line. The line might be completely vert"
2652,478,"16.15 Master Mind: The Game of Master Mind is played as follows: 
The computer has four slots, and each slot will contain a ball that is red (R), yellow (Y), green (G) or 
blue (B). For example, the computer might have RGGB (Slot #1 is red, Slots #2 and #3 are green, Slot 
#4 is blue). 
You, the use"
2653,495,"but is in the wrong slot, you get a ""pseudo-hit:' Note that a slot that is a hit can never count as a 
pseudo-hit. 
For example, if the actual solution is RGBY and you guess GGRR , you have one hit and one pseudo­
hit 
Write a method that, given a guess and a solution, returns the number of hits and"
2654,423,"code extremely thoroughly, on a variety of test cases. 
We'll implement this code by first creating a frequency array which stores how many times each character 
occurs in solution, excluding times when the slot is a ""hit:'Then, we iterate through guess to count the 
number of pseudo-hits. 
The code"
2655,496,"3 public int pseudoHits = 0; 
4 
Solutions to Chapter 16 I Moderate 
5 public String toString() { 
6 return ""("" + hit s+"" ,"" + pseudoHits + "")""; 
7 } 
8 } 
9 
10 int code(char c) { 
11 switch (c) { 
12 case 'B': 
13 return 0; 
14 case 'G': 
15 return 1; 
16 case 'R': 
17 return 2; 
18 case 'Y': 
19 "
2656,509,"28 if (guess.length() != solution.length()) return null; 
29 
30 Result res = new Result(); 
31 int[] frequencies = new int[MAX_COLORS]; 
32 
33 /* Compute hits and build frequency table */ 
34 for (int i= 0; i < guess.length(); i++) { 
35 if (guess.charAt(i) == solution.charAt(i)) { 
36 res.hits++;"
2657,476,"40 int code = code(solution.charAt(i));
41 frequencies[code]++;
42 } 
43 } 
44 
45 /* Compute pseudo-hits */ 
46 for (int i= 0; i < guess.length(); i++) { 
47 int code = code(guess.charAt(i)); 
48 if (code >= 0 && frequencies[code] > 0 && 
49 guess.charAt(i) != solution.charAt(i)) { 
50 res.pseudoHi"
2658,197,"In this case, we've pulled co de ( char c) into its own method, and we've created a Result class to hold 
the result, rather than just printing it. 
CrackingTheCodinglnterview.com I 6th Edition 495"
2659,462,"Solutions to Chapter 16 I Moderate
16.16 Sub Sort: Given an array of integers, write a method to find indices m and n such that if you sorted 
elements m through n, the entire array would be sorted. Minimize n - m (that is, find the smallest 
such sequence). 
EXAMPLE 
Input: 1, 2, 4, 7, 10, 11, 7, 1"
2660,454,"indices, this indicates that some middle section of the array will be sorted, with the start and end of the 
array already being in order. 
Now, let's approach this problem by looking at an example. 
1, 2, 4, 7, 10, 11, 8, 12, 5, 6, 16, 18, 19 
Our first thought might be to just find the longest inc"
2661,482,"middle: 8, 12 
right: 5, 6, 16, 18, 19 
These subsequences are easy to generate. We just start from the left and the right sides, and work our way 
inward. When an element is out of order, then we have found the end of our increasing/decreasing subse­
quence. 
In order to solve our problem, though, "
2662,444,"/* all items on left are smaller than all items in middle */ 
min(middle) > end(left) 
/* all items in middle are smaller than all items in right */ 
max(middle) < start(right) 
Or, in other words, for all elements: 
left< middle < right 
In fact, this condition will never be met. The middle section"
2663,428,"start. Thus, you cannot sort the middle to make the entire array sorted. 
But, what we can do is shrink the left and right subsequences until the earlier conditions are met. We need 
the left part to be smaller than all the elements in the middle and right side, and the right part to be bigger 
than"
2664,451,"Observe that since the right and left sides are already in sorted order, we only actually need to check their 
start or end point. 
On the left side, we start with the end of the subsequence (value 11, at element 5) and move to the left. The 
value min equals 5. Once we find an element i such that a"
2665,487,"Solutions to Chapter 16 I Moderate 
Then, we do a similar thing on the right side. The value max equals 12. So, we begin with the start of the
right subsequence tvalue 6) and move to the right. We compare the max ot, 2 to 6, then 7, then '\6. When
reach 16, we know that no elements smaller than 12 c"
2666,502,"The following code implements this algorithm. 
1 void findUnsortedSequence(int[] array) { 
2 II find left subsequence 
3 int end left= findEndOfleftSubsequence(array); 
4 if (end_left >= array.length - 1) return; II Already sorted 
5 
6 II find right subsequence 
7 int start_right = findStartOfRight"
2667,471,"12 for (int i= end_left + 1; i < start_right; i++) { 
13 if (array[i] < array[min_index]) min index i; 
14 if (array[i] > array[max_index]) max_index = i; 
15 } 
16 
17 // slide left until less than array[min_index] 
18 int left_index = shrinkLeft(array, min_index, end_left); 
19 
20 // slide right "
2668,502,"24 } 
25 
26 int findEndOfLeftSubsequence(int[] array) { 
for (int i= 1; i < array.length; i++) { 27 
28 if (array[i] < array[i - 1]) return i - 1; 
29 } 
30 return array.length - 1; 
31 } 
32 
33 int findStartOfRightSubsequence(int[] array) { 
34 for (int i= array.length - 2; i >= 0; i--) { 
35 if "
2669,299,"42 for (inti= start - 1; i >= 0; i--) { 
43 if (array[i] <= comp) return i + 1; 
44 } 
45 return 0; 
46 } 
47 
48 int shrinkRight(int[] array, int max_index, int start) { 
49 int comp array[max_index]; 
50 for (int i= start; i < array.length; i++) { 
CrackingTheCodinglnterview.com I 6th Edition 497"
2670,460,"Solutions to Chapter 16 I Moderate
Sl if (array(i1 >= comp) return i - 1; 
52 } 
53 return array.length - 1; 
54 } 
Note the use of other methods in this solution. Although we could have jammed it all into one method, it 
would have made the code a lot harder to understand, maintain, and test. In yo"
2671,482,"contiguous sequence with the largest sum. Return the sum. 
EXAMPLE 
Input: 2, -8, 3, -2, 4, -10 
Output: 5 ( i. e • , { 3, -2, 4} ) 
SOLUTION 
pg 783
This is a challenging problem, but an extremely common one. Let's approach this by looking at an example: 
2 3 -8 -1 2 4 -2 3 
If we think about our a"
2672,412,"Why would we? Including part of a negative subsequence would make things unnecessarily negative, and 
we should just instead not include that negative sequence at all. Likewise, including only part of a positive 
subsequence would be strange, since the sum would be even bigger if we included the who"
2673,445,"alternating negative and positive numbers. Each number corresponds to the sum of a subsequence of posi­
tive numbers of a subsequence of negative numbers. For the array above, our new reduced array would be: 
5 -9 6 -2 3 
This doesn't give away a great algorithm immediately, but it does help us to b"
2674,487,"sum to -4, so we're better off not including either number, or possibly just having the sequence be just 
{5}). 
When would we want negative numbers included in a subsequence? Only if it allows us to join two positive 
subsequences, each of which have a sum greater than the negative value. 
We can a"
2675,509,"consider-9. If we added it to sum, we'd get a negative value. There's no sense in extending the subsequence 
from 5 to -9 (which ""reduces""to a sequence of just -4), so we just reset the value of sum. 
Now, we consider 6. This subsequence is greater than 5, so we update both maxSum and sum. 
Next, we"
2676,55,"maxSum. 
498 Cracking the Coding Interview, 6th Edition"
2677,497,"Solutions to Chapter 16 I Moderate 
Finally, we look at 3. Adding 3 to sum (4) gives us 7, so we update maxsum. The max subsequence is there­
fore the sequence { 6, -2, 3 }. 
When we look at this in the fully expanded array, our logic is identical. The code below implements this 
algorithm. 
1 int g"
2678,493,"8 } else if (sum < 0) { 
9 sum = 0; 
10 } 
11 } 
12 return maxsum; 
13 } 
If the array is all negative numbers, what is the correct behavior? Consider this simple array: { -3, -10, 
- 5}. You could make a good argument that the maximum sum is either:
1. -3 (if you assume the subsequence can't be emp"
2679,498,"your interviewer; it will show how detail-oriented you are. 
16.18 Pattern Matching: You are given two strings, pattern and value. The pattern string consists of 
just the letters a and b, describing a pattern within a string. For example, the string catcatgocatgo 
matches the pattern aabab (where c"
2680,508,"As always, we can start with a simple brute force approach. 
Brute Force 
A brute force algorithm is to just try all possible values for a and b and then check if this works. 
We could do this by iterating through all substrings for a and all possible substrings for b. There are 0( n2 ) 
substrings "
2681,267,"takes O(n) time, giving an overall runtime of O(n5 ). 
1 for each possible substring a 
2 for each possible substring b 
3 candidate = buildFromPattern(pattern, a, b) 
4 if candidate equals value 
5 return true 
Ouch. 
CrackingTheCodinglnterview.com I 6th Edition 499"
2682,419,"Solutions to Chapter 16 / Moderate 
One easy optimization is to notice that if the pattern starts with 'a'. then the a string must start at the 
beginning of value. (Otherwise, the b string must start at the beginning of value.) Therefore, there aren't 
0( n2 ) possible values for a; there are 0( n "
2683,489,"each 'a' to a 'b' and each 'b'to an 'a') so that it starts with 'a'. Then, iterate through all possible substrings for 
a (each of which must begin at index 0) and all possible substrings for b (each of which must begin at some 
character after the end of a). As before, we then compare the string fo"
2684,493,"the string starts with 'b' instead of 'a'. The build F romPattern method can take care of this. We can think 
about the first character in the pattern as the ""main"" item and the other character as the alternate character. 
The buildFromPattern method can build the appropriate string based on whether"
2685,464,"3 
4 int size = value.length(); 
5 for (int mainSize = 0; mainSize < size; mainSize++) { 
6 String main= value.substring(0, mainSize); 
7 for (int altStart = mainSize; altStart <= size; ,altStart++) { 
8 for (int altEnd = altStart; altEnd <= size; altEnd++) { 
9 String alt= value.substring(altStart,"
2686,418,"13 } 
14 } 
15 } 
16 } 
17 return false; 
18 } 
19 
20 String buildFromPattern(String pattern, String main, String alt) { 
21 StringBuffer sb = new StringBuffer(); 
22 char first= pattern.charAt(0); 
23 for (char c : pattern.toCharArray()) { 
24 if (c == first) { 
25 sb.append(main); 
26 } else { 
2"
2687,338,"31 } 
We should look for a more optimal algorithm. 
Optimized 
Let's think through our current algorithm. Searching through all values for the main string is fairly fast (it 
takes O ( n) time). It's the alternate string that is so slow: 0 ( n2 ) time. We should study how to optimize that. 
500 Crac"
2688,495,"Solutions to Chapter 16 I Moderate 
Suppose we have a pattem like aabab and we're comparing it to the string catcatgocatgo. Once we've 
picked ""cat"" as the value for a to try, then the a strings are going to take up nine characters (three a strings 
with length three each). Therefore, the b strings "
2689,479,"pattern is aabab, then b must be go. 
In other words, once we've picked a, we've picked b too. There's no need to iterate. Gathering some basic 
stats on pattern (number of as, number of bs, first occurrence of each) and iterating through values for a 
(or whichever the main string is) will be suffi"
2690,484,"5 
6 
7 
8 
9 
10 
11 
12 
char mainChar = pattern.charAt(0); 
char altChar = mainChar == 'a' ? 'b' 'a'; 
int size= value.length(); 
int countOfMain = countOf(pattern, mainChar); 
int countOfAlt = pattern.length() - countOfMain; 
int firstAlt = pattern.indexOf(altChar); 
int maxMainSize = size/ coµn"
2691,472,"15 String first= value.substring(0, mainSize); 
16 if (countOfAlt == 0 I I remainingLength % countOfAlt == 0) { 
17 int altindex = firstAlt * mainSize; 
18 int altSize = countOfAlt == 0? 0 
: remaininglength / countOfAlt; 
19 String second = countOfAl t == 0 ? """" : 
20 value.substring(altindex, altS"
2692,465,"24 return true; 
25 } 
26 } 
27 } 
28 return false; 
29 }
30 
31 int countOf(String pattern, char c) { 
32 int count = 0; 
33 for (int i= 0; i < pattern.length(); i++) { 
34 if (pattern.charAt(i) == c) { 
35 count++; 
36 } 
37 } 
38 return count; 
39 } 
40 
41 String buildFromPattern( ... ) { /* sam"
2693,283,"work to build and compare the strings. 
Observe that we've also cut down the possibilities for the main string that we try. If there are three instances 
of the main string, then its length cannot be any more than one third of value. 
CrackingTheCodinglnterview.com I 6th Edition S01"
2694,479,"Solutions to Chapter 16 I Moderate 
Optimized (Alternate} 
If you don't like the work of building a string only to compare it (and then destroy it), we can eliminate this. 
Instead, we can iterate through the values for a and ba s before. But this time, to check if the string matches 
the pattern (g"
2695,486,"1 boolean doesMatch(String pattern, String value) { 
2 if (pattern.length()== 0) return value.length() 0; 
3 
4 
5 
6 
7 
char mainChar = pattern.charAt(0); 
char altChar = mainChar == 'a' ? 'b' 
int size= value.length(); 
I a I; 
8 int countOfMain = countOf{pattern, mainChar); 
9 int countOfAlt = p"
2696,445,"14 int remaininglength = size - mainSize * countOfMain; 
15 if (countOfAlt == 0 I I remaininglength % countOfAlt == 0) { 
16 int altlndex = firstAlt * mainSize; 
17 int altSize = countOfAlt == 0? 0 : remaininglength / countOfAlt; 
18 if (matches(pattern, value, mainSize, altSize, altlndex)) { 
19 
2"
2697,447,"27 * this is the main string or the alternate string. Then checks if the next set of
28 * characters in value match the original set of those characters (either the main
29 * or the alternate. */
30 boolean matches(String pattern, String value, int mainSize, int altSize, 
31 int firstAlt) { 
32 int "
2698,489,"35 int offset= pattern.charAt(i) == pattern.charAt(0) ? 0 : firstAlt; 
36 if (!isEqual(value, offset, stringlndex, size)) { 
37 return false; 
38 } 
39 stringindex += size; 
40 } 
41 return true; 
42 } 
43 
44 /* Checks if two substrings are equal, starting at given offsets and continuing to 
45 * s"
2699,64,"49 return false; 
502 Cracking the Coding Interview, 6th Edition"
2700,433,"Solutions to Chapter 16 \ Moderate
50 } 
51 } 
52 return true; 
53 } 
This algorithm will still take O ( n2 ) time, but the benefit is that it can short circuit when matches fail early 
(which they usually will). The previous algorithm must go through all the work to build the string before it 
can "
2701,498,"represents the height above sea level. A value of zero indicates water. A pond is a region of water 
connected vertically, horizontally, or diagonally. The size of the pond is the total number of 
connected water cells. Write a method to compute the sizes of all ponds in the matrix. 
EXAMPLE 
Input:"
2702,449,"that's water. 
Given a water cell, how can we compute the amount of water nearby? If the cell is not adjacent to any zero 
cells, then the size of this pond is 1. If it is, then we need to add in the adjacent cells, plus any water cells 
adjacent to those cells. We need to, of course, be careful to "
2703,473,"For each cell, we need to check eight adjacent cells. We could do this by writing in lines to check up, down, 
left, right, and each of the four diagonal cells. It's even easier, though, to do this with a loop. 
1 Arraylist<Integer> computePondSizes (int[J[] land) { 
2 Arraylist<Integer> pondSizes ="
2704,470,"5 if (land[r][c] == 0) {//Optional. Would return anyway. 
6 int size = computeSize(land, r, c); 
7 pondSizes.add(size); 
8 } 
9 } 
10 } 
11 return pondSizes; 
12 } 
13 
14 int computeSiz e(int[J[] land, int row, int col) { 
15 /* If out of bounds or already visited. */ 
16 if (row < 0 I I col< 0 I I"
2705,476,"Solutions to Chapter 16 I Moderate
20 int size = 1; 
21 land[row][col] = -1; // Mark visited 
22 for (int dr = -1; dr <= 1; dr++) { 
23 for (int de = -1; de <= 1; de++) { 
24 size += computeSize(land, row + ctr, col + de); 
25 } 
26 } 
27 return size; 
28 } 
In this case, we marked a cell as visited"
2706,476,"You might also notice that the for loop iterates through nine cells, not eight. It includes the current cell. 
We could add a line in there to not recurse if dr == 0 and de == 0. This really doesn't save us much. 
We'll execute this if-statement in eight cells unnecessarily, just to avoid one recurs"
2707,485,"1 Arraylist<Integer> computePondSizes(int[][] land) { 
2 boolean[][] visited = new boolean[land.length][land[0].length]; 
3 Arraylist<Integer> pondSizes = new Arraylist<Integer>(); 
4 for (int r = 0; r < land.length; r++) { 
5 for (int c = 0; c < land[r].length; c++) { 
6 int size = computeSize(land"
2708,508,"16 /* If out of bounds or already visited. */ 
17 if (row < 0 I I col < 0 I I row >= land.length I I col >= land[row].length I I 
18 visited [row][col] I I land[row][col] != 0) { 
19 return 0; 
20 } 
21 int size = 1;
22 visited[row][col] = true; 
23 for (int dr = -1; dr <= 1; dr++) { 
24 for (int de"
2709,484,"I 
S04 
Note: Many people say ""O(N)"" or ""O(N2 )'; as though N has some inherent meaning. It doesn't. 
Suppose this were a square matrix. You could describe the runtime as 0( N) or 0( N2 ). Both are 
correct, depending on what you mean by N. The runtime is O(N2 ), where N is the length of one 
side. "
2710,42,"Cracking the Coding Interview, 6th Edition"
2711,460,"Solutions to Chapter l 6 \ Moderate 
Some people will miscompute the runtime to be 0( N4), reasoning that the computeSize method could 
take as long as O( N2 ) time and you might call it as much as 0( N2 ) times (and apparently assuming an NxN
matrix, too). While those are both basically correct sta"
2712,487,"For example, suppose the very first call to computeSize goes through the entire matrix. That might take 
O(N2) time, but then we never call computeSize again. 
Another way to compute this is to think about how many times each cell is ""touched"" by either call. Each cell 
will be touched once by the c"
2713,508,"O(N2) on an NxN matrix or, more generally, O(WH). 
16.20 T9: On old cell phones, users typed on a numeric keypad and the phone would provide a list of words 
that matched these numbers. Each digit mapped to a set of O - 4 letters. Implement an algorithm 
to return a list of matching words, given a s"
2714,497,"EXAMPLE 
Input: 
Output: 
SOLUTION 
8733 
tree, used 
1 
4 
ghi 
7 
pqrs 
2 3 
abc def 
5 6 
jkl mno 
8 9 
tuv wxyz 
0 
We could approach this in a couple of ways. Let's start with a brute force algorithm. 
Brute Force 
pg 184 
Imagine how you would solve the problem if you had to do it by hand. You"
2715,440,"to that digit. For each character, we add it to a prefix variable and recurse, passing the prefix downward. 
Once we run out of characters, we print prefix (which now contains the full word) if the string is a valid 
word. 
We will assume the list of words is passed in as a HashSet. A HashSet operat"
2716,263,"1 ArrayList<String> getValidT9Words(String number, HashSet<String> wordList) { 
2 ArrayList<String> results = new Arraylist<String>(); 
3 getValidWords(number, 0, """", wordList, results); 
4 return results; 
5 } 
6 
CrackingTheCodinglnterview.com I 6th Edition SOS"
2717,509,"Solutions to Chapter 16 I Moderate
7 void getValidWords(String number, int index, String prefix, 
8 HashSet<String> wordSet, Arraylist<String> results) { 
9 /* If it's a complete word, print it. */ 
10 if (index == number.length() && wordSet.contains(prefix)) { 
11 results.add(prefix); 
12 return; 
"
2718,469,"20 if (letters != null) { 
21 for (char letter : letters) { 
22 getValidWords(number, index + 1, prefix + letter, wordSet, results); 
23 } 
24 } 
25 } 
26 
27 /* Return array of characters that map to this digit. */ 
28 char[] getT9Chars(char digit) { 
29 if (!Character.isDigit(digit)) { 
30 return "
2719,507,"34 } 
35 
36 /* Mapping of digits to letters. */ 
37 char[][] t9Letters = {null, null, {'a', 'b', 'c'}, { 'd', 'e', 'f'}, 
38 
39 
40 }; 
{'g', 'h', 'i'}, 
{'t', 'u', 'v'}, 
{'j', 'k', 'l'}, {'m',
{'w', 'x', 'y', 'z'} 
'n', 'o'}, {'p', 'q', 'r', 's,},
This algorithm runs in O( 4N ) time, where N is "
2720,458,"This is very, very slow on large strings. 
Optimized 
Let's return to thinking about how you would do this, if you were doing it by hand. Imagine the example of 
33835676368 (which corresponds to development). If you were doing this by hand, I bet you'd skip over 
solutions that start with fftf [338"
2721,468,"obviously fail. Specifically, if there are no words in the dictionary that start with prefix, stop recursing. 
The Trie data structure (see ""Tries (Prefix Trees)"" on page 1 OS) can do this for us. Whenever we reach a 
string which is not a valid prefix, we exit. 
1 Arraylist<String> getValidT9Words("
2722,73,"4 return results; 
5 } 
6 
S06 Cracking the Coding Interview, 6th Edition"
2723,506,"Solutions to Chapter 16 { Moderate 
7 void getValidWords(String number, int index, String prefix, TrieNode trieNode, 
8 Arraylist<String> results) { 
9 /* If it's a complete word, print it. */ 
10 if (index == number.length()) { 
11 if (trieNode.terminates()) {//Is complete word 
12 results.add(pref"
2724,477,"20 
21 /* Go through all remaining options. */ 
22 if (letters != null) { 
23 for (char letter : letters) { 
24 TrieNode child= trieNode.getChild(letter); 
25 /* If there are words that start with prefix + letter, 
26 
27 
28 
29 
30 } 
31 } 
32 } 
* then continue recursing. */
if (child != null) {
"
2725,503,"However, this ""short-circuiting"" will make it run much, much faster in practice. 
Most Optimal 
Believe or not, we can actually make it run even faster. We just need to do a little bit of preprocessing. That's 
not a big deal though. We were doing that to build the trie anyway. 
This problem is aski"
2726,464,"do this in advance. 
Our algorithm now has a few steps: 
Pre-Computation: 
1. Create a hash table that maps from a sequence of digits to a list of strings.
2. Go through each word in the dictionary and convert it to its T9 representation (e.g., APPLE - > 27753).
Store each of these in the above hash"
2727,224,"That's it! 
1 /* WORD LOOKUP * / 
2 ArrayList<String> getValidT9Words(String numbers, 
3 HashMapList<String, String> dictionary) { 
4 return dictionary.get(numbers); 
5 } 
6 
Crackin gTheCodinglnterview.com I 6th Edition S07"
2728,432,"Solutions to Chapter 16 \ Moderate
7 /* PRECOMPUTATION */ 
8 
9 /* Create a hash table that maps from a number to all words that have this 
10 * numerical representation. */
11 HashMapList<String, String> initializeDictionary(String[] words) { 
12 /* Create a hash table that maps from a letter to th"
2729,475,"14 
15 /* Create word -> number map. */ 
16 HashMaplist<String, String> wordsToNumbers = new HashMaplist<String, String>(); 
17 for (String word: words) { 
18 String numbers = convertToT9(word, letterToNumberMap); 
19 wordsToNumbers.put(numbers, word); 
20 } 
21 return wordsToNumbers; 
22 } 
23 
24 "
2730,430,"26 HashMap<Character, Character> letterToNumberMap 
27 new HashMap<Character, Character>(); 
28 for (int i= 0; i < t9Letters.length; i++) { 
29 char[] letters = t9Letters[i]; 
30 if (letters != null) { 
31 for (char letter : letters) { 
32 char c = Character.forDigit(i, 10); 
33 letterToNumberMap.pu"
2731,437,"39 
40 /* Convert from a string to its T9 representation. */ 
41 String convertToT9(String word, HashMap<Character, Character> letterToNumberMap) { 
42 StringBuilder sb = new StringBuilder(); 
43 for (char c : word.toCharArray()) { 
44 if (letterToNumberMap.containsKey(c)) { 
45 char digit = letterT"
2732,504,"50 } 
51 
52 char[][] t9Letters =/* Same as before */ 
53 
54 /* HashMaplist<String, Integer> is a HashMap that maps from Strings to 
55 * Arraylist<Integer>. See appendix for implementation. */ 
Getting the words that map to this number will run inO(N) time, where N is the number of digits. TheO(N)"
2733,256,"Note that it's easy to think, ""Oh, linear-that's not that fast:' But it depends what it's linear on. Linear on the 
length of the word is extremely fast. Linear on the length of the dictionary is not so fast. 
508 Cracking the Coding Interview, 6th Edition"
2734,453,"Solutions to Chapter 16 I Moderate 
16.21 Sum Swap: Given two arrays of integers, find a pair of values (one value from each array) that you 
can swap to give the two arrays the same sum. 
EXAMPLE 
lnput:{4, 1, 2, 1, 1, 2}and{3, 6, 3, 3} 
Output: {1, 3} 
SOLUTION 
We should start by trying to unders"
2735,438,"we are for now. After all, computing the sum is an O(N) operation and we know we can't beat O(N) anyway. 
Computing the sum, therefore, won't impact the runtime. 
When we move a (positive) value a from array A to array B, then the sum of A drops by a and the sum of B 
increases by a. 
We are looking"
2736,490,"2a - 2b = sumA - sumB 
a - b = (sumA - sumB) / 2 
Therefore, we're looking for two values that have a specific target difference: (sumA - sumB) / 2. 
Observe that because that the target must be an integer (after all, you can't swap two integers to get a non­
integer difference), we can conclude tha"
2737,503,"We can either do this the ""naive"" way (compare the new sums) or by looking for a pair with that difference. 
Naive approach: 
1 int[] findSwapValues(int[] arrayl, int[] array2) { 
2 int suml sum(arrayl); 
3 int sum2 = sum(ar ray2); 
5 for (int one : arrayl) { 
6 for (int two : array2) { 
7 int newsu"
2738,166,"15 
return values; 
} 
16 return null; 
17 } 
Target approach: 
1 int[] findSwapValues(int[] arrayl, int[] array2) { 
CrackingTheCodinglnterview.com \ 6th Edition 509"
2739,492,"Solutions to Chapter 16 I Moderate
2 Integer target = getTarget(arrayl, array2); 
3 if (target== null) return null; 
4 
5 for (int one : arrayl) { 
6 for (int two : array2) { 
7 if (one - two== target) { 
8 int[] values= {one, two}; 
9 return values; 
13 } 
11 } 
12 } 
13 
14 return null; 
15 } 
16 "
2740,458,"return (suml - sum2) / 2; 
We've used an Integer (a boxed data type) as the return value for getTarget. This allows us to distin-
guish an ""error"" case. 
This algorithm takes O(AB) time. 
Optimal Solution 
This problem reduces to finding a pair of values that have a particu lar difference. With that"
2741,503,"gives us the ""right"" difference. If the value in A is 5 and the target is 3, then we must be looking for the value 
2. That's the only value that could fulfill the goal.
That is, rather than writing one - two == target, we could have written two 
How can we more quickly find an element in B that equ"
2742,487,"iterate through A and look for the appropriate element in B. 
1 int[] findSwapValues(int[] arrayl, int[] array2) { 
2 Integer target= getTarget(arrayl, array2); 
3 if (target== null) return null; 
4 return findDifference(arrayl, array2, target); 
5 } 
6 
7 )* Find a pair of values with a specific di"
2743,193,"10 for (int one : arrayl) { 
11 int two= one - target; 
12 if (contents2.contains(two)) { 
13 int[] values = {one, two}; 
14 return values; 
15 } 
510 Cracking the Coding Interview, 6th Edition"
2744,452,"16 } 
17 
18 return null; 
19 }
20 
Solutions to Chapter 16 I Moderate
21 /* Put contents of array into hash set. */ 
22 HashSet<Integer> getContents(int[] array) { 
23 HashSet<Integer> set= new HashSet<Integer>(); 
24 for (int a : array) { 
25 set.add(a); 
26 } 
27 return set; 
28 } 
This solution "
2745,463,"touch every element in the two arrays. 
Alternate Solution 
If the arrays are sorted, we can iterate through them to find an appropriate pair. This will require less space. 
1 int[] findSwapValues(int[] arrayl, int[] array2) { 
2 Integer target = getTarget(arrayl, array2); 
3 if (target == null) ret"
2746,507,"8 int a 0; 
9 int b = 0; 
10 
11 while (a < arrayl.length && b < array2.length) { 
12 int difference = arrayl[a] - array2[b]; 
13 /* Compare difference to target. If difference is too small, then make it 
14 * bigger by moving a to a bigger value. If it is too big, then make it
15 * smaller by movin"
2747,387,"20 } else if (difference < target) { 
21 a++; 
22 } else { 
23 b++; 
24 } 
25 } 
26 
27 return null; 
28 } 
This algorithm takes O (A + B) time but requires the arrays to be sorted. If the arrays aren't sorted, we can 
still apply this algorithm but we'd have to sort the arrays first. The overall ru"
2748,423,"Solutions to Chapter 16 I Moderate
16.22 Langton's Ant: An ant is sitting on an infinite grid of white and black squares. It initially faces right. 
At each step, it does the following: 
(1) At a white square, flip the color of the square, turn 90 degrees right (clockwise), and move forward
one unit"
2749,422,"forward one unit.
Write a program to simulate the first K moves that the ant makes and print the final board as a grid. 
Note that you are not provided with the data structure to represent the grid. This is something you 
must design yourself. The only input to your method is K. You should print the"
2750,473,"pg 185 
SOLUTION 
At first glance, this problem seems very straightforward: create a grid, remember the ant's position and 
orientation, flip the cells, turn, and move. The interesting part comes in how to handle an infinite grid. 
Solution #1: Fixed Array 
Technically, since we're only running the "
2751,427,"the ant at the center), we know it will be big enough. 
The problem with this is that it's not very extensible. If you run K moves and then want to run another K 
moves, you might be out of luck. 
Additionally, this solution wastes a good amount of space. The max might be K moves in a particular dim"
2752,408,"Solution #2: Resizable Array 
One thought is to use a resizable array, such as Java's ArrayList class. This allows us to grow an array as 
necessary, while still offering 0( 1) amortized insertion. 
The problem is that our grid needs to grow in two dimensions, but the Arraylist is only a single arra"
2753,439,"However, we take a similar approach by building our own resizable grid. Each time the ant hits an edge, we 
double the size of the grid in that dimension. 
What about the negative expansions? While conceptually we can talk about something being at negative 
positions, we cannot actually access array"
2754,456,"-10), but track some sort of offset or delta to translate these coordinates into array indices.
This is actually unnecessary, though. The ant's location does not need to be publicly exposed or consistent 
(unless, of course, indicated by the interviewer). When the ant travels into negative coordinat"
2755,224,"are relabeling all the indices. 
This relabeling will not impact the big O time since we have to create a new matrix anyway. 
1 public class Grid { 
2 private boolean[][] grid; 
512 Cracking the Coding Interview, 6th Edition"
2756,510,"3 private Ant ant new Ant(); 
4 
5 public Grid() { 
6 grid= new boolean[l][l]; 
7 } 
8 
Solutions to Chapter 16 I Moderate 
9 /* Copy old values into new array, with an offset/shift applied to the row and 
10 * columns. */
11 private void copyWithShift{boolean[)[) oldGrid, boolean[][] newGrid, 
12 i"
2757,469,"16 } 
17 } 
18 } 
19 
20 /* Ensure that the given position will fit on the array. If necessary, double 
21 * the size of the matrix, copy the old values over, and adjust the ant's
22 * position so that it's in a positive range. */
23 private void ensureFit(Position position) { 
24 int shiftRow = 0; "
2758,480,"30 shiftRow = numRows; 
31 numRows *= 2; 
32 } else if (position.row >= numRows) { 
33 numRows *= 2; 
34 } 
35 
36 /* Calculate new number of columns. */ 
37 int numColumns = grid[0].length; 
38 if (position.column < 0) { 
39 shiftColumn = numColumns; 
40 numColumns *= 2; 
41 } else if (position.col"
2759,437,"47 boolean[][] newGrid = new boolean[numRows][numColumns]; 
48 copyWithShift(grid, newGrid, shiftRow, shiftColumn); 
49 ant.adjustPosition(shiftRow, shiftColumn); 
50 grid= newGrid; 
51 } 
52 } 
53 
54 /* Flip color of cells. */ 
55 private void flip(Position position) { 
56 int row= position.row; 
"
2760,498,"Solutions to Chapter 16 I Moderate 
59 } 
60 
61 /* Move ant. */ 
62 
63 
64 
public void move() { 
ant.turn(grid[ant.position.row][ant.position.column]); 
flip(ant.position); 
65 ant. move() ; 
66 ensureFit(ant.position); // grow 
67 } 
68 
69 /* Print board. */ 
70 public String toString() { 
71 
"
2761,495,"} 
for (int c = 0; c < grid[0].length; c++) { 
} 
if (r == ant.position.row && c == ant.position.column) { 
sb.append(ant.orientation); 
} else if (grid[r][c]) { 
sb.append(""X""); 
} else { 
sb.append(""_""); 
} 
sb.append(""\n""); 
sb.append(""Ant: "" + ant.orientation + \n""); 
return sb.toString(); 
We p"
2762,508,"1 public class Ant { 
2 public Position position = new Position(0, 0); 
3 public Orientation orientation = Orientation.right; 
4 
5 public void turn(boolean clockwise) { 
6 orientation = orientation.getTurn(clockwise); 
7 } 
8 
9 public void move() { 
10 if (orientation == Orientation.left) { 
11 po"
2763,274,"16 } else if (orientation == Orientation.down) { 
17 position.row++; 
18 } 
19 } 
20 
21 public void adjustPosition(int shiftRow, int shiftColumn) { 
22 position.row += shiftRow; 
23 position.column += shiftColumn; 
24 } 
25 } 
514 Cracking the Coding Interview, 6th Edition"
2764,498,"Solutions to Chapter 16 I Moderate 
Orientation is also its own enum, with a few useful functions. 
1 public enum Orientation { 
2 left, up, right, down; 
3 
4 public Orientation getTurn(boolean clockwise) { 
5 if (this== left) { 
6 return clockwise? up: down; 
7 } else if (this== up) { 
8 return cl"
2765,509,"13 } 
14 } 
15 
16 @Override 
17 public String toString() { 
18 if (this == left) { 
19 return ""\u2190""; 
20 } else if (this== up) { 
21 return ""\u2191""; 
22 } else if (this== right) { 
23 return ""\u2192""; 
24 } else {//down 
25 return ""\u2193""; 
26 } 
27 } 
28 } 
We've also put Position into its ow"
2766,402,"4 
5 public Position(int row, int column) { 
6 this.row= row; 
7 this.column= column; 
8 } 
9 } 
This works, but it's actually more complicated than is necessary. 
Solution #3: HashSet 
Although it may seem ""obvious""that we would use a matrix to represent a grid, it's actually easier not to do 
that"
2767,490,"We can do this by using a HashSet of the white squares. If a position is in the hash set, then the square is 
white. Otherwise, it is black. 
The one tricky bit is how to print the board. Where do we start printing? Where do we end? 
Since we will need to print a grid, we can track what should be to"
2768,93,"right position, updating them if necessary. 
CrackingTheCodinglnterview.com \ 6th Edition 515"
2769,509,"Solutions to Chapter 16 I Moderate 
1 public class Board { 
2 private HashSet<Position> whites = new HashSet<Position>(); 
3 private Ant ant = new Ant(); 
4 private Position topLeftCorner = new Position(0, 0); 
5 private Position bottomRightCorner new Position(0, 0); 
6 
7 public Board() {} 
8 
9 /*"
2770,460,"15 } 
16 
17 /* Flip color of cells. */ 
18 private void flip(Position position) { 
19 if (whites.contains(position)) { 
20 whites.remove(position); 
21 } else { 
22 whites.add(position.clone()); 
23 } 
24 } 
25 
26 /* Grow grid by tracking the most top-left and bottom-right positions.*/ 
27 private"
2771,482,"30 
31 topLeftCorner.row = Math.min(topLeftCorner.row, row); 
32 topLeftCorner.column = Math.min(topLeftCorner.column, column); 
33 
34 bottomRightCorner.row = Math.max(bottomRightCorner.row, row); 
35 bottomRightCorner.column = Math.max(bottomRightCorner.column, column); 
36 } 
37 
38 /* Check if c"
2772,505,"44 public boolean isWhite(int row, int column) { 
45 return whites.contains(new Position(row, column)); 
46 } 
47 
48 /* Print board. */ 
49 public String toString() { 
50 5tringBuilder sb = new StringBuilder(); 
51 int rowMin = topLeftCorner.row; 
52 int rowMax bottomRightCorner.row; 
53 int colMin"
2773,498,"Solutions to Chapter 16 l Moderate 
57 
58 
59 
60 
61 
62 
63 
if (r == ant.position.row && c == ant.position.column) { 
sb.append(ant.orientation); 
64 } 
} else if (isWhite(r, c)) { 
sb.append(""X""); 
} else { 
sb.append(""_""); 
} 
65 sb.append(""\n""); 
66 } 
67 sb.append(""Ant: "" + ant.orientation +"
2774,484,"The position will be the key, so we need to implement a hashCode () function. 
1 public class Position { 
2 public int row; 
3 public int column; 
4 
5 public Position(int row, int column) { 
6 this.row = row; 
7 this.column = column; 
8 } 
9 
10 
11 
12 
13 
14 
@Override 
public boolean equals(Obj"
2775,445,"17 } 
18 
19 @Override 
20 public int hashCode() { 
column; 
21 /* There are many options for hash functions. This is one. */ 
22 return (row * 31) A column; 
23 } 
24 
25 public Position clone() { 
26 return new Position(row, column); 
27 } 
28 } 
The nice thing about this implementation is that if"
2776,444,"Solutions to Chapter 16 I Moderate
16.23 Rand7 from Rand 5: Implement a method rand7 () given rand S (). That is, given a method that 
generates a random number between O and 4 (inclusive), write a method that generates a random 
number between O and 6 (inclusive). 
pg 186 
SOLUTION 
To implement th"
2777,482,"probability. 
First Attempt (Fixed Number of Calls) 
As a first attempt, we might try generating all numbers between O and 9, and then mod the resulting value 
by 7. Our code for it might look something like this: 
1 int rand7() { 
2 int v = rands()+ rands(); 
3 return v % 7; 
4 } 
Unfortunately, th"
2778,492,"1st Call 2nd Call Result 1st Call 2nd Call Result 
0 0 2 3 
0 1 2 4 
0 2 3 0 
0 3 3 1 
0 4 3 2 
1 0 3 3 
1 1 3 4 
1 2 4 0 
1 3 4 1 
1 4 4 2 
2 0 4 3 
2 1 4 4 
2 2 
Each individual row has a 1 in 25 chance of occurring, since there are two calls to rands () and each distrib­
utes its results with Ys "
2779,443,"This means that our function has failed; the results do not have probability ;0th. 
Now, imagine we modify our function to add an if-statement, to change the constant multiplier, or to insert 
a new call to rands (). We will still wind up with a similar looking table, and the probability of getting "
2780,286,"have different number of calls. 
The probability of winding up with the result of the rand7 () function being, say, 6 would be the sum of 
the probabilities of all rows that result in 6. That is: 
P(rand7() = 6) = Ys; + Ysi + ... + Ysm 
- S 18 Cracking the Coding Interview, 6th Edition"
2781,506,"Solutions to Chapter 16 I Moderate
We know that, in order for our function to be correct, this probability must equal ;/,. This is impossible 
though. Because 5 and 7 are relatively prime, no series of reciprocal powers of 5 will result in 1,,1.
Does this mean the problem is impossible? Not exactly."
2782,472,"will not give well distributed results. 
We can still solve this prob/em. We just have to use a while loop, and realize that there's no telling just how 
many turns will be required to return a result. 
Second Attempt (Nondeterministic Number of Calls) 
As soon as we've allowed for a while loop, our"
2783,499,"then we can discard the elements greater than the previous multiple of 7, and mod the rest of them by 7. This 
will get us a value within the range of Oto 6, with each value being equally likely. 
In the below code, we generate the range O through 24 by doing S * rands () + rands (). Then, 
we disca"
2784,490,"Note that because we discard values in this approach, we have no guarantee on the number of rands () calls 
it may take to return a value. This is what is meant by a nondeterministic number of calls. 
1 int rand?() { 
2 while (true) { 
3 int num = 5 * randS() + randS(); 
4 if (num < 21) { 
5 return "
2785,471,"Could we instead do 2 * rands () + rands ()? No, because the values wouldn't be equally distributed. 
For example, there would be three ways of getting a 6 (6 = 2 * 1 + 4, 6 = 2 * 2 + 2, and 6 = 2 
* 3 + 0) but only one way of getting a O (0=2 *0+0). The values in the range are not equally probable."
2786,421,"1 int rand?() { 
2 while (true) { 
3 int rl = 2 * rands(); /* evens between 0 and 9 */ 
4 int r2 = rand5(); /* used later to generate a·0 or 1 */ 
5 if (r2 != 4) { /* r2 has extra even num-discard the extra*/ 
6 int randl = r2 % 2; /* Generate 0 or 1 */ 
7 int num = rl + randl; /* will be in the ran"
2787,443,"Solutions to Chapter 16 I Moderate
In fact, there is an infinite number of ranges we can use. The key is to make sure that the range is big enough 
and that all values are equally likely. 
16.24 Pairs with Sum: Design an algorithm to find all pairs of integers within an array which sum to a 
specifi"
2788,496,"be z - x (that is, the number that can be added to x to make z). For example, if we're trying to find a pair 
of numbers that sums to 12, the complement of-5 would be 17. 
Brute Force 
A brute force solution is to just iterate through all pairs and print the pair if its sum matches the target sum. 
"
2789,434,"4 for (int j = i + 1; j < array.length; j++) { 
5 if (array[i] + array[j] == sum) { 
6 result.add(new Pair(array[i], array[j])); 
7 } 
8 } 
9 } 
10 return result; 
11 } 
If there are duplicates in the array (e.g., { 5, 6, 5} ), it might print the same sum twice. You should discuss 
this with your in"
2790,481,"instances of a key. We walk through the array. At each element x, check how many unpaired instances of 
x's complement preceded it in the array. If the count is at least one, then there is an unpaired instance of x's 
complement. We add this pair and decrement x's complement to signify that this ele"
2791,493,"1 Arraylist<Pair> printPairSums(in t[] array, int sum) { 
2 Arraylist<Pair> result= new Arraylist<Pair>(); 
3 HashMap<Integer, Integer> unpairedCount = new HashMap<Integer, Integer>(); 
4 for (int x: array) { 
5 int complement = sum - x; 
6 if (unpairedCount.getOrDefault(complement, 0) > 0) { 
7 res"
2792,87,"11 } 
12 } 
13 return result; 
14 } 
15 
520 Cracking the Coding Interview, 6th Edition"
2793,475,"Solutions to Chapter 16 I Moderate 
15 void adjustCounterBy(HashMap<Integer, Integer> counter, int key, int delta) { 
17 counter.put(key, counter.getOrDefault(key, 0) + delta); 
18 } 
This solution will print duplicate pairs, but will not reuse the same instance of an element. It will take O(N) 
tim"
2794,444,"{-2, -1, 0, 3, 5, 6, 7, 9, 13, 14}. 
Let first point to the head of the array and last point to the end of the array. To find the complement of 
first, we just move last backwards until we find it. lffirst + last < sum, then there is no comple­
ment for first. We can therefore move first forward. We"
2795,487,"smaller numbers. When the sum of first and last is less than the sum, we know that trying even smaller 
numbers (as last) won't help us find a complement. 
Why must this find all complements for last? Because all pairs must be made up of a first and a last. 
We've found all complements for first, th"
2796,454,"4 int last= array.length - 1; 
5 while (first< last) { 
6 int s = array[first] + array[last]; 
7 if (s == sum) { 
8 System.out.println(array[first] + ff ff+ array[last]); 
9 first++; 
10 last--; 
11 } else { 
12 if (s < sum) first++; 
13 else last-- ; 
14 } 
15 } 
16 } 
This algorithm takes O(N log "
2797,430,"binary search at each element for its complement. This would give us a two-step algorithm, where each 
step isO(N log N).
16.25 LRU Cache: Design and build a ""least recently used"" cache, which evicts the least recently used item. 
The cache should map from keys to values (allowing you to insert and "
2798,325,"recently used item. You can assume the keys are integers and the values are strings. 
pg 785 
SOLUTION 
We should start off by defining the scope of the problem. What exactly do we need to achieve? 
Inserting Key, Value Pair: We need to be able to insert a (key, value) pair. 
CrackingTheCodinglnterv"
2799,486,"Solutions to Chapter 16 I Moderate 
Retrieving Value by Key: We need to be able to retrieve the value using the key. 
Finding Least Recently Used: We need to know the least recently used item (and, likely, the usage 
ordering of all items). 
Updating Most Recently Used: When we retrieve a value by k"
2800,453,"it hits capacity. 
The (key, value) mapping suggests a hash table. This would make it easy to look up the value associated 
with a particular key. 
Keychain Book Blanket Food 
Unfortunately, a hash table usually would not offer a quick way to remove the most recently used item. We 
could mark each i"
2801,479,"Instead, we could use a linked list, ordered by the most recently used. This would make it easy to mark an 
item as the most recently used (just put it in the front of the list) or to remove the least recently used item 
(remove the end). 
72, Food 13, Keychain 45, Blanket 27,Book 
Unfortunately, th"
2802,495,"Each approach does half of the problem (different halves) very well, but neither approach does both parts 
well. 
Can we get the best parts of each? Yes. By using both! 
The linked list looks as it did in the earlier example, but now it's a doubly linked list. This allows us to easily 
remove an ele"
2803,336,"The algorithms now operate as follows: 
Inserting Key, Value Pair: Create a linked list node with key, value. Insert into head of linked list. Insert 
key-> node mapping into hash table. 
Retrieving Value by Key: Look up node in hash table and return value. Update most recently used item 
522 Cracki"
2804,511,"Solutions to Chapter 16 I Moderate 
(see below). 
• Finding Least Recently Used: Least recently used item will be found at the end of the linked list.
Updating Most Recently Used: Move node to front of linked list. Hash table does not need to be
updated.
Eviction: Remove tail of linked list. Get key"
2805,490,"3 private HashMap<Integer, LinkedListNod�> map 
4 new HashMap<Integer, LinkedlistNodel();
s private LinkedListNode listHead = nullf 
6 public LinkedListNode listTail = null; 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
"
2806,504,"public String getValue(int key) { 
} 
LinkedListNode item= map.get(key); 
I if (item== null) return null; 
/* Move to front of list to mark as �ost recently used. */ 
if (item != listHead) { \removeFromLinkedList(item); 
insertAtFrontOfLinkedList(item); 
} 
return item.value; 
/* Remove node from li"
2807,505,"if (node.next != null) node.next.prev = node.prev; 
if (node listTail) listTail node.prev; 
} 
if ( node == listHead) listHead = node 
r
ext; 
/* Insert node at front of linked list. */ 
private void insertAtFrontOflinkedList(LinkedListNode node) { 
if (listHead == null) { 
listHead node; 
listTail "
2808,85,"public boolean removeKey(int key) { 
CrackingTheCodinglnterview.com I 6th Edition S23"
2809,496,"Solutions to Chapter 16 I Moderate 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 } 
} 
LinkedListNode node = map.get(key); 
removeFromLinkedlist(node); 
map.remove(key); 
return true; 
/* Put key, value pair in cac"
2810,501,"/* Remove if already there. */ 
} 
removeKey(key); 
/* If full, remove least recently used item from cache. */ 
if (map.s ize() >= maxCacheSize && listTail != null) { 
removeKey(listTail.key); 
} 
/* Insert new node. */ 
LinkedListNode node = new LinkedListNode(key, value); 
insertAtFrontOfLinkedLis"
2811,446,"public LinkedListNode(int k, String v) { 
key= k; 
} 
} 
value = v; 
Note that we've chosen to make LinkedListNode an inner class of Cache, since no other classes should 
need access to this class and really should only exist within the scope of Cache. 
16.26 Calculator: Given an arithmetic equation"
2812,411,"EXAMPLE 
Input: 
Output: 
SOLUTION 
2*3+5/6*3+15 
23.5 
pg 185 
The first thing we should realize is that the dumb thing-just applying each operator left to right-won't 
work. Multiplication and division are considered ""higher priority"" operations, which means that they have 
to happen before additi"
2813,277,"the addition. If you just processed the equation left to right, you would end up with the incorrect result, 
18, rather than the correct one, 15. You know all of this, of course, but it's worth really spelling out what it 
means. 
524 Cracking the Coding Interview, 6th Edition"
2814,485,"Solutions to Chapter 16 I Moderate
Solution #1 
We can still process the equation from left to right; we just have to be a little smarter about how we do it. 
Multiplication and division need to be grouped together such that whenever we see those operations, we 
perform them immediately on the surro"
2815,481,"we know we need to fully process that term before adding it to the result. 
We can do this by reading left to right and maintaining two variables. 
, The first is processing, which maintains the result of the current cluster of terms (both the operator 
and the value). In the case of addition and su"
2816,469,"subtraction). 
• The second is the result variable. If the next term is an addition or subtraction (or there is no next
term), then processing is applied to result.
On the above example, we would do the following: 
1. Read +2. Apply it to processing. Apply processing to result. Clear processing.
pro"
2817,468,"processing ={-, 6} --> null
result= 
2 --> -4 
3. Read -7. Apply it to processing. Observe next sign is a""*. Continue.
processing={-, 7}
result = -4 
4. Read *8. Apply it to processing. Observe next sign is a/. Continue.
proces sing={-, 56}
result = -4 
5. Read /2. Apply it to 
processing. Observe n"
2818,494,"processing={-, 28} --> null 
result= -4 --> -32 
6. Read +5. Apply it to processing. Apply processing to result. Clear proc essing.
processing={+, 5} --> null
result= -32 --> -27 
The code below implements this algorithm. 
1 /* Compute the result of the arithmetic sequence. This works by reading lef"
2819,289,"4 double compute(String sequence) { 
5 Arraylist<Term> terms = Term.pars eTermSequen ce(sequen ce); 
6 if (terms == null) return Integer.MIN_VALUE; 
8 double result = 0; 
9 Term processing null; 
10 for (int i= 0; i 
< terms.size(); i++) { 
CrackingTheCodinglnterview.com I 6th Edition 525"
2820,461,"Solutions to Chapter 16 I Moderate 
11 
12 
13 
Term current= terms.get(i); 
Term next= i + 1 < terms.size() ? terms.get(i + 1) 
14 /* Apply the current term to ""processing"". */ 
15 processing= collapseTerm(processing, current); 
16 
null; 
17 /* If next term is + or -, then this cluster is done and"
2821,439,"20 I I next.getOperator() == Operator.SUBTRACT) { 
21 result= applyOp(result, processing.getOperator(), processing.getNumber()); 
22 processing= null; 
23 } 
24 } 
25 
26 return result; 
27 } 
28 
29 /* Collapse two terms together using the operator in secondary and the numbers 
30 * from each. */
3"
2822,510,"33 if (secondary== null) return primary; 
34 
35 double value= applyOp(primary.getNumber(), secondary.getOperator(), 
36 secondary.getNumber()); 
37 primary.setNumber(value); 
38 return primary; 
39 } 
40 
41 double applyOp(double left, Operator op, double right) { 
42 if (op== Operator.ADD) return "
2823,449,"46 else return right; 
47 } 
48 
49 public class Term { 
50 public enum Operator { 
51 ADD, SUBTRACT, MULTIPLY, DIVIDE, BLANK 
52 } 
53 
54 private double value; 
55 private Operator operator= Operator.BLANK; 
56 
57 public Term(double v, Operator op) { 
58 value= v; 
59 operator= op; 
60 } 
61 
62 "
2824,181,"64 public void setNumber(double v) {value= v;} 
65 
66 /* Parses arithmetic sequence into a list of Terms. For example, 3-5*6 becomes 
S26 Cracking the Coding Interview, 6th Edition"
2825,485,"Solutions to Chapter 16 I Moderate
67 * something like: [{BLANK,3}, {SUBTRACT, 5}, {MULTIPLY, 6}}.
68 * If improperly formatted, returns null. */
69 public static ArrayList<Term> parseTermSequence(String sequence) { 
70 /* Code can be found in downloadable solutions. */ 
71 } 
72 } 
This takes O(N) "
2826,486,"2 - 6 - 7 * 8 / 2 + 5 
The processing works as follows: 
Each time we see a number, it gets pushed onto numberStac k. 
• Operators get pushed onto operatorStack-as long as the operator has higher priority than the
current top of the stack. If priority( currentOperator) <= priority( operatorStack.
to"
2827,499,"the operator, and push the result onto numberStack.
» Priority: addition and subtraction have equal priority, which is lower than the priority of multipli­
cation and division (also equal priority).
This collapsing continues until the above inequality is broken, at which point currentOperator is 
pu"
2828,508,"- operatorStack.push(-)
6 number5tack.push(6) 
- co llapseStacks [2 - 6]
operatorStack.push(-) 
7 numberStack.push(7) 
* operatorStack.push(*)
· Bit numberstack:push(8)
I collapseStack [7 * 8] 
numberStack.push(/) 
2 numberStack.pi.ish(2) 
+ collapseStack [56 I 2]
collapseStack [-4 - 28]
operatorSta"
2829,191,"-4 -
7, -4 -
7, -4 * 
s: ' . 7)/' ,, 7 V * 7, -4 , -
56, -4 -
56, -4 /, -
2, 56, -4 /, -
28, -4 -
-32 [empty] 
-32 + 
5, 
.,32 + 
-27 [empty] 
CrackingTheCodinglnterview.com I 6th Edition 527"
2830,480,"Solutions to Chapter 16 I Moderate 
The code below implements this algorithm. 
1 public enum Operator { 
2 ADD, SUBTRACT, MULTIPLY, DIVIDE, BLANK 
3 } 
4 
5 double compute(String sequence) { 
6 Stack<Double> numberStack = new Stack<Double> (); 
7 Stack<Operator> operatorStack = new Stack<Operator>()"
2831,475,"13 numberStack.push((double) value); 
14 
15 /* Move to the operator. */ 
16 i += Integer.toString(value).length(); 
17 if (i >= sequence.length()) { 
18 break; 
19 } 
20 
21 /* Get operator, collapse top as needed, push operator. */ 
22 Operator op= parseNextOperator(sequence, i); 
23 collapseTop(o"
2832,455,"27 } 
28 } 
29 
30 /* Do final collapse. */ 
31 collapseTop(Operator.BLANK, numberStack, operatorStack); 
32 if (numberStack.size() == 1 && operatorStack.size() == 0) { 
33 return numberStack.pop(); 
34 } 
35 return 0; 
36 } 
37 
38 /* Collapse top until priority(futureTop) > priority(top). Collapsi"
2833,479,"40 * stack, and then push that onto the numbers stack.*/
41 void collapseTop(Operator futureTop, Stack<Double> numberStack, 
42 Stack<Operator> operatorStack) { 
43 while (operatorStack.size() >= 1 && numberStack.size() >= 2) { 
44 if (priorityOfOperator(futureTop) <= 
45 priorityOfOperator(operator"
2834,165,"49 double collapsed= applyOp(first, op, second); 
50 numberStack.push(collapsed); 
51 } else { 
52 break; 
53 } 
54 } 
S28 Cracking the Coding Interview, 6th Edition"
2835,489,"Solutions to Chapter 16 I Moderate 
55 } 
56 
57 /* Return priority of operator. Mapped so that: 
58 * addition== subtraction< multiplication
59 int priorityOfOperator(Operator op) { 
60 
61 
switch (op) { 
62 
63 
64 
65 
66 } 
case ADD: return 1; 
case SUBTRACT: return 1; 
case MULTIPLY: return 2;"
2836,459,"71 double applyOp(double left, Operator op, double right) { 
72 if (op== Operator.ADD) return left+ right; 
73 else if ( op == Operator. SUBTRACT) return left - right; 
74 else if (op == Operator.MULTIPLY) return left * right; 
75 else if (op== Operator.DIVIDE) return left/ right; 
76 else return ri"
2837,505,"81 StringBuilder sb = new StringBuilder(); 
82 while (offset< seq.length() && Character.isDigit(seq.charAt(offset))) { 
83 sb.append(seq.charAt(offset)); 
84 offset++; 
85 } 
86 return Integer.parseint(sb.toString()); 
87 } 
88 
89 /* Return the operator that occurs as offset. */ 
90 Operator parseN"
2838,496,"96 
97 
98 } 
99 } 
case 
case 
case 
case 
'+':
, 
. 
'*-' : 
'I, : 
return 
return 
return 
return 
100 return Operator.BLANK; 
101 } 
Operator.ADD; 
Operator.SUBTRACT; 
Operator.MULTIPLY; 
Operator.DIVIDE; 
This code also takes 0( N) time, where N is the length of the string. 
This solution invol"
2839,340,"passed in pre-parsed into some sort of data structure. 
Focus on modularizing your code from the beginning and ""farming out"" tedious or less interesting parts of 
the code to other functions. You want to focus on getting the core compute function working. The rest of 
the details can wait! 
Cracking"
2840,460,"17 
Solutions to Hard 
17 .1 Add Without Plus: Write a function that adds two numbers. You should not use+ or any arithmetic 
operators. 
pg 786 
SOLUTION 
Our first instinct in problems like these should be that we're going to have to work with bits. Why? Because 
when you take away the+ sign, what"
2841,460,"problem to see if we can understand something new-some pattern-and then see if we can replicate that 
with code. 
So let's do just that-let's walk through an addition problem. We'll work in base 10 so that it's easier to see. 
To add 759 + 674, I would usually add digit [0] from each number, carry t"
2842,489,"carry the one as necessary. 
Can we make this a little easier? Yes! Imagine I decided to split apart the ""addition"" and ""carry"" steps. That is, 
I do the following: 
1. Add 759 + 674, but""forget"" to carry. I then get 323.
2. Add 759 + 
674 but only do the carrying, rather than the addition of each d"
2843,491,"1110 + 323 = 1433.
Now, how would we do this in binary? 
1. If I add two binary numbers together, but forget to carry, the ith bit in the sum will be 0 only if a and b
have the same ith bit (both 0 or both 1). This is essentially an XOR.
2. If I add two numbers together but only carry, I will have a"
2844,239,"The following code implements this algorithm. 
1 int add(int a, int b) { 
2 if (b == 0) return a; 
3 int sum
= a Ab;// add without carrying 
4 int carry= (a & b) << 1; // carry, but don't add 
530 Cracking the Coding Interview, 6th Edition"
2845,436,"Solutions to Chapter 17 I Hard 
S return add(sum, carry); // recurse with sum + carry 
6 } 
Alternatively, you can implement this iteratively. 
1 int add(int a, int b) { 
2 while (b != 0) { 
3 int sum = a Ab; /I add without carrying 
4 int carry= (a & b) << 1; II carry, but don't add 
S a sum; 
6 b "
2846,431,"The key in all of these problems is to dig into how these operations are usually implemented, so that we can 
re-implement them with the constraints of the given problem. 
17 .2 Shuffle: Write a method to shuffle a deck of cards. It must be a perfect shuffle-in other words, each 
of the 52! permutat"
2847,467,"number generator which is perfect. 
pg 186 
SOLUTION 
This is a very well known interview question, and a well known algorithm. If you aren't one of the lucky few 
to already know this algorithm, read on. 
Let's imagine our n-element array. Suppose it looks like this: 
(l] [2] [ 3] [4] (S] 
Using ou"
2848,481,"Sure. In fact, that's quite easy. We would first shuffle the first n - 1 elements. Then, we would take the nth 
element and randomly swap it with an element in the array. That's it! 
Recursively, that algorithm looks like this: 
1 /* Random number between lower and higher, inclusive*/ 
2 int rand(in"
2849,360,"7 if (i == 0) return cards; 
8 
9 shuffleArrayRecursively(cards, i - 1); // Shuffle earlier part 
10 int k = rand(0, i); // Pick random index to swap with 
11 
12 /* Swap element k and i */ 
13 int temp= cards[k]; 
14 cards(k] cards(i]; 
15 cards[i) = temp; 
16 
17 /* Return shuffled array*/ 
18 ret"
2850,501,"Solutions to Chapter 17 I Hard
19 } 
What would this algorithm look like iteratively? Let's think about it. All it does is moving through the array 
and, for each element i. swapping array [ i] with a random element between 0 and i, inclusive. 
This is actually a very clean algorithm to implement it"
2851,452,"5 cards[k] = cards[i]; 
6 cards[i] = temp; 
7 } 
8 } 
The iterative approach is usually how we see this algorithm written. 
17 .3 Random Set: Write a method to randomly generate a set of m integers from an array of size n. Each 
element must have equal probability of being chosen. 
pg 786 
SOLUTION "
2852,449,"sively using the Base Case and Build approach. 
Suppose we have an algorithm that can pull a random set of m elements from an array of size n - 1. How 
can we use this algorithm to pull a random set of m elements from an array of size n? 
We can first pull a random set of size m from the first n - 1"
2853,500,"An easy way to do this is to pick a random number k from 0 through n. If k < m, then insert array[ n] into 
subset [ k]. This will both ""fairly"" (i.e., with proportional probability) insert array[ n] into the subset and 
""fairly"" remove a random element from the subset. 
The pseudocode for this recu"
2854,498,"4 } else if (i + 1 > m) { 
5 int[] subset = pickMRecursively(original, m, i - 1); 
6 int k = random value between 0 and i, inclusive 
7 if (k < m) { 
8 subset[k] = original[i]; 
9 } 
10 return subset; 
11 } 
12 return null; 
13 } 
This is even cleaner to write iteratively. In this approach, we initi"
2855,181,"the subset at (random) position k whenever k < m. 
1 int[] pickMiteratively(int[] original, int m) { 
2 int[] subset = new int[m]; 
3 
532 Cracking the Coding Interview, 6th Edition"
2856,502,"Solutions to Chapter 17 I Hard 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 } 
/* Fill in subset array with first part of original array*/ 
for (int i= 0; i < m; i++) { 
subset[i] = original[i]; 
} 
/* Go through rest of original array. */ 
for (int i= m; i < original.length; i++) { 
} 
int"
2857,436,"17 .4 Missing Number: An array A contains all the integers from O to n, except for one number which 
is missing. In this problem, we cannot access an entire integer in A with a single operation. The 
elements of A are represented in binary, and the only operation we can use to access them is ""fetch "
2858,481,"in O(n) time? 
pg 786 
SOLUTION 
You may have seen a very similar sounding problem: Given a list of numbers from O to n, with exactly 
one number removed, find the missing number. This problem can be solved by simply adding the list of 
numbers and comparing it to the actual sum of O through n, whic"
2859,496,"lating the sum. 
The runtime of this solution is n * length ( n), when length is the number of bits in n. Note that
length (n) = log/n ). So, the runtime is actuallyO(n log(n) ). Not quite good enough! 
So how else can we approach it? 
We can actually use a similar approach, but leverage the bit val"
2860,497,"00101 
00110 
00111 
01000 
01001 
01010 
01011 
01100 
01101 
Removing the number above creates an imbalance of ls and Os in the least significant bit, which we'll call 
LSB1• In a list of numbers from Oto n, we would expect there to be the same number of Os as 1 s (if n is odd), 
or an additional "
2861,48,CrackingTheCodinglnterview.com I 6th Edition S33
2862,461,"Solutions to Chapter 17 I Hard 
When we remove a value v from the list, we'll know immediately ifv is even or odd just by looking at the 
least significant bits of all the other values in the list. 
a 1 is removed. 
count(0s) > count(ls) 
a 1 is removed. 
count(0s) > count(ls) 
So,if count(0s) <= co"
2863,476,"Okay, but how do we figure out what the next bit in vis? If v were contained in our (now smaller) list, then 
we should expect to find the following (where co unt2 indicates the number of Os or 1 s in the second least 
significant bit): 
count,(0s) = count,(ls) OR count2(0s) = 1 + count2(ls) 
As in "
2864,487,"a 1 is removed. 
count2(0s) > count2(ls) 
Again, we have the same conclusion: 
lf countz<0s) <= count2 (ls),thenLSBz(v) = 0. 
lf countz<0s) > count2 (ls), then LSB2 (v) = 1. 
a 0 is removed. 
count2 ( 0s) < count2 (ls) 
a 1 is removed. 
count2(0s) > count2(ls) 
We can repeat this process for each bi"
2865,427,"discard the odd numbers, and so on. 
By the end of this process, we will have computed all bits in v. In each successive iteration, we look at n, then 
n / 2, then n / 4, and so on, bits. This results in a runtime of O(N). 
If it helps, we can also move through this more visually. In the first itera"
2866,432,"00101 
00110 
00111 
01000 
01001 
01010 
01011 
01100 
01101 
Since count1 (0s) > count/ ls), we know that LSB/v) = 1. Now, discard all numbers x where
LSB1 (x) != LSB1 (v). 
00000 
00001 
000ie 
0file0 
00101 
00H0 
00111 
01000 
01001 
0i-0f0 
01011 
Now, count 2 ( 0s) > count2 (ls), so we know t"
2867,468,"Solutions to Chapter 17 I Hard 
ooree 
OOWi­
OOHe 
00111 
ewee 
0ie0r 
0r0ie 
01011 
This time, count3 ( 0s) <= count/ls), we know that LSB3(v) 
LSB/x) != LSB/v). 
0. Now, discard all numbers x where
00000 ooree ewee ettee 
00001- 00Wi- 0ie0r 9H0l-
000i0 00He 0r0ie 
001H 01011 
We're down to just on"
2868,499,"empty,thencounti(0s) <= counti(1s),soLSB;(v) = 0.ln other words,once we have an empty 
list, we can fill in the rest of the bits of v with 0. 
This process will compute that, for the example above, v = 00011. 
The code below implements this algorithm. We've implemented the discarding aspect by parti"
2869,470,"3 return findMissing(array, 0); 
4 } 
5 
6 int findMissing(Arraylist<Bitinteger> input, int column) { 
7 if (column >= Bitinteger.INTEGER_SIZE) {//We're done! 
8 return 0; 
9 } 
10 Arraylist<Bitlnteger> oneBits = new Arraylist<Bitlnteger>(input.size()/2); 
11 Arraylist<Bitlnteger> zeroBits = new Arr"
2870,460,"16 } else { 
17 oneBits.add(t); 
18 } 
19 } 
20 if (zeroBits.size() <= oneBits.size()) { 
21 int v = findMissing(zeroBits, column+ 1); 
22 return (v << 1) I 0; 
23 } else { 
24 int v = findMissing(oneBits, column+ 1); 
25 return (v << 1) I 1; 
26 } 
27 } 
In lines 24 and 27, we recursively calculate"
2871,487,"Solutions to Chapter 17 I Hard 
17.5 Letters and Numbers: Given an array filled with letters and numbers, find the longest subarray with 
an equal number of letters and numbers. 
pg 186 
SOLUTION 
In the introduction, we discussed the importance of creating a really good, general-purpose example. Th"
2872,502,"all numbers are treated identically. Therefore, we can use an example with a single letter and a single 
number-or, for that matter, As and Bs, Os and 1 s, or Thingls and Thing2s. 
With that said, let's start with an example: 
[A, B, A, A, A, B, B, B, A, B, A, A, B, B, A, A, A, A, A, A] 
We're looki"
2873,482,"and numbers), and find the longest one that is equal. 
We can make one small optimization to this. We can start with the longest subarray and, as soon as we find 
one which fits this equality condition, return it. 
1 /* Return the largest subarray with equal number of 0s and ls. Look at each 
2 * su"
2874,504,"5 for (int len = array.length; len > 1; len--) { 
6 for (int i= 0; i <= array.length - len; i++) { 
7 if (hasEquallettersNumbers(array, i, i + len - 1)) { 
8 return extractSubarray(array, i, i + len - 1); 
9 } 
10 } 
11 } 
12 return null; 
13 } 
14 
15 /* Check if subarray has equal number of letter"
2875,467,"19 if (Character.isletter(array[i])) { 
20 counter++; 
21 } else if (Character.isDigit(array[i])) { 
22 
23 } 
24 } 
counter--; 
25 return counter 
26 } 
27 
0· , 
28 /* Return subarray of array between start and end (inclusive). */ 
29 char[] extractSubarray(char[] array, int start, int end) { 
30 "
2876,469,"Solutions to Chapter 17 ! Hard 
33 } 
34 return subarray; 
35 } 
Despite the one optimization we made, this algorithm is still O ( N2 ), where N is the length of the array. 
Optimal Solution 
What we're trying to do is find a subarray where the count of letters equals the count of numbers. What if 
"
2877,498,"#a 1 2 3 4 4 4 5 5 5 6 7 7 8 9 9 10 11 12 13 14 
#1 0 0 0 0 1 2 2 3 4 4 4 5 5 5 6 6 6 6 6 6 
Certainly, whenever the number of letters equals the number of numbers, we can say that from index Oto 
that index is an ""equal"" subarray. 
That will only tell us equal subarrays that start at index 0. How c"
2878,498,"would that impact the counts? 
a 1 a a a 1 I a 1 1 a 1 a 
#a 1 1 2 3 4 4 I s s s 6 6 1 
#1 0 1 1 1 1 2 I 2 3 4 4 s s 
Study the numbers before the subarray (4, 2) and the end (7, 5). You might notice that, while the values 
aren't the same, the differences are: 4 - 2 = 7 - 5. This makes sense. Since"
2879,422,"index and continues through the final matching index. This explains line 10 in the code below. 
Let's update the earlier array with the differences. 
a a a a 1 1 a 1 1 a a 1 a a 1 a a a a a 
#a 1 2 3 4 4 4 5 5 5 6 7 7 8 9 9 10 11 12 13 14 
#1 0 0 0 0 1 2 2 3 4 4 4 5 5 5 6 6 6 6 6 6 
1 2 3 4 3 2 3 2 "
2880,477,"biggest subarray, we just have to find the two indices farthest apart with the same value. 
To do so, we use a hash table to store the first time we see a particular difference. Then, each time we see the 
same difference, we see if this subarray (from first occurrence of this index to current index"
2881,371,"3 int[] deltas = computeDeltaArray(array); 
4 
5 /* Find pair in deltas with matching values and largest span. */ 
6 int[] match = findlongestMatch(deltas); 
7 
8 /* Return the subarray. Note that it starts one *after* the initial occurence of 
9 * this delta.*/
10 return extract(array, match[0] + 1"
2882,487,"Solutions to Chapter 17 I Hard 
13 /* Compute the difference between the number of letters and numbers between the 
14 * beginning of the array and each index. */
15 int[] computeDeltaArray(char[] array) { 
16 int[] deltas = new int[array.length]; 
17 int delta = 0; 
18 for (int i= 0; i 
< array.len"
2883,488,"23 } 
24 deltas[i] = delta; 
25 } 
26 return deltas; 
27 } 
28 
29 /* Find the matching pair of values in the deltas array with the largest 
30 * difference in indices. */
31 int[] findlongestMatch(int[] deltas) { 
32 HashMap<Integer, Integer> map= new HashMap<Integer, Integer>(); 
33 map.put(0, 
-1"
2884,443,"38 } else { 
39 int match= map.get(deltas[i]); 
40 int distance= i - match; 
41 int longest= max[l] - max[0]; 
42 if (distance > longest) { 
43 max[l] = i; 
44 max[0] = match; 
45 } 
46 } 
47 } 
48 return max; 
49 } 
50 
51 char[] extract(char[] array, int start, int end) {/*same */} 
This solution "
2885,480,"SOLUTION 
pg 186 
Our first approach to this problem can be-and probably should be-a brute force solution. Remember 
that interviewers want to see how you're approaching a problem. Offering a brute force solution is a great 
way to start. 
1 /* Counts the number of '2' digits between 0 and n */ 
2 i"
2886,451,"6 } 
7 return count; 
8 } 
9 
Solutions to Chapter 17 l Hard 
10 /* Counts the number of '2' digits in a single number */ 
11 int number0f2s(int n) { 
12 int count = 0; 
13 while (n > 0) { 
14 if (n % 10 == 2) { 
15 count++; 
16 } 
17 n = n / 10; 
18 } 
19 return count; 
20 } 
The only interesting p"
2887,458,"Improved Solution 
Rather than looking at the problem by ranges of numbers, we can look at the problem digit by digit. Picture 
a sequence of numbers: 
0 1 2 3 4 5 6 7 8 9 
10 11 12 13 14 15 16 17 18 19 
20 21 22 23 24 25 26 27 28 29 
110 111 112 113 114 115 116 117 118 119 
We know that roughly one"
2888,484,"We say""roughly"" because there are (very common) boundary conditions. For example, between 1 and 100, 
the 1 O's digit is a 2 exactly Yio th of the time. However, between 1 and 37, the 1 O's digit is a 2 much more
than 1 /1 Q'h of the time. 
We can work out what exactly the ratio is by looking at the"
2889,502,"There are 2s at the 3rd digit in the ranges 2000 - 2999, 12000 - 12999, 22000 - 22999, 32000 -
32999, 42000 - 42999, and 52000 - 52999. We will not yet have hit the range 62000 - 62999, so 
there are 6000 2s total in the 3rd digit. This is the same amount as if we were just counting all the 2s in th"
2890,164,"2s in the dth digit. 
if x[d) < 2: count2sinRangeAtDigit(x, d) 
let y = round down to nearest 10d•1 
return y / 10 
CrackingTheCodinglnterview.com I 6th Edition 539"
2891,441,"Solutions to Chapter 17 I Hard
Case digit> 2 
Now, let's look at the case where dth digit of xis greater than 2 (x [ d] > 2). We can apply almost the exact 
same logic to see that there are the same number of 2s in the 3rd digit in the range 0 - 63525 as there as 
in the range 0 - 70000. So, rather "
2892,502,"return y I 10 
Case digit= 2 
The final case may be the trickiest, but it follows from the earlier logic. Consider x = 62523 and d = 3. We 
know that there are the same ranges of2s from before (that is, the ranges 2000 - 2999, 12000 - 12999, 
... , 52000 - 52999). How many appear in the 3rd digit in"
2893,484,"let y = round down to nearest 10a+1 
let z = right side of x (i.e., x % 10d) 
return y I 10 + z + 1 
Now, all you need is to iterate through each digit in the number. Implementing this code is reasonably 
straightforward. 
1 int count2sinRangeAtDigit(int number, int d) { 
2 int powerOf10 = (int) Mat"
2894,508,"7 int roundup roundDown + nextPowerOf10; 
8 
9 int digit = (number I power0f10) % 10; 
10 if (digit< 2) { II if the digit in spot digit is 
11 return roundDown I 10; 
12 } else if (digit == 2) { 
13 return roundDown I 10 + right+ 1; 
14 } else { 
15 return roundup I 10; 
16 } 
17 } 
18 
19 int count"
2895,201,"24 } 
25 return count; 
26 } 
This question requires very careful testing. Make sure to generate a list of test cases, and to work through 
each of them. 
540 Cracking the Coding Interview, 6th Edition"
2896,424,"Solutions to Chapter 17 \ Hard 
17.7 Baby Names: Each year, the government releases a list of the 10,000 most common baby names 
and their frequencies (the number of babies with that name). The only problem with this is that 
some names have multiple spellings. For example, ""John"" and ''.Jon"" are es"
2897,505,"of pairs of equivalent names, write an algorithm to print a new list of the true frequency of each 
name. Note that if John and Jon are synonyms, and Jon and Johnny are synonyms, then John and 
Johnny are synonyms. (It is both transitive and symmetric.) In the final list, any name can be used 
as th"
2898,495,"Output: John (27), Kris (36) 
SOLUTION 
pg 787
Let's start off with a good example. We want an example with some names with multiple synonyms and 
some with none. Additionally, we want the synonym list to be diverse in which name is on the left side and 
which is on the right. For example, we wouldn"
2899,490,"Alternate 
John 
Johnny 
John 
Carrie 
Carleton Carlton 
Carrie 5 
The final list should be something like: John (33), Kari (8), Davis(2), Carleton (10). 
Solution #1 
Let's assume our baby names list is given to us as a hash table. (If not, it's easy enough to build one.) 
We can start reading pair"
2900,386,"the future, we could discover that Jonathan is equivalent to something else. 
We can use a hash table (Ll) that maps from a name to its ""true"" name. We'll also need to know, given a 
""true"" name, all the names equivalent to it. This will be stored in a hash table L2. Note that L2 acts as a 
reverse "
2901,501,"Solutions to Chapter 17 I Hard 
Li.ADD Jonathan -> John 
L2.ADD John -> Jonathan 
READ (Jon, Johnny) 
Li.ADD Jon -> Johnny 
LZ.ADD Johnny -> Jon 
READ (Johnny, John) 
LI.ADD Johnny -> John
Li.UPDATE Jon -> John
LZ.UPDATE John -> Jonathan, Johnny, Jon
If we later find that John is equivalent to, say,"
2902,493,"Instead, we can think of these names as ""equivalence classes:'When we find a pair (Jonathan, John), we put 
these in the same set (or equivalence classes). Each name maps to its equivalence class. All items in the set 
map to the same instance of the set. 
If we need to merge two sets, then we copy "
2903,491,"Ll.ADD John -> Setl 
READ (Jon, Johnny) 
CREATE Set2 = Jon, Johnny 
Li.ADD Jon -> Set2 
Ll.ADD Johnny -> Set2 
READ (Johnny, John) 
COPY Set2 into Setl. 
Setl = Jonathan, John, Jon, Johnny 
Ll.UPDATE Jon -> Setl 
Ll.UPDATE Johnny -> Setl 
In the last step above, we iterated through all items in Se t"
2904,487,"String[][] synonyms) { 
/* Parse list and initialize equivalence classes.*/ 
HashMap<String, NameSet> groups = constructGroups(names); 
6 /* Merge equivalence classes together. */ 
7 mergeClasses(groups, synonyms); 
8 
9 /* Convert back to hash map. */ 
10 return convertToMap(groups); 
11 } 
12 
nam"
2905,273,"15 * the first set.*/
16 void mergeClasses(HashMap<String, NameSet> groups, String[][] synonyms) { 
17 for (String[] entry: synonyms) { 
18 String namel entry[e]; 
19 String name2 entry[l]; 
20 NameSet setl groups.get(namel); 
542 Cracking the Coding Interview, 6th Edition"
2906,480,"21 NameSet set2 = groups.get(name2); 
22 if (setl != set2) { 
Solutions to Chapter 17 I Hard 
23 /* Always merge the smaller set into the bigger one. */ 
24 NameSet smaller = set2.size() < setl.size() ? set2 : setl; 
25 NameSet bigger = set2.size() < setl.size() ? setl : set2; 
26 
27 /* Merge lists"
2907,484,"31 
32 /* Update mapping*/ 
33 for (String name : otherNames) { 
34 groups.put(name, bigger); 
35 } 
36 } 
37 } 
38 } 
39 
40 /* Read through (name, frequency) pairs and initialize a mapping of names to 
41 * NameSets (equivalence classes).*/
42 HashMap<String, NameSet> constructGroups(HashMap<Strin"
2908,487,"45 String name = entry.getKey(); 
46 int frequency= entry.getValue(); 
47 NameSet group= new NameSet(name, frequency); 
48 groups.put(name, group); 
49 } 
50 return groups; 
51 } 
52 
53 HashMap<String, Integer> convertToMap(HashMap<String, NameSet> groups) { 
54 HashMap<String, Integer> list = new "
2909,466,"57 } 
58 return list; 
59 } 
60 
61 public class NameSet { 
62 private Set<String> names new HashSet<String>(); 
63 private int frequency= 0; 
64 private String rootName; 
65 
66 public NameSet(String name, int freq) { 
67 names.add(name); 
68 frequency= freq; 
69 rootName = name; 
70 } 
71 
72 publ"
2910,476,"Solutions to Chapter 17 I Hard 
77 public Set<String> getNames() { return names; } 
78 public String getRootName() { return rootName; } 
79 public int getFrequency() { return frequency; } 
80 public int size() { return names.size();} 
81 } 
The runtime of the algorithm is a bit tricky to figure out."
2911,493,"together. Also, for the worst case, the merging should come in the worst possible way: repeated pairwise 
merging of sets. Each merging requires copying the set's elements into an existing set and updating the 
pointers from those items. It's slowest when the sets are larger. 
If you notice the para"
2912,422,"guess it's O ( N log N). That is correct. 
If you don't notice that parallel, here's another way to think about it. 
Imagine we had the names (a, b, c, d, ••• , z). In our worst case, we'd first pair up the items into equivalence 
classes: (a, b), (c, d), (e, f), ... , (y, z). Then, we'd merge pairs"
2913,503,"At each ""sweep""through the list where we merge sets together, half of the items get moved into a new set. 
This takes O(N) work per sweep. (There are fewer sets to merge, but each set has grown larger.) 
How many sweeps do we do? At each sweep, we have half as many sets as we did before. Therefore, "
2914,503,"Optimized Solution 
To optimize the old solution, we should think about what exactly makes it slow. Essentially, it's the merging 
and updating of pointers. 
So what if we just didn't do that? What if we marked that there was an equivalence relationship between 
two names, but didn't actually do any"
2915,178,"group the names by their component, sum up their frequencies, and return a list with one arbitrarily chosen 
name from each group. 
544 Cracking the Coding Interview, 6th Edition"
2916,496,"Solutions to Chapter 17 I Hard 
In practice, how does this work? We could pick a name and do a depth-first (or breadth-first) search to sum 
the frequencies of all the names in one component. We would have to make sure that we hit each compo­
nent exactly once. That's easy enough to achieve: mark a "
2917,507,"2 String[)[) synonyms) { 
3 I* Create data. *I
4 Graph graph= 
constructGraph(names); 
s connectEdges(graph, synonyms); 
6 
7 /* Find components. *I
8 HashMap<String, Integer> rootNames getTrueFrequencies(graph); 
9 return rootNames; 
10 
} 
11 
12 /* Add all names to graph as nodes. *I
13 Graph con"
2918,473,"17 int frequency= entry.getValue(); 
18 graph.createNode(name, frequency); 
19 } 
20 return graph; 
21 } 
22 
23 /* Connect synonymous spellings. *I
24 void connectEdges(Graph graph, String[][] synonyms) { 
25 for (String[] entry : synonyms) { 
26 String namel = entry[0); 
27 String name2 = entry[l]"
2919,440,"33 * has already been computed. *I
34- HashMap<String, Integer> getTrueFrequencies(Graph graph) {
35 HashMap<String, Integer> rootNames 
= new HashMap<String, Integer>(); 
36 for (GraphNode node : graph.getNodes()) { 
37 if (!node.isVisited()) { II Already visited this component 
38 int frequency= g"
2920,377,"41 } 
42 } 
43 return rootNames; 
44 } 
45 
46 I* Do depth-first search to find the total frequency of this component, and mark 
47 * each node as visited.*/
48 int getcomponentFrequency(GraphNode node) { 
49 if (node.isVisited()) return 0; fl Already visited 
50 
51 node.setisVisited(true); 
52 int"
2921,482,"Solutions to Chapter 17 I Hard 
53 for (GraphNode child : node.getNeighbors()) { 
54 sum += getComponentFrequency(child ); 
55 } 
56 return sum; 
57 } 
58 
59 /* Code for GraphNode and Graph is fairly self-explana tory, but can be found in 
60 * the downloadable code solutions.*/
To analyze the effi"
2922,504,"number of baby names and P is the number of pairs of synonyms. This is because we only do a constant 
amount of work per piece of input data. 
• To compute the frequencies, each edge gets ""touched"" exactly once across all of the graph searches and
each node gets touched exactly once to check if it's"
2923,467,"must at least read in the B + P pieces of data. 
17.8 Circus Tower: A circus is designing a tower routine consisting of people standing atop one another's 
shoulders. For practical and aesthetic reasons, each person must be both shorter and lighter than 
the person below him or her. Given the height"
2924,415,"pg187 
SOLUTION ·· ·· ···---····-··-----
When we cut out all the ""fluff"" to this problem, we can understand that the problem is really the following. 
We have a list of pairs of items. Find the longest sequence such that both the first and second items are in non­
decreasing order. 
One thing we mig"
2925,488,"the way there. 
By sorting the items by height, we have a relative order the items must appear in. We still need to find the 
longest increasing subsequence of weight though. 
Solution 1: Recursive 
One approach is to essentially try all possibilities. After sorting by height, we iterate through the"
2926,388,"Arraylist<Htwt> longestincreasingSeq(ArrayList<Htwt> items) { 
Collections.sort(items); 
return bestSeqAtindex(items, new Arraylist<Htwt>(), 0); 
4 } 
5 
6 Arraylist<Htwt> bestSeqAtindex(ArrayList<Htwt> array, Arraylist<Htwt> sequence, 
7 int index) { 
8 if (index >= array.size()) return sequence; 
"
2927,502,"12 Arraylist<Htwt> bestWith = null; 
13 if (canAppend(sequence, value)) { 
Solutions to Chapter 17 I Hard 
14 ArrayList<Htwt> sequenceWith = (ArrayList<Htwt>) sequence.clone();
1s sequenceWitn.add(value); 
16 bestWith = bestSeqAtindex(array, sequenceWith, index + 1); 
17 J 
18 
19 ArrayList<Htwt> be"
2928,506,"23 } else { 
24 return bestWith; 
25 } 
26 } 
27 
28 boolean canAppend(ArrayList<HtWt> solution, Htwt value) { 
29 if (solution== null) return false; 
30 if (solution.size()== 0) return true; 
31 
32 
33 
HtWt last = solution.get(solution.size() - 1); 
return last.isBefore(value); 
34 } 
35 
36 Arra"
2929,453,"41 } 
42 return seql.size() > seq2.size() ? seql seq2; 
43 } 
44 
45 public class Htwt implements Comparable<HtWt> { 
46 private int height; 
47 private int weight; 
48 public HtWt(int h, int w) {height = h; weight w; } 
49 
50 public int compareTo(HtWt second) { 
51 if (this.height != second.height"
2930,472,"55 } 
56 } 
57 
58 /* Returns true if ""this"" should be lined up before ""other"". Note that it's 
59 * possible that this.isBefore(other) and other.isBefore(this) are both false.
60 * This is different from the compareTo method, where if a< b then b 
> a. */
61 public boolean isBefore(Htwt other) {
62"
2931,485,"Solutions to Chapter 17 I Hard 
68 } 
This algorithm will take 0(2°) time. We can optimize it using memoization (that is, caching the best 
sequences). 
There's a cleaner way to do this though. 
Solution #2: Iterative 
Imagine we had the longest subsequence that terminates with each element, A[ 0] t"
2932,490,"Longest(ending with A[l]): 13, 14 
Longest(ending with A[2]): 10 
Longest(ending with A[3]): 10, 11 
Longest(ending with A[4]): 10, 11, 12 
Sure. We just append A[ 4] on to the longest subsequence that it can be appended to. 
This is now fairly straightforward to implement. 
1 Arraylist<Htwt> longes"
2933,486,"new Arraylist<Arraylist<Htwt>>(); 
7 /* Find the longest subsequence that terminates with each element. Track the 
8 * longest overall subsequence as we go. */
9 for (int i= 0; i < array.size(); i++) {
10 Arraylist<HtWt> longestAtindex = bestSeqAtindex(array, solutions, i); 
11 solutions.add(i, long"
2934,501,"19 Arraylist<Htwt> bestSeqAtindex(ArrayList<HtWt> array, 
20 Arraylist<Arraylist<Htwt>> solutions, int index) { 
21 HtWt value = array.get(index); 
22 
23 Arraylist<Htwt> bestSequence = new Arraylist<HtWt>(); 
24 
25 /* Find the longest subsequence that we can append this element to. */ 
26 for (int"
2935,178,"30 } 
31 } 
32 
33 /* Append element. */ 
34 ArrayList<HtWt> best (Arraylist<Htwt>) bestSequence.clone(); 
35 best.add(value); 
36 
S48 Cracking the Coding Interview, 6th Edition"
2936,406,"Solutions to Chapter 17 I Hard 
37 return best; 
38 } 
This algorithm operates in O( n2 ) time. An 0( n log( n)) algorithm does exist, but it is considerably more 
complicated and it is highly unlikely that you would derive this in an interview-even with some help. 
However, if you are interested in"
2937,457,"explanations of this solution. 
17 .9 Kth Multiple: Design an algorithm to find the kth number such that the only prime factors are 3, 5, 
and 7. Note that 3, 5, and 7 do not have to be factors, but it should not have any other prime factors. 
For example, the first several multiples would be (in or"
2938,508,"form 3a * Sb * 7c, Let's start with a brute force way of finding this. 
Brute Force 
We know that biggest this kth number could be is 3k * Sk * ?k. So, the ""stupid"" way of doing this is to 
compute 3a * Sb * 7c for all values of a, b, and c between 0 and k. We can throw them all into a list, sort 
t"
2939,506,"4 return possibilities.get(k); 
5 } 
6 
7 ArrayList<Integer> allPossibleKFactors(int k) { 
8 Arraylist<Integer> values = new Arraylist<Integer>(); 
9 for (int a= 0; a< = k; a++) {//loop 3 
10 int powA = (int) Math.pow(3, a); 
11 for (int b = 0; b <= k; b++) {//loop 5 
12 int powB = (int) Math.pow(S,"
2940,270,"18 if (value < 0 I I powA == Integer.MAX_VALUE I I 
19 powB == Integer.MAX_VALUE I I 
20 pow( == Integer.MAX_VALUE) { 
21 value = Integer.MAX_VALUE; 
22 } 
23 values.add(value); 
24 } 
25 } 
26 } 
27 return values; 
28 } 
CrackingTheCodinglnterview.com / 6th Edition S49"
2941,416,"Solutions to Chapter 17 I Hard 
What is the runtime of this approach? We have nested for loops, each of which runs for k iterations. The 
runtime of the allPossibleKFactors is O(k3). Then, we sort the k3 results in D(k3 log (k3)) time
(which is equivalent toO(k3 log k) . This gives us a runtime ofO("
2942,504,"flow), but honestly this algorithm is fairly slow. We should instead focus on reworking the algorithm. 
Improved 
Let's picture what our results will look like. 
1 30 * 50 * 70 
3 3 31 * 50 * 70
5 5 30 * 51 * 70
7 7 30 * 50 * 71
9 3*3 32 * 50 * 70 
15 3*5 31 * 51 * 70 
21 3*7 31 * 50 * 71
25 5*5 30 "
2943,481,"• 3 * (some previous number in list)
• 5 * (some previous number in list)
• 7 * (some previous number in list)
If this doesn't immediately jump out at you, think about it this way: whatever the next value (let's call it nv) 
is, divide it by 3. Will that number have already appeared? As long as nv h"
2944,449,"Ak is, by definition, the next number in the list. Therefore, Ak will be the smallest ""new"" number (a number
that it's already in {A1, ••• , A k-1}) that can be formed by multiplying each value in the list by 3, 5 or 7.
How would we find AJ Well, we could actually multiply each number in the list by"
2945,392,"do better. 
Rather than Ak trying to""pull"" from a previous element in the list (by multiplying all of them by 3, 5 and 7),
we can think about each previous value in the list as ""pushing"" out three subsequent values in the list. That 
is, each number Ai will eventually be used later in the list in th"
2946,511,"Solutions to Chapter 17 I Hard 
We can use this thought to plan in advance. Each time we add a number Ai to the list, we hold on to the 
values 3A., 5A., and 7 A. in some sort of temporary list. To generate A1+1' we search through this temporary 
1 1 1 
list to find the smallest value. 
Our code loo"
2947,422,"9 q.remove(min);
10 } 
11 return 
min; 
12 } 
13 
14 void addProduc ts(Queue<Integer> q, int v) { 
15 q.add(v * 3); 
16 q.add(v * 5);
17 q.add(v * 7);
18 } 
19 
20 int getKthMagicNumber(int k) { 
21 if (k < 0) return 
0; 
22 
23 int val= l; 
24 Queue<Integer> q = new Linkedlist<Integer>(); 
25 addPr"
2948,459,"28 addProducts(q, val); 
29 } 
30 return val; 
31 } 
This algorithm is certainly much, much better than our first algorithm, but it's still not quite perfect. 
Optimal Algorithm 
To generate a new element Ai, we are searching through a linked list where each element looks like one of: 
3 * previous "
2949,474,"Let's imagine our list looks like: 
q6 = {7A1, SA2, 7A2, 7A3, 3A4, SA4, 7A4, SAs, 7 As} 
When we search this list for the min, we check if 7 A1 < min, and then later we check if 7 As < min. That 
seems sort of silly, doesn't it? Since we know that A1 < As, we should only need to check 7 A1• 
If we s"
2950,48,CrackingTheCodinglnterview.com I 6th Edition 551
2951,412,"Solutions to Chapter 17 I Hard 
That is, our list above would look like: 
Q36 = {3A4}
Q56 = {SA,, SA., SAS} 
Q76 = {7A1, 7A2, 7A3, 7A4, 7A,} 
To get the min, we only need to look at the fronts of each queue: 
y = min(Q3.head(), Q S.head(), Q7.head()) 
Once we compute y, we need to insert 3y into Q3,"
2952,468,"these elements if they aren't already in another list. 
Why might for example, 3y already be somewhere in the holding queues? Well, if y was pulled from Q7, 
then that means that y = 7x, for some smaller x. If 7x is the smallest value, we must have already seen 3x. 
And what did we do when we saw 3x"
2953,468,"already handled 3 * suffix and 5 * suffix. In handling 3 * suffix, we inserted 7 * 3 * suffix 
into a Q7. And in handling 5 * suffix, we know we inserted 7 * 5 * suffix in Q7. The only value we 
haven't seen yet is 7 * 7 * suffix, so we just insert 7 * 7 * suffix into Q7. 
Let's walk through this wi"
2954,504,"Q3 3*3 
QS = 5, 5*3 
Q7 = 7, 7*3 
remove min = 5. 3*5 is a dup, since we already did 5*3. insert 5*5 into Q5, 7*5 
into Q7. 
Q3 3*3 
QS 5*3, 5*5 
Q7 7, 7*3, 7*5.
remove min = 7. 3*7 and 5*7 are dups, since we already did 7*3 and 7*5. insert 7*7 
into Q7. 
Q3 3*3 
QS 5*3, 5*5 
Q7 7*3, 7*5, 7*7 
remov"
2955,426,"5*5*3 in Q5, 7*5*3 into Q7. 
Q3 3*3*3 
Q5 = 5*5, 5*3*3, 5*5*3 
Q7 = 7*3, 7*5, 7*7, 7*3*3, 7*5*3 
remove min = 7*3 = 21. 3*(7*3) and 5*(7*3) are dups, since we already did 7*(3*3) 
and 7*(5*3). insert 7*7*3 into Q7. 
Q3 3*3*3 
Q5 = 5*5, 5*3*3, 5*5*3 
Q7 = 7*5, 7*7, 7*3*3, 7*5*3, 7*7*3 
Our pseudocode"
2956,509,"Solutions to Chapter 17 I Hard 
2. Insert 1 into array.
3. Insert 1 *3, 1 *5 and 1 *7 into Q3, QS, and Q7 respectively.
4. Let x be the minimum element in Q3, QS, and Q7. Append x to magic.
5. If x was found in:
Q3 -> append x*3, x*S and x*7 to Q3, QS, and Q7. Remove x from Q3.
QS -> append x*5 and "
2957,509,"1 int getKthMagicNumber(int k) { 
2 if (k < 0) { 
3 return 0; 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 } 
} 
int val = 0; 
Queue<Integer> queue3 
Queue<Integer> queues 
Queue<Integer> queue7 
queue3.add(l); 
new Linkedlist<Integer>(); 
new"
2958,510,"int vs= queues.size() > 0? queues.peek() 
int v7 = queue7.size() > 0? queue7.peek() 
val= Math.min(v3, Math.min(v5, v7)); 
Integer.MAX_VALUE; 
Integer.MAX_VALUE; 
Integer.MAX_VALUE; 
if (val== v3) { II enqueue into queue 3, Sand 7 
queue3.remove(); 
queue3.add(3 * val); 
queueS.add(S * val); 
} else"
2959,429,"} 
queue7.add(7 * val);// Always enqueue into Q7 
return val; 
When you get this question, do your best to solve it-even though it's really difficult. You can start with a 
brute force approach (challenging, but not quite as tricky), and then you can start trying to optimize it. Or, 
try to find a p"
2960,331,"Think out loud, wonder out loud, and explain your thought process. Your interviewer will probably jump in 
to guide you. 
Remember, perfection on this problem is not expected. Your performance is evaluated in comparison to 
other candidates. Everyone struggles on a tricky problem. 
CrackingTheCoding"
2961,511,"Solutions to Chapter 17 I Hard
17 .1 o Majority Element: A majority element is an element that makes up more than half of the items in 
an array. Given a positive integers array, find the majority element. If there is no majority element, 
return -1. Do this in O(N) time and 0(1) space. 
Input: 1 2 "
2962,501,"ning, it must appear much more often toward the end. That's a good observation to make. 
This interview question specifically requires us to do this in 0( N) time and 0( 1) space. Nonetheless, some­
times it can be useful to relax one of those requirements and develop an algorithm. Let's try relaxin"
2963,494,"majority element. This takes O(N2) time and 0(1) space. 
1 int findMajorityElement(int[] array) { 
2 for (int x: array) { 
3 if (validate(array, x)) { 
4 return x; 
5 } 
6 } 
7 return -1; 
8 } 
9 
10 boolean validate(int[] array, int majority) { 
11 int count = 0; 
12 for (int n: array) { 
13 if (n "
2964,410,"about optimizing this. 
Solution #2 (Optimal) 
Let's think about what that algorithm did on a particular example. Is there anything we can get rid of? 
In the very first validation pass, we select 3 and validate it as the majority element. Several elements later, 
we've still counted just one 3 and "
2965,465,"Solutions to Chapter 17 I Hard 
On one hand, yes. 3 could redeem itself and be the majority element, if there are a bunch of 3s later in the 
array. 
On the other hand, not really. If 3 does redeem itself, then we'll encounter those 3s later on, in a subsequent 
validation step. We could terminate t"
2966,494,"validate( 1), validate(7), and so on.
Since the logic was okay for the first element, what if we treated all subsequent elements like they're the 
first element of some new subarray? This would mean that we start validate(array[l]) at index 1, 
validate ( array [ 2]) at index 2, and so on. 
What wou"
2967,485,"validate(l) 
sees 1 -> countYes = 0, countNo = 0 
sees 7 -> countYes = 1, countNo = 1
TERMINATE. 1 is not majority thus far. 
validate(7) 
sees 7 -> countYes = 1, countNo = 0 
sees 1 -> countYes = 1, countNo = 1
TERMINATE. 7 is not majority thus far. 
validate(l) 
sees 1 -> countYes 1, countNo 0 
se"
2968,456,"validate(l) 
sees 1 -> countYes = 1, countNo = 0 
sees 7 -> countYes = 1, countNo = 1
TERMINATE. 1 is not majority thus far. 
validate(7) 
sees 7 -> countYes 1, countNo 0 
sees 7 -> countYes 2, countNo 0 
sees 3 -> 
sees 7 -> 
sees 7 -> 
sees 7 -> 
countYes 2, 
countYes 3, 
countYes = 4, 
countYes ="
2969,504,"before that 7, and everything after it. But there could be no majority element. A quick validate (7) pass 
that starts from the beginning can confirm if? is actually the majority element. This validate step will be 
O(N) time, which is also our Best Conceivable Runtime. Therefore, this final validat"
2970,481,"being ""inspected"" repeatedly. Can we get rid of this? 
Lookat thefirstvalidate ( 3 ). This fails after the subarray [ 3, 1], because 3 was not the majority element. 
But because validate fails the instant an element is not the majority element, it also means nothing else 
in that subarray was the ma"
2971,48,CrackingTheCodinglnterview.com I 6th Edition SSS
2972,490,"Solutions to Chapter 17 I Hard
Let's try this again and see if it works out. 
validate(3) 
sees 3 -> countYes = 1, countNo 0 
sees 1 -> countYes = 1, countNo 1 
TERMINATE. 3 is not majority thus far. 
skip 1 
validate(7) 
sees 7 -> countYes = 1, countNo = 0 
sees 1 -> countYes = 1, countNo = 1 
TERM"
2973,421,"TERMINATE. 1 is not majority thus far. 
skip 7 
validate(7) 
sees 7 -> countYes = 1, countNo = 0 
sees 3 -> countYes = 1, countNo = 1 
TERMINATE. 7 is not majority thus far. 
skip 3 
validate(7) 
sees 7 -> countYes 1, countNo 0 
sees 7 -> countYes 2, countNo 0 
sees 7 -> countYes 3, countNo 0 
Good!"
2974,508,"1. We start off with [ 3] and we expand the subarray until 3 is no longer the majority element. We fail at
[ 3, 1]. At the moment we fail, the subarray can have no majority element.
2. Then we go to [ 7] and expand until [ 7, 1]. Again, we terminate and nothing could be the majority
element in that "
2975,454,"5. We go to [ 7] and expand until the end of the array: [ 7, 7, 7]. We have found the majority element
(and now we must validate that).
Each time we terminate the validate step, the subarray has no majority element. This means that there 
are at least as many non-7s as there are 7s. Although we're e"
2976,503,"status. Therefore, at some point, we will discover the majority element. 
Our algorithm can now be run in two passes: one to find the possible majority element and another to vali­
date it. Rather than using two variables to count (countYes and countNo), we'll just use a single count 
variable that "
2977,109,"4 } 
5 
6 int getCandidate(int[] array) { 
7 int majority= 0; 
SS6 Cracking the Coding Interview, 6th Edition"
2978,504,"Solutions to Chapter 17 I Hard
8 int count = 0; 
9 for (int n : array) { 
10 if (count== 0) { II No majority element in previous set. 
11 majority= n; 
12 } 
13 if (n == majority) { 
14 count++; 
15 } else { 
16 count- -; 
17 } 
18 } 
19 return majority; 
20 } 
21 
22 boolean validate(int[] array, i"
2979,484,"31 } 
This algorithm runs in O(N) time and 0(1) space. 
17 .11 Word Distance: You have a large text file containing words. Given any two words, find the shortest 
distance (in terms of number of words) between them in the file. If the operation will be repeated 
many times for the same file (but dif"
2980,488,"tion you should ask your interviewer. 
To solve this problem, we can traverse the file just once. We remember throughout our traversal where 
we've last seen wordl and word 2, storing the locations in locationl and location2. If the current 
locations are better than our best known location, we upda"
2981,441,"2 LocationPair best = new LocationPair(-1, -1); 
3 LocationPair current= new LocationPair(-1, -1); 
4 for (int i= 0; i < words.length; i++) { 
5 String word= words[i]; 
6 if (word.equals(wordl)) { 
7 current.locationl = i; 
8 best.updateWithMin(current); 
9 } else if (word.equals(word2)) { 
10 curre"
2982,474,"Solutions to Chapter 17 I Hard 
14 return best; 
15 } 
16 
17 public class LocationPair { 
18 public int locationl, location2; 
19 public LocationPair(int first, int second) { 
20 setLocations(first, second); 
21 } 
22 
23 public void setLocations(int first, int second) { 
24 this.locationl = first;"
2983,430,"30 } 
31 
32 public int distance() { 
33 return Math.abs(locationl - location2); 
34 } 
35 
36 public boolean isValid() { 
37 return locationl >= 0 && location2 >= 0; 
38 } 
39 
40 public void updateWithMin(LocationPair loc) { 
41 if (!isValid() I I loc.distance() < distance()) { 
42 setlocations(lo"
2984,473,"word to the locations where it occurs. We'll only need to read through the list of words once. After that 
point, we can do a very similar algorithm but just iterate through the locations directly. 
Consider the following lists of locations. 
listA: {l, 2, 9, 15, 25} 
listB: {4, 10, 19} 
Picture poi"
2985,476,"The first potential pair is ( 1, 4). 
What is the next pair we can find? If we moved pB, then the distance would definitely get larger. If we 
moved pA, though, we might get a better pair. Let's do that. 
The second potential pair is ( 2, 4). This is better than the previous pair, so let's record th"
2986,204,"Next we get (15, 10), then (15, 19), then (25, 19). 
We can implement this algorithm as shown below. 
1 LocationPair findClosest(String wordl, String word2, 
558 Cracking the Coding Interview, 6th Edition"
2987,509,"Solutions to Chapter 17 I Hard 
2 HashMaplist<String, Integer> locations) { 
3 Arraylist<Integer> locationsl = locations.get(wordl); 
4 Arraylist<Integer> locations2 = locations.get(word2); 
5 return findMinDistancePair(locationsl, locations2); 
6 } 
7 
8 LocationPair findMinDistancePair(Arraylist<I"
2988,495,"13 } 
14 
15 int indexl = 0; 
16 int index2 = 0; 
17 LocationPair best = new LocationPair(array1.get(0), array2.get(0)); 
18 LocationPair current = new LocationPair(arrayl.get(0), array2.get(0)); 
19 
20 while (indexl < arrayl.size() && index2 < array2.size()) { 
21 current.setlocations(arrayl.get(i"
2989,506,"24 indexl++; 
25 } else { 
26 index2++; 
27 } 
28 } 
29 
30 return best; 
31 } 
32 
33 /* Precomputation. */ 
34 HashMaplist<String, Integer> getWordlocations(String[] words) { 
35 HashMaplist<String, Integer> locations new HashMaplist<String, Integer>(); 
36 for (int i= 0; i < words.length; i++) { "
2990,397,"43 * Arraylist<Integer>. See appendix for implementation. */
The precomputation step of this algorithm will take O(N) time, where N is the number of words in the 
string. 
Finding the closest pair of locations will take O (A + B) time, where A is the nu mber of occurrences of the 
first word and B i"
2991,429,"Solutions to Chapter 17 I Hard
17.12 BiNode: Consider a simple data structure called BiNode, which has pointers to two other nodes. The 
data structure BiNode could be used to represent both a binary tree (where node1 is the left node 
and node2 is the right node) or a doubly linked list (where node"
2992,468,"into a doubly linked list. The values should be kept in order and the operation should be performed 
in place (that is, on the original data structure). 
pg 188 
SOLUTION 
This seemingly complex problem can be implemented quite elegantly using recursion. You will need to 
understand recursion very w"
2993,488,"0 <-> 1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 6 
Let's approach this recursively, starting with the root (node 4). 
We know that the left and right halves of the tree form their own ""sub-parts"" of the linked list (that is, they 
appear consecutively in the linked list). So, if we recursively converted the lef"
2994,409,"The pseudocode looks something like: 
1 BiNode convert(BiNode node) { 
2 BiNode left = convert(node.left); 
3 BiNode right= convert(node.right); 
4 mergelists(left, node, right); 
5 return left;// front of left 
6 } 
To actually implement the nitty-gritty details of this, we'll need to get the head "
2995,356,"Solution #1: Additional Data Structure 
The first, and easier, approach is to create a new data structure called NodePair which holds just the head 
and tail of a linked list. The convert method can then return something of type NodePair. 
The code below implements this approach. 
1 private class No"
2996,479,"2 BiNode head, tail; 
3 
4 public NodePair(BiNode head, BiNode tail) { 
5 this.head= head; 
6 this.tail= tail; 
7 } 
8 } 
9 
10 public NodePair convert(BiNode root) { 
11 if (root == null) return null; 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
NodePair partl 
NodePair part2 
convert(root.nodel); "
2997,445,"} 
Solutions to Chapter 17 I Hard 
23 
24 
25 
26 } 
27 
return new NodePair(partl == null? root 
part2 == null? root 
partl. head, 
part2.tail); 
28 public static void concat(BiNode x, BiNode y) { 
29 x.node2 y; 
30 y.nodel = x; 
31 } 
The above code still converts the BiNode data structure in plac"
2998,491,"purposes, but it looks a bit messier (and we like clean code, especially in an interview). 
It'd be nice, though, if we could do this without these extra data structures-and we can. 
Solution #2: Retrieving the Tail 
Instead of returning the head and tail of the linked list with NodePair, we can ret"
2999,293,"3 
4 
5 
6 
BiNode partl 
BiNode part2 
convert(root.nodel); 
convert(root.node2); 
7 if (partl != null) { 
8 concat(getTail(partl), root); 
9 } 
10 
11 if (part2 != null) { 
12 concat(root, part2); 
13 } 
14 
15 return partl null? root partl; 
CrackingTheCodinglnterview.com I 6th Edition 561"
3000,426,"Solutions to Chapter 17 I Hard 
16 } 
17 
18 public static BiNode getTail(BiNode node) { 
19 if (node == null) return null; 
20 while (node.node2 != null) { 
21 node = node.node2; 
22 } 
23 return node; 
24 } 
Other than a call to getTail, this code is almost identical to the first solution. It is n"
3001,498,"it), leading to an 0( N2 ) overall runtime, where N is the number of nodes in the tree. 
Solution #3: Building a Circular Linked List 
We can build our third and final approach off of the second one. 
This approach requires returning the head and tail of the linked list with BiNode. We can do this b"
3002,493,"2 if (root == null) return null; 
3 
4 
5 
BiNode partl 
BiNode part3 
convertToCircular(root.nodel); 
convertToCircular(root.node2); 
6 
7 if (partl == null && part3 == null) { 
8 root.nodel = root; 
9 root.node2 = root; 
10 return root; 
11 
12 
13 
} 
BiNode tail3 = (part3 
14 /* join left to roo"
3003,419,"19 } 
20 
21 /* join right to root*/ 
22 if (part3 == null) { 
23 concat(root, partl); 
24 } else { 
25 concat(root, part3); 
26 } 
27 
28 /* join right to left*/ 
29 if (partl != null && part3 != null) { 
30 concat(tail3, partl); 
31 } 
32 
33 
34 } 
35 
return partl null? root partl; 
36 /* Conver"
3004,505,"37 BiNode convert(BiNode root) { 
38 BiNode head= convertToCircular(root); 
39 head.nodel.node2 = null; 
40 head.nodel = null; 
41 return head; 
42 } 
Solutions to Chapter 17 I Hard 
Observe that we have moved the main parts of the code into co nvertToCirc ular. The co nvert 
method calls this metho"
3005,496,"0(1) times). 
17.13 Re-Space: Oh, no! You have accidentally removed all spaces, punctuation, and capitalization in a 
lengthy document. A sentence like ""I reset the computer. It still didn't boot!"" 
became ""iresetthec omputeri tstilldidntboot''. You'll deal with the punctuation and capi­
talization "
3006,482,"to unconcatenate the document in a way that minimizes the number of unrecognized characters. 
EXAMPLE 
Input jesslookedjustliketimherbrother 
Output: jess looked just like tim her brother (7 unrecognized characters) 
pg 788
SOLUTION 
Some interviewers like to cut to the chase and give you the specif"
3007,483,"what it's really all about. 
In this case, the problem is really about finding a way to break up a string into separate words such that as 
few characters as possible are ""left out"" of the parsing. 
Note that we do not attempt to ""understand""the string. We could just as well parse ""thisisawesome"" to"
3008,508,"lems. One way to do this is recursing through the string. 
The very first choice we make is where to insert the first space. After the first character? Second character? 
Third character? 
Let's imagine this in terms of a string like thisismikesfavori tefood. What is the first space we insert? 
If w"
3009,103,"• At thisi is five invalid characters .
... and so on.
CrackingTheCodinglnterview.com I 6th Edition 563"
3010,466,"Solutions to Chapter 17 I Hard
After we choose the first space, we can recursively pick the second space, then the third space, and so on, 
until we are done with the string. 
We take the best (fewest invalid characters) out of all these choices and return. 
What should the function return? We need "
3011,479,"1 String bestSplit(HashSet<String> dictionary, String sentence) { 
2 ParseResult r = split(dictionary, sentence, 0); 
3 return r == null? null: r.parsed; 
4 } 
5 
6 ParseResult split(HashSet<String> dictionary, String sentence, int start) { 
7 if (start >= sentence.length()) { 
8 return new ParseRes"
3012,480,"14 int index = start; 
15 while (index < sentence.length()) { 
16 char c = sentence.charAt(index); 
17 partial+= c; 
18 int invalid= dictionary.contains (partial) ? 0: partial.length(); 
19 if (invalid < bestinvalid) {//Short circuit 
20 /* Recurse, putting a space after this character. If this is b"
3013,478,"23 if (invalid+ result.invalid < bestinvalid) {
24 bestinvalid =invalid+ result.invalid; 
25 bestParsing = partial + "" "" + result.parsed; 
26 if (bestlnvalid == 0) break;// Short circuit 
27 } 
28 } 
29 
30 index++; 
31 } 
32 return new ParseResult(bestinvalid, bestParsing); 
33 } 
34 
35 public cla"
3014,439,"39 invalid= inv; 
40 parsed= p; 
41 } 
42 } 
We've applied two short circuits here. 
Line 22: If the number of current invalid characters exceeds the best known one, then we know this 
recursive path will not be ideal. There's no point in even taking it. 
Line 30: If we have a path with zero invalid"
3015,483,"Solutions to Chapter 17 I Hard
What's the runtime of this? It's difficult to truly describe in practice as it depends on the (English) language. 
One way of looking at it is to imagine a bizarre language where essentially all paths in the recursion are 
taken. In this case, we are making both choice"
3016,488,"memoization (that is, caching results). To do so, we need to find the common subproblems. 
Where do recursive paths overlap? That is, where are the common subproblems? 
Let's again imagine the string thisismikesfavori tefood. Again, imagine that everything is a valid 
word. 
In this case, we attempt"
3017,489,"t + split(hisismikesfavoritefood) 
OR th+ split(isismikesfavoritefood) 
OR ... 
split(hisismikesfavoritefood) -> 
h + split(isismikesfavoritefood) 
OR ... 
Adding a space after t and h leads to the same recursive path as inserting a space after th. There's no sense 
in computing split ( isismikesfav"
3018,485,"the ParseResul t object. 
We don't actually need to make the current substring a key. The st a rt index in the string sufficiently represents 
the substring. After all, if we were to use the substring, we'd really be using sentence. substring(start, 
sentence . length). This hash table will map from"
3019,494,"ParseResul t objects. This will also serve the purpose of mapping from an index to an object. 
The code is essentially identical to the earlier function, but now takes in a memo table (a cache). We look up 
when we first call the function and set it when we return. 
l String bestSplit(HashSet<String"
3020,331,"4 return r == null? null: r.parsed; 
5 } 
6 
7 ParseResult split(HashSet<String> dictionary, String sentence, int start, 
8 ParseResult [] memo) { 
9 if (start >= sentence.length()) { 
10 return new ParseResult(0, """"); 
11 } if (memo[start] != null) { 
12 return memo[start]; 
13 } 
CrackingTheCoding"
3021,439,"Solutions to Chapter 17 I Hard
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 } 
int bestinvalid = Integer.MAX_VALUE; 
String bestParsing = null; 
String partial=""""; 
int index = start; 
while (index < sentence.length()) { 
char c = sentence.charAt"
3022,508,"if (invalid< bestinvalid) { II Short circuit 
I* Recurse, putting a space after this character. If this is better than 
* the current best option, replace the best option. *I
ParseResult result = split(dictionary, sentence, index + 1, memo);
if (invalid+ result.invalid< bestinvalid) {
} 
} 
bestinva"
3023,494,"return memo[start]; 
Understanding the runtime of this is even trickier than in the prior solution. Again, let's imagine the truly 
bizarre case, where essentially everything looks like a valid word. 
One way we can approach it is to realize that split ( i) will only be computed once for each value "
3024,443,"split(i + 2) 
split(i + 3) 
split(i + 4) 
split(n - 1) 
Each of the recursive calls has already been computed, so they just return immediately. Doing n - i calls 
at 0( 1) time each takes O( n - i) time. This means that split ( i) takes 0( i) time at most. 
We can now apply the same logic to split(i"
3025,237,"calls to compute split ( 0), how many calls total do we do? This is basically the sum of the numbers from 
1 through n, which is O ( n2). 
Therefore, the runtime of this function is 0( n2). 
566 Cracking the Coding Interview, 6th Edition"
3026,476,"Solutions to Chapter 17 I Hard 
17 .14 Smallest K: Design an algorithm to find the smallest K numbers in an array. 
pg/88 
SOLUTION 
There are a number of ways to approach this problem. We will go through three of them: sorting, max heap, 
and selection rank. 
Some of these algorithms require modify"
3027,487,"array and modify the clone instead. This will not impact the overall big O time of any algorithm. 
Solution 1: Sorting 
We can sort the elements in ascending order and then take the first million numbers from that. 
1 int[] smallestK(int[] array, int k) { 
2 if (k <= 0 I I k > array.length) { 
3 thr"
3028,457,"11 for (int i= 0; i < k; i++) { 
12 smallest[i] = array[i]; 
13 } 
14 return smallest; 
15 } 
The time complexity is O(n log(n ) ). 
Solution 2: Max Heap 
We can use a max heap to solve this problem. We first create a max heap (largest element at the top) for the 
first million numbers. 
Then, we tr"
3029,508,"and delete the largest element (which will be the root). 
At the end of the traversal, we will have a heap containing the smallest one million numbers. This algorithm 
is O(n log(m) ), where mis the number of values we are looking for. 
1 int[] smallestK(int[] array, int k) { 
2 if (k <= 0 I I k > a"
3030,201,"8 } 
9 
10 /* Create max heap of smallest k elements. */ 
11 PriorityQueue<Integer> getKMaxHeap(int[] array, int k) { 
12 PriorityQueue<Integer> heap = 
CrackingTheCodinglnterview.com I 6th Edition S67"
3031,483,"Solutions to Chapter 17 I Hard 
13 new PriorityQueue<Integer>(k, new MaxHeapComparator()); 
14 for (int a: array) { 
15 if (heap.size() < k) {//If space remaining 
16 heap.add(a); 
17 } else if (a < heap.peek()) {//If full and top is small 
18 heap.poll();// remove highest 
19 heap.add(a); // insert"
3032,496,"27 int[] array= new int[heap.size()]; 
28 while (!heap.isEmpty()) { 
29 array[heap.size() - 1] = heap.poll(); 
30 } 
31 return array; 
32 } 
33 
34 class MaxHeapComparator implements Comparator<Integer> { 
35 public int compare(Integer x, Integer y) { 
36 return y - x; 
37 } 
38 } 
Java's uses the P"
3033,463,"different comparator. 
Approach 3: Selection Rank Algorithm (if elements are unique) 
Selection Rank is a well-known algorithm in computer science to find the ith smallest (or largest) element 
in an array in linear time. 
If the elements are unique, you can find the ith smallest element in expected"
3034,492,"track of the number of elements on the left side of the partition.
2. If there are exactly i elements on the left, then you just return the biggest element on the left.
3. If the left side is bigger than i, repeat the algorithm on just the left part of the array.
4. If the left side is smaller than "
3035,327,"left of this (since you've partitioned the array accordingly). You can now just return the first i elements. 
The code below implements this algorithm. 
1 int[] smallestK(int[] array, int k) { 
2 if (k <= 0 I I k > array.length) { 
3 throw new IllegalArgumentException(); 
4 } 
5 
568 Cracking the Co"
3036,503,"6 int threshold= rank(array, k - 1); 
7 int[] smallest = new int[k]; 
8 int count = 0; 
9 for (int a: array) { 
10 if (a<= threshold) { 
11 smallest[count] = a; 
12 count++; 
13 } 
14 } 
15 return smallest; 
16 } 
17 
18 /* Get element with rank. */ 
19 int rank(int[] array, int rank) { 
Solutions t"
3037,444,"24 int rank(int[] array, int left, int right, int rank) { 
25 int pivot = array[randomintinRange(left, right)]; 
26 int leftEnd = partition(array, left, right, pivot); 
27 int leftSize = leftEnd - left + 1; 
28 if (rank == leftSize - 1) { 
29 return max(array, left, leftEnd); 
30 } else if (rank< le"
3038,507,"34 } 
35 } 
36 
37 /* Partition array around pivot such that all elements <= pivot come before all 
38 *e lements > pivot. */
39 int partition(int[] array, int left, int right, int pivot) { 
40 while (left<= right) { 
41 if (array[left] > pivot) { 
42 /* Left is bigger than pivot. Swap it to the rig"
3039,360,"48 * it should be. */
49 swap(array, left, right); 
50 left++; 
51 } else { 
52 /* Left and right are in correct places. Expand both sides. */ 
53 left++; 
54 right- -; 
55 } 
56 } 
57 return left - 1; 
58 } 
59 
60 /* Get random integer within range, inclusive. */ 
61 int randomintinRange(int min, "
3040,510,"Solutions to Chapter 17 I Hard 
62 Random rand= new Random(); 
63 return rand.nextint(max + 1 - min) + min; 
64 } 
65 
66 /* Swap values at index i and j. */ 
67 void swap(int[] array, int i, int j) { 
68 int t = array[i]; 
69 array[i] = array[j]; 
70 array[j] = t; 
71 } 
72 
73 /* Get largest eleme"
3041,440,"77 max= Math.max(array[i], max); 
78 } 
79 return max; 
80 } 
If the elements are not unique, we can tweak this algorithm slightly to accommodate this. 
Approach 4: Selection Rank Algorithm (if elements are not unique) 
The major change that needs to be made is to the partition function. When we par"
3042,497,"pivot. 
This requires minor tweaks to rank as well. We now compare the size of left and middle partitions to rank. 
1 class PartitionResult { 
2 int leftSize, middleSize; 
3 public PartitionResult(int left, int middle) { 
4 this.leftSize = left; 
5 this.middleSize = middle; 
6 } 
7 } 
8 
9 int[] sma"
3043,387,"15 int threshold= rank(array, k - 1);
16 
17 /* Copy elements smaller than the threshold element. */ 
18 int[] smallest = new int[k]; 
19 int count= 0; 
20 for (int a: array) { 
21 if (a < threshold) { 
22 smallest[count] = a; 
23 count++; 
24 } 
25 } 
26 
27 /* If there's still room left, this must"
3044,508,"28 *element. Copy those in. */
29 while (count< k) { 
30 smallest[count] = threshold; 
31 count++; 
32 } 
33 
34 return smallest; 
35 } 
36 
37 /* Find value with rank ki n array. */ 
38 int rank(int[] array, int k) { 
39 if (k >= array.length) { 
40 throw new IllegalArgumentException(); 
41 } 
42 r"
3045,479,"46 int rank(int[] array, int k, int start, int end) { 
47 /* Partition array around an arbitrary pivot. */ 
48 int pivot = array[randomintinRange(start, end)]; 
49 PartitionResult partition = partition(array, start, end, pivot); 
50 int leftSize = partition.leftSize; 
51 int middleSize = partition.m"
3046,503,"return rank(array, k, start, start + leftSize - l); 
} else if (k < leftSize + middleSize) {//Rank k is in middle 
return pivot; // middle is all pivot values 
} else {//Rank k is on right 
return rank(array, k - leftSize - middleSize, start + leftSize + middleSize, 
end); 
} 
62 } 
63 
64 /* Partit"
3047,510,"66 int left = start; /* Stays at (right) edge of left side. */ 
67 int right = end; /* Stays at (left) edge of right side. */ 
68 int middle = start; /* Stays at (right) edge of middle. */ 
69 while (middle<= right) { 
70 if (array[middle] < pivot) { 
71 /* Middle is smaller than the pivot. Left is "
3048,354,"76 left++; 
77 } else if (array[middle] > pivot) { 
78 /* Middle is bigger than the pivot. Right could have any value. Swap them, 
79 * then we know that the new right is bigger than the pivot. Move right by
80 *one. */
81 swap(array, middle, right); 
82 right--; 
83 } else if (array[middle) == pivo"
3049,446,"Solutions to Chapter 17 I Hard 
84 /* Middle is equal to the pivot. Move by one. */ 
85 middle++; 
86 } 
87 } 
88 
89 /* Return sizes of left and middle. */ 
90 return new PartitionResul t(left - start, right - left + 1); 
91 } 
Notice the change made to smallestK too. We can't simply copy all eleme"
3050,477,"to threshold. (We also can't just say ""okay, only copy k elements over:' We could inadvertently fill up the 
array early on with ""equal"" elements, and not leave enough space for the smaller ones.) 
The solution for this is fairly simple: only copy over the smaller elements first, then fill up the ar"
3051,493,"in the list.' 
pg 188 
SOLUTI0!'.1 
This problem seems complex, so let's simplify it. What if we just wanted to know the longest word made of 
two other words in the list? 
We could solve this by iterating through the list, from the longest word to the shortest word. For each word, 
we would split i"
3052,473,"1 String getlonges tWord(String[] list) { 
2 String[] array= list.SortByLength(); 
3 /* Create map for easy lookup */ 
4 HashMa p<String, Boolean> map= new Hash Map<String, Boolean>; 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 } 
for (String str : array) { 
map.put(str, true);"
3053,336,"String right= s.s ubstring(i); 
// Check if both sides are in the array 
if (map[left] == true && map[right] == true) { 
return s; 
} 
} 
return str; 
This works great for when we just want to know composites of two words. But what if a word could be 
formed by any number of other words? 
572 Cracki"
3054,476,"Solutions to Chapter 17 I Hard
In this case, we could apply a very similar approach, with 
one modification: rather than simply looking up if 
the right side is in the array, we would recursively see if we can build the right side from the other elements 
in the array. 
The code below implements thi"
3055,501,"3 for (String str : arr) { 
4 map.put(str, true); 
5 } 
6 Arrays.sort(arr, new LengthComparator()); // Sort by length 
7 for (String s : arr) { 
8 if (canBuildWord(s, true, map)) { 
9 Syst em.out.println(s); 
10 return s; 
11 } 
12 
13 
14 } 
15 
} 
return """".,
16 boolean canBuildWord(String str, bo"
3056,505,"21 
22 
23 
24 
25 
for (int i= 1; i 
< str.length(); i++) { 
String left = str.substring(0, i); 
String right= str.substring(i); 
if (map.containsKey(left) && map.get(left) 
canBuildWord(right, false, map)) { 
26 return true; 
27 } 
28 } 
29 map.put(str, false); 
30 return false; 
31 } 
true && 
No"
3057,495,"any way to build ""testingtester;' we'II only have to compute it once. 
A boolean flag isOriginalWord is usedto complete theaboveopti mization. The method canBuildWord 
is called for the original word and for each substring, and its first step is to check the cache for a previously 
calculated result"
3058,123,"original word, we simply bypass this check using the isOriginalWord flag. 
CrackingTheCodinglnterview.com / 6th Edition S73"
3059,511,"Solutions to Chapter 17 I Hard 
17.16 The Masseuse: A popular masseuse receives a sequence of back-to-back appointment requests 
and is debating which ones to accept. She needs a 15-minute break between appointments and 
therefore she cannot accept any adjacent requests. Given a sequence of back-to-"
3060,497,"EXAMPLE 
Input: {30, 15, 60, 75, 45, 15, 15, 45} 
Output180 minutes ({30, 60, 45, 45}). 
SOLUTION 
pg 188 
Let's start with an example. We'll draw it visually to get a better feel for the problem. Each number indicates 
the number of minutes in the appointment. 
! r0 = 751 r1 = 105 751 r4 = 90 
Alte"
3061,503,"The best set of appointments for this problem has 330 minutes total, formed with { r 0 = 75, r 2 = 120, 
r 5 = 135}. Note that we've intentionally chosen an example in which the best sequence of appointments 
was not formed through a strictly alternating sequence. 
We should also recognize that choo"
3062,481,"optimal set. 
Solution #1: Recursion 
The first thing that may come to mind is a recursive solution. We have essentially a sequence of choices as 
we walk down the list of appointments: Do we use this appointment or do we not? If we use appointment 
i, we must skip appointment i + 1 as we can't take"
3063,491,"2 return maxMinutes(massages, 0); 
3 } 
4 
5 int maxMinutes(int[] massages, int index) { 
6 if (index>= massages.length) {//Out of bounds 
7 return 0; 
8 } 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 } 
S74 
/* Best with this reservat ion. */ 
int bestWith = massages[index] + maxMinutes(massages, index+ "
3064,83,"return Math.max(bestWith, bestWithout); 
Cracking the Coding Interview, 6th Edition"
3065,512,"Solutions to Chapter 17 I Hard 
The runtime of this solution is O ( 2"") because at each element we're making two choices and we do this n 
times (where n is the number of massages). 
The space complexity is 0( n) due to the recursive call stack. 
We can also depict this through a recursive call tree"
3066,479,"0) callsmaxMinutes(massagesJ 1) andmaxMinutes(massages) 2).
As with many recursive problems, we should evaluate if there's a possibility to memoize repeated subprob­
lems. Indeed, there is. 
Solution #2: Recursion + Memoization 
We will repeatedly call maxMinutes on the same inputs. For example, we'"
3067,487,"appointment 1. We should memoize this. 
Our memo table is just a mapping from index to the max minutes. Therefore, a simple array will suffice. 
1 int maxMinutes(int[] massages) { 
2 int[] memo= new int[massages.length]; 
3 return maxMinutes(massages, 0, memo); 
4 } 
5 
6 int maxMinutes(int[] massag"
3068,389,"13 int bestWithout = maxMinutes(massages, index+ 1, memo); 
14 memo[index] = Math.max(bestWith, bestWithout); 
15 } 
16 
17 return memo[index]; 
18 } 
To determine the runtime, we'll draw the same recursive call tree as before but gray-out the calls that will 
return immediately. The calls that will"
3069,411,"Solutions to Chapter 17 I Hard
If we drew a bigger tree, we'd see a similar pattern. The tree looks very linear, with one branch down to the 
left. This gives us an O ( n) runtime and 0( n) space. The space usage comes from the recursive call stack as 
well as from the memo table. 
Solution #3: Iter"
3070,445,"However, we might be able to beat the space complexity. This would mean not solving the problem recur­
sively. 
Let's look at our first example again. 
As we noted in the problem statement. we cannot take adjacent appointments. 
There's another observation, though, that we can make: We should never "
3071,443,"r 3• This would be suboptimal since we could always improve our set by grabbing that middle element. 
This means that if we taker 0, we know we'll definitely skip r 1 and definitely take either r2 or r 3' This substan­
tially limits the options we need to evaluate and opens the door to an iterative "
3072,500,"approach it iteratively. 
A useful way to do this is to approach it from the back and move toward the start of the array. At each point, 
we find the solution for the subarray. 
best ( 7): What's the best option for { r 7 
• best ( 6): What's the best option for { r 6
= 45}?We can get45 min. if we t"
3073,441,"» take best(6) = 45.
The first gives us 60 minutes, best ( 5) = 60. 
best( 4 ): What's the best option for {r4 = 45, ••• }? We can either: 
» taker 4 = 45 and merge it with best ( 6) = 45, or:
» takebest(S) = 60.
The first gives us 90 minutes, best ( 4) = 90. 
best (3): What's the best option for { "
3074,472,"Solutions to Chapter 17 I Hard 
» take best(4) = 90.
The first gives us 135 minutes, best ( 3) = 135. 
• best ( 2): What's the best option for { r 2 = 60, ... } ? We can either:
» taker 2 = 60 and merge it with best ( 4) = 90, or:
» take best ( 3) = 135.
Thefirst gives us150minutes,best(2) = 150. 
b"
3075,503,"» take best(2) 150. 
Either way, best(l) 150. 
best (0):What's the best option for {r0 = 30, ... }? We can either: 
» taker0 = 30 and merge it with best(2) = 150,or:
» take best(l) = 150.
The first gives us 180 minutes, best(0) 180. 
Therefore, we return 180 minutes. 
The code below implements this "
3076,505,"4 int[] memo = new int[massages.length + 2];
5 memo[massages.length] = 0;
6 memo[massages.length + 1] = 0;
7 for (int i= massages.length - 1; i >= 0; i--) {
8 int bestWith = massages[i] + memo[i + 2]; 
9 int bestWithout = memo[i + 1]; 
10 memo[i] = Math.max (bestWith, bestWithout); 
11 } 
12 return "
3077,499,"had the same time and space complexity. 
Solution #4: Iterative with Optimal Time and Space 
In reviewing the last solution, we can recogpize that we only use the values in the memo table for a short 
amount of time. Once we are several elements past an index, we never use that element's index again"
3078,248,"1 int maxMinutes(int[] massages) { 
2 int oneAway = 0; 
3 int twoAway = 0; 
4 for (int i= massages.length - 1; i >= 0; i--) { 
5 int bestWith = mas sages [i] + twoAway; 
6 int bestWithout = oneAway; 
CrackingTheCodinglnterview.com I 6th Edition 577"
3079,450,"Solutions to Chapter 17 I Hard 
7 int current = Math.max(bestWith, bestWithout); 
8 twoAway = oneAway; 
9 oneAway = current; 
10 } 
11 return oneAway; 
12 } 
This gives us the most optimal time and space possible: 0 ( n) time and O ( 1) space. 
Why did we look backward? It's a common technique in ma"
3080,509,"others. In this case, rather than asking ""What's the best set that starts with a [ i] ?'; we would ask ""What's the 
best set that ends with a [ i] ?"" 
17.17 Multi Search: Given a string band an array of smaller strings T, design a method to search b for 
each small string in T. 
SOLUTION 
Let's star"
3081,444,"Solution#1 
The naive solution is reasonably straightforward. Just search through the bigger string for each instance of 
the smaller string. 
1 HashMaplist<String, Integer> searchAll(String big, String[] smalls) { 
2 HashMapList<String, Integer> lookup= 
3 new HashMapList<String, Integer>(); 
4 for"
3082,466,"7 } 
8 return lookup; 
9 } 
10 
11 /* Find all locations of the smaller string within the bigger string. */ 
12 Arraylist<Integer> search(String big, String small) { 
13 Arraylist<Integer> locations = new Arraylist<Integer>(); 
14 for (int i= 0; i < big.length() - small.length() + 1; i++) { 
15 if ("
3083,281,"22 /* Check if small appears at index offset within big. */ 
23 boolean isSubstringAtLocation(String big, String small, int offset) { 
24 for (inti= 0; i < small.length(); i++) { 
2S if (big.charAt(offset + i) != small.charAt(i)) { 
S 7 8 Cracking the Coding Interview, 6th Edition"
3084,431,"Solutions to Chapter 17 I Hard 
26 
27 } 
28 } 
return false; 
29 return true; 
30 } 
31 
32 /* HashMaplist<String, Integer> is a HashMap that maps from Strings to 
33 * Arraylist<Integer>. See appendix for implementation. */ 
We could have also used a substring and equals function, instead of writi"
3085,500,"This will take 0( kbt) time, where k is the length of the longest string in T, b is the length of the bigger 
string, and t is the number of smaller strings within T. 
Solution #2 
To optimize this, we should think about how we can tackle all the elements in Ta t once, or somehow re-use 
work. 
One "
3086,469,"The tree for this is below. 
B I s 
I s B 
B s 
s 
Then, all you need to do is search in the suffix tree for each string in T. Note that if ""B"" were a word, you 
would come up with two locations. 
1 HashMaplist<String, Integer> searchAll(String big, String[] smalls) { 
2 HashMapList<String, Integer>"
3087,312,"5 /* Get terminating location of each occurrence.*/ 
6 Arraylist<Integer> locations = tree.search(s); 
7 
8 /* Adjust to starting location. */ 
9 subtrac tValue(locations, s.length()); 
10 
11 /* Insert. */ 
12 lookup .put(s, locations); 
13 } 
14 return lookup; 
CrackingTheCodinglnterview.com J 6th"
3088,492,"Solutions to Chapter 17 I Hard 
15 } 
16 
17 Trie createTrieFromString(String s) { 
18 Trie trie = new Trie(); 
19 for (int i= 0; i < s.length(); i++) { 
20 String suffix = s.substring(i); 
21 trie.insertString(suffix, i); 
22 } 
23 return trie; 
24 } 
25 
26 void subtractValue(ArrayList<Integer> lo"
3089,494,"30 } 
31 } 
32 
33 public class Trie { 
34 private TrieNode root new TrieNode(); 
35 
36 public Trie(String s) { insertString(s, 0); } 
37 public Trie() {} 
38 
39 public Arraylist<Integer> search(String s) { 
40 return root.search(s); 
41 } 
42 
43 public void insertString(String str, int location)"
3090,491,"53 private HashMap<Character, TrieNode> children; 
54 private Arraylist<Integer> indexes; 
55 private char value; 
56 
57 public TrieNode() { 
58 children = new HashMap<Character, TrieNode>(); 
59 indexes= new Arraylist<Integer>(); 
60 } 
61 
62 public void insertString(String s, int index) { 
63 in"
3091,118,"68 child= children.get(value); 
69 } else { 
70 child= new TrieNode(); 
580 Cracking the Coding Interview, 6th Edition"
3092,468,"71 children.put(value, child); 
72 } 
73 String remainder = s.substring(l); 
Solutions to Chapter 17 I Hard 
74 child.insertString(remainder, index + 1); 
75 } else { 
76 children.put('\0', null); // Terminating character 
77 } 
78 } 
79 
80 public Arraylist<Integer> search(String s) { 
81 if (s == "
3093,432,"86 String remainder = s.substring(l); 
87 return children.get(first).search(remainder); 
88 } 
89 } 
90 return null; 
91 } 
92 
93 public boolean terminates() { 
94 return children.containsKey('\0'); 
95 } 
96 
97 public TrieNode getChild(char c) { 
98 return children.get(c); 
99 } 
100} 
101 
102 /"
3094,432,"103 * Arraylist<Integer>. See appendix for implementation. */ 
It takes O ( b2 ) time to create the tree and O (kt) time to search for the locations. 
I 
Reminder: k is the length of the longest string in T, b is the length of the bigger string, and t is 
the number of smaller strings within T. 
The"
3095,463,"was the runtime of the prior solution, to O ( b2 + kt). If b is very large, then O ( bkt) is preferable. But if 
you have a lot of smaller strings, then 0( b2 + kt) might be better. 
Solution #3 
Alternatively, we can add all the smaller strings into a trie. For example, the strings { i, is, pp, ms}"
3096,497,"Solutions to Chapter 17 I Hard 
I p M 
s * p s 
* * * 
Now, when we want to find all words in miss is s ippi, we search through this trie starting with each word. 
m: We would first look up in the trie starting with m, the first letter in mississippi. As soon as we go 
to mi, we terminate. 
i: Then,"
3097,449,"that to the list. This node has no more children, so we move onto the next character in mississippi. 
s: We now go to s. There is no upper-level node for s, so we go onto the next character. 
s: Another s. Go on to the next character. 
i: We see another i. We go to the i node in the trie. We see tha"
3098,504,"list. This node has no more children, so we move onto the next character in mississippi. 
s: We go to s. There is no upper-level node for s. 
s: Another s. Go on to the next character. 
i: We go to the i node. We see that i is a complete word, so we add it to the trie. The next character in 
mississ"
3099,490,"characters left in mississippi, so we are done. 
Each time we find a complete ""small"" word, we add it to a list along with the location in the bigger word 
(mississippi) where we found the small word. 
The code below implements this algorithm. 
1 HashMaplist<String, Integer> searchAll(String big, St"
3100,221,"6 for (inti= 0; i < big.length(); i++) { 
7 Arraylist<String> strings = findStringsAtloc(root, big, i); 
8 insertintoHashMap(strings, lookup, i); 
9 } 
10 
11 return lookup; 
582 Cracking the Coding Interview, 6th Edition"
3101,495,"12 } 
13 
Solutions to Chapter l 7 \ Hard 
14 /* Insert each string into trie (provided string is not longer than maxLen). */
15 Trie createTreeFromStrings(String[] smalls, int maxLen) {
16 Trie tree = new Trie(""""); 
17 for (String s : smalls) { 
18 if (s.length() <= maxlen) { 
19 tree.insertString("
3102,488,"27 Arraylist<String> strings= new Arraylist<String>(); 
28 int index= start; 
29 while (index < big.length()) { 
30 root= root.getChild(big.charAt(index)); 
31 if (root== null) break; 
32 if (root.terminates()) { II Is complete string, add to list 
33 strings.add(big.substring(start, index+ 1)); 
34"
3103,435,"41 * Arraylist<Integer>. See appendix for implementation. *I
This algorithm takes 0( kt) time to create the trie and 0( bk) time to search for all the strings. 
I 
Reminder: k is the length of the longest string in T, b is the length of the bigger string, and t is 
the number of smaller strings with"
3104,249,"Solution #2 was O ( b2 + kt). Since b will always be bigger than k (or if it's not, then we know this really 
long string k cannot be found in b), we know Solution #3 is also faster than Solution #2. 
CrackingTheCodinglnterview.com I 6th Edition 583"
3105,428,"Solutions to Chapter 17 I Hard 
17 .18 Shortest Supersequence: You are given two arrays, one shorter (with all distinct elements) and one 
longer. Find the shortest subarray in the longer array that contains all the elements in the shorter 
array. The items can appear in any order. 
EXAMPLE 
Input: "
3106,507,"SOLUTIONS 
pg189 
As usual, a brute force approach is a good way to start. Try thinking about it as if you were doing it by hand. 
How would you do it? 
Let's use the example from the problem to walk through this. We'll call the smaller array smallArray and 
the bigger array bigArray. 
Brute Force 
"
3107,496,"largest of these next occurrences will tell us the shortest subarray that starts at that index. (We'll call this 
concept""clos ure:'That is, the closure is the element that ""closes"" a complete subarray starting at that index. 
For example, the closure of index 3-which has value 0-in the example is i"
3108,493,"2 int bestStart = -1; 
3 int bestEnd = -1; 
4 for (int i= 0; i < bigArray.length; i++) { 
5 int end= findClosure(bigArray, smallArray, i); 
6 if (end== -1) break; 
7 if (bestStart == -1 I I end - i < bestEnd - bestS tart) { 
8 bestStart = i; 
9 bestEnd = end; 
10 } 
11 } 
12 return new Range(bestSta"
3109,375,"17 * next locations of each element in smallArray. */
18 int findClosure(int[] bigArray, int[] smallArray, int index) { 
19 int max= -1; 
20 for (int i= 0; i < smallArray.length; i++) { 
21 int next= findNextinstance(bigArray, smallArray[i], index); 
22 if (next== -1) { 
23 return -1; 
24 } 
25 max="
3110,500,"27 return max; 
28 )-
29 
Solutions to Chapter 17 I Hard 
30 /* Find next instance of element starting from index. */ 
31 int findNextinstance(int[] array, int element, int index) { 
32 for (inti= index; i < array.length; i++) { 
33 if (array[i] == element) { 
34 
35 } 
36 } 
return i;
37 return -1;"
3111,454,"46 } 
47 
48 public int length() { return end - start + 1;} 
49 public int getStart() { return start;} 
50 public int getEnd() { return end; } 
51 
52 public boolean shorterThan(Range other) { 
53 return length() < other.length(); 
54 } 
55 } 
This algorithm will potentially take O(S82) time, where "
3112,453,"rest of the string, which has potentially B characters. 
Optimized 
Let's think about how we can optimize this. The core reason why it's slow is the repeated searches. Is there a 
faster way that we can find, given an index, the next occurrence of a particular character? 
Let's think about it with a"
3113,460,"7, s, 9, 0, 2, 1, 3, s, 7, 9, 1, 1, s, 8, 8, 9, 7 
Yes. Because we're going to have to do this repeatedly, we can precompute this information in just a single 
(backwards) sweep. Iterate through the array backwards, tracking the last (most recent) occurrence of 5. 
value 
index 
next 5 
Doing this f"
3114,340,"it's not really. Doing it in one backwards sweep means doing three comparisons at each iteration. N moves 
through the list with three comparisons at each move is no better than 3N moves and one comparison at 
each move. You might as well keep the code clean by doing it in separate sweeps. 
Cracking"
3115,410,"Solutions to Chapter 17 I Hard 
1iCvalue 7 5 9 0 .... l:2 r llti 3 5 7 9 1%. 1'1':i:!i; H>s· 8 8 ,9 7. 
index 0 l 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 
next 1 5 5 5 5 5 5 10 10 10 10 10 11 X X X X X 
next 5 1 1 7 7 7 7 7 7 12 12 12 12 12 X X X X 
next 9 2 2 2 9 9 9 9 9 9 9 15 15 15 15 15 15 X 
The f"
3116,495,"doing a search. 
But, actually, we can make it a bit simpler. Using the table above, we can quickly compute the closure of 
each index. It's just the max of the column. If a column has an x in it, then there is no closure, at this indicates 
that there's no next occurrence of that character. 
The di"
3117,483,"index 0 1 2 3 4 5 6 7 8 9 10 
next 1 5 5 5 5 5 5 10 10 10 10 10 
next 5 1 1 7 7 7 7 7 7 12 12 12 
next 9 2 2 2 9 9 9 9 9 9 9 15 
closure 5 5 7 9 9 9 10 10 12 12 15 
diff. 5 4 5 6 5 4 4 3 4 3 5 
Now, all we have to do is to find the minimum distance in this table. 
1 Range shortestSupersequence(int[]"
3118,480,"3 int[] closures= getClosures( nextElements); 
4 return getShortestClosure( closures); 
5 } 
6 
7 /* Create tab le of next occurrences. */ 
8 int[][] getNextElementsMulti(int[] big, int[] small) { 
9 int[ ][] nextElements = new int[ small.length][big.length]; 
10 for (inti= 0; i < small.length; i++)"
3119,469,"13 14 15 16 
X X X X 
X X X X 
15 15 15 X 
X X X X 
X X X X 
16 /* Do ba ckwards sweep to get a list of the next occurrence of value from each 
17 * index. */
18 int[] getNextElement(int[] bigArray, int value) { 
19 int next= -1; 
20 int[] nexts = new int[bigArray.length]; 
21 for (inti= bigArray.le"
3120,94,"28 } 
29 
30 /* Get closure for each index. */ 
586 Cracking the Coding Interview, 6th Edition"
3121,502,"Solutions to Chapter 17 I Hard
31 int[] getClosures(int[][] nextElements) { 
32 int[] maxNextElement = new int[nextElements[0].length]; 
33 for (inti= 0; i < nextElements[0].length; i++) {
34 maxNextElement[i] = getClosureForindex(nextElements, i);
35 )-
36 return maxNextElement; 
37 } 
38 
39 /* Gi"
3122,459,"42 int max= -1; 
43 for (int i= 0; i < nextElements.length; i++) { 
44 if (nextElements[i][index] == -1) { 
45 return -1; 
46 } 
47 max= Math.max(max, nextElements[i][index]); 
48 } 
49 return max; 
50 } 
51 
52 /* Get shortest closure. */ 
53 Range getShortestClosure(int[] closures) { 
54 int bestS"
3123,495,"58 break; 
59 } 
60 int current= closures[i] - i; 
61 if (bestStart == -1 I I current< bestEnd - bestStart) { 
62 bestStart = i; 
63 bestEnd = closures[i]; 
64 } 
65 } 
66 return new Range(bestStart, bestEnd); 
67 } 
This algorithm will potentially take O(SB) time, where Bis the length of bigString "
3124,463,"It uses O(SB) space. 
More Optimized 
While our solution is fairly optimal, we can reduce the space usage. Remember the table we created: 
value}. :11 5 ,I 0> 2 1 ,3'"" 
index 0 1 2 3 4 5 6 
next 1 5 5 5 5 5 5 10 
next 5 1 1 7 7 7 7 7 
next 9 2 2 2 9 9 9 9 
closure 5 5 7 9 9 9 10 
, ... 5 7 9 :;,::::"
3125,101,"9 9 9 15 15 15 15 15 15 X 
10 12 12 15 15 X X X X X 
CrackingTheCodinglnterview.com \ 6th Edition 587"
3126,495,"Solutions to Chapter 17 I Hard 
In actuality, all we need is the closure row, which is the minimum of all the other rows. We don't need to 
store all the other next occurrence information the entire time. 
Instead, as we do each sweep, we just update the closure row with the minimums. The rest of th"
3127,499,"3 return getShortestClosure( closures); 
4 } 
5 
6 /* Get closure for each index. */ 
7 int[] getClosures(int[] big, int[ ] small) { 
8 int[ ] closure = new int[big.length]; 
9 for (inti= 0; i < small.length; i++) { 
10 sweepForClosure(big, closure, small[i]); 
11 } 
12 return closure; 
13 } 
14 
15"
3128,497,"18 int next= -1; 
19 for (inti= big.length - 1; i >= 0; i-- ) { 
20 if (big[i] == value) { 
21 
22 } 
next = i; 
23 if (( next== -1 I I closures[i] < next) && 
24 (c losures[i] != -1)) { 
25 closures[i] = next; 
26 } 
27 } 
28 } 
29 
30 /* Get shortest closure. */ 
31 Range getShortestClosure(int[ ]"
3129,453,"35 br eak; 
36 } 
37 Range range= new Range(i, closures[i]); 
38 if (!shortest.shorterThan( range)) { 
39 shortest = range; 
40 } 
41 } 
42 return shortest; 
43 } 
This still runs in O(SB) time, but it now only takes O(B) additional memory. 
Alternative & More Optimal Solution 
There's a totally dif"
3130,451,"Solutions to Chapter 17 I Hard 
value 7 5 9 2 1 3 5 7 
index 0 1 2 3 4 5 6 7 16 
1 -> {5, 10, 11} 
5 -> {1, 7, 12} 
9 -> {2, 3, 9, 15} 
What is the very first valid subsequence (which contains 1, 5, and 9)? We can just look at the heads of each 
list to tell us this. The minimum of the heads is the "
3131,472,"How can we find the next one? Well, the next one will not include index 1, so let's remove that from the list. 
1 -> {5, 10, 11} 
5 -> {7, 12} 
9 -> {2, 3, 9, 15} 
The next subsequence is [2, 7]. This is worse than the earlier best, so we can toss it. 
Now, what's the next subsequence? We can remove"
3132,466,"We can continue down this path each time, repeating this process. We will end up iterating through all 
""minimal"" subsequences that start from a given point. 
1. Current subsequence is [min of heads, max of heads]. Compare to best subsequence and update if
necessary.
2. Remove the minimum head.
3. R"
3133,506,"ison to the S other list heads to find the minimum. 
This is pretty good, but let's see if we can make that minimum computation faster. 
What we're doing in these repeated minimum calls is taking a bunch of elements, finding and removing the 
minimum, adding in one more element, and then finding the"
3134,500,"To get the list that the minimum element came from, we'll need to use a HeapNode class that stores both 
the locat ionWithinlist (the index) and the list Id. This way, when we remove the minimum, we can 
jump back to the correct list and add its new head to the heap. 
1 Range shortestSupersequence(i"
3135,414,"4 return getShortestClosure(locations); 
5 } 
6 
7 !* Get list of queues (linked lists) storing the indices at which each element in 
8 * smallArray appears in bigArray. */ 
9 Arraylist<Queue<Integer>> getlocationsForElements(int[] big, int[] small) { 
10 /* Initialize hash map from item value to lo"
3136,500,"Solutions to Chapter 17 I Hard 
12 new HashMap<Integer, Queue<Integer>>(); 
13 for (int s : small) { 
14 Queue<Integer> queue = new Linkedlist<Integer>(); 
15 itemlocations.put(s, queue); 
15 } 
17 
18 /* Walk through big array, adding the item locations to hash map*/ 
19 for (int i= 0; i < big.leng"
3137,506,"27 allLocations.addAll(itemLocations.values()); 
28 return alllocations; 
29 } 
30 
31 Range getShortestClosure(ArrayList<Queue<Integer>> lists) { 
32 PriorityQueue<HeapNode> minHeap = new PriorityQueue<HeapNode>(); 
33 int max= Integer.MIN_VALUE; 
34 
35 /* Insert min element from each list. */ 
36"
3138,499,"40 } 
41 
42 int min= minHeap.peek().locationWithinList; 
43 int bestRangeMin min; 
44 int bestRangeMax = max; 
45 
46 while (true) { 
47 /* Remove min node. */ 
48 HeapNode n = minHeap.poll(); 
49 Queue<Integer> list= lists.get(n.listid); 
50 
51 /* Compare range to best range. */ 
52 min= n.locati"
3139,261,"59 * can break. */
60 if (list.size() 0) {
61 break; 
62 } 
63 
64 
65 
66 
67 
S90 
/* Add new head of list to heap. */ 
n.locationWithinlist = list.remove();
minHeap.add(n);
max = Math.max(max, n.locationWithinList);
Cracking the Coding Interview, 6th Edition"
3140,427,"Solutions to Chapter 17 l Hard 
68 } 
69 
70 return new Range(bestRangeMin, bestRangeMax); 
71 } 
We're going through B elements in getShortestClosure, and each time pass in the for loop will take 
O( log S) time (the time to insert/remove from the heap). This algorithm will therefore take 0( B log "
3141,483,"except for one number that is missing. How can you find the missing number in O(N) time and 
0( 1) space? What if there were two numbers missing? 
pg189 
SOLUTIONS 
Let's start with the first part: find a missing number in O(N) time and 0( 1) space. 
Part 1: Find One Missing Number 
We have a very c"
3142,509,"This suggests that we need to do some sort of computation with the values. What characteristics does this 
computation need to have? 
Unique. If this computation gives the same result on two arrays (which fit the description in the 
problem), then those arrays must be equivalent (same missing number"
3143,422,"• Constant Time: The calculation can be slow, but it must be constant time per element in the array.
Constant Space: The calculation can require additional memory, but it must be O ( 1) memory.
The ""unique"" requirement is the most interesting-and the most challenging. What calculations can be 
perfo"
3144,482,"There are actually a number of possibilities. 
We could do something with prime numbers. For example, for each value x in the array, we multiply 
result by the xth prime. We would then get some value that is indeed unique (since two different sets of 
primes can't have the same product). 
Is this re"
3145,469,"Is it constant time and space, though? Only if we had a way of getting the ith prime number in 0(1) time 
and O ( 1) space. We don't have that. 
What other calculations could we do? We don't even need to do all this prime number stuff. Why not just 
multiply all the numbers together? 
Unique?Yes. Pi"
3146,80,"Constant time and space? Yes. 
CrackingTheCodinglnterv'iew.com I 6th Edition 591"
3147,451,"Solutions to Chapter 17 I Hard 
Reversible? Let's think about this. If we compare what our product is to what it would have been 
without a number removed, can we find the missing number? Sure. We just divide full_product by 
actual_product. This will tell us which number was missing from actual_pro"
3148,474,"2,000,000,000,000,000,000. 
We can still approach it this way, but we'll need to use the Biglnteger class. 
1 int missingOne(int[] array) { 
2 Biginteger fullProduct = productToN(array.l ength + 1); 
3 
4 Biginteger actualProduct = new Biginteger(""l""); 
5 for (int i= 0; i < array.length; i++) { 
6 B"
3149,483,"11 return Integer.parseint(missingNumber.toString()); 
12 } 
13 
14 Biginteger productToN(int n) { 
15 Biginteger fullProduct = new Biginteger(""l""); 
16 for (int i= 2; i <= n; i++) { 
17 fullProduct = fullProduct.multiply(new Biginteger(i + """")); 
18 } 
19 return fullProduct; 
20 } 
There's no need "
3150,479,"n(n+l} 
numbers between 1 and n. This is -2-. 
I 
Most candidates probably won't remember the expression for the sum of numbers between 1 
and n, and that's okay. Your interviewer might, however, ask you to derive it. Here's how to think 
about that: you can pair up the low and high values in the se"
3151,483,"1 
pairs. But what if n is even, such that "";
1 
is not an integer? In this case, pair
n/ n(n+l} 
up low and high values to get /2 pairs with sum n+l. Either way, the math works out to -2-. 
Switching to a sum will delay the overflow issue substantially, but it won't wholly prevent it. You should 
d"
3152,449,"Part 2: Find Two Missing Numbers 
This is substantially more difficult. Let's start with what our earlier approaches will tell us when we have two 
missing numbers. 
• Sum: Using this approach will give us the sum of the two values that are missing.
Product: Using this approach will give us the prod"
3153,125,"(2, 8), and a handful of other pairs. The same could be said for the product. 
592 Cracking the Coding Interview, 6th Edition"
3154,491,"Solutions to Chapter 17 I Hard 
We're again at the same point we were in the first part of the problem. We need a calculation that can be 
applied such that the result is unique across all potential pairs of missing numbers. 
Perhaps there is such a calculation (the prime one would work, but it's no"
3155,459,"result leaves us with a number of possibilities. But using both of them narrows it down to the specific 
numbers. 
X + y
X * y
sum -> y = sum - x 
product-> x(sum x) = product 
x*sum - x2 = product 
x*sum - x2 - product= 0
-x2 + x*sum - product = 0
At this point, we can apply the quadratic formula t"
3156,490,"(other than ""linear"" calculations) will give us values for x and y. 
For th is part, let's use a different calculation. Instead of using the product of 1 * 2 * . . . * n, we can use
the sum of the squares: 12 + 2 2 + . . . + n 2• This will make the Biginteger usage a little less critical,
as the cod"
3157,500,"-> y = S - X 
-> x2 + (s-x)2 = t 
2x2 - 2sx + s 2 -t 0
Recall the quadratic formula: 
x = [-b +- sqrt(b2 - 4ac)] / 2a
where, in this case: 
a 2 
b = -25 
C = 52-t 
Implementing this is now somewhat straightforward. 
1 int[] missingTwo(int[] array) { 
2 int max_value = array.length+ 2; 
3 int rem_squ"
3158,294,"8 rem_one -= array[i]; 
9 } 
10 
11 return solveEquation(rem_one, rem_square); 
12 } 
13 
14 int squareSumToN(int n, int power) { 
15 int sum = 0; 
16 for (inti= 1; i <= n; i++) { 
17 sum += (int) Math.pow(i, power); 
18 } 
19 return sum; 
20 } 
CrackingTheCodinglnterview.com \ 6th Edition 593"
3159,491,"Solutions to Chapter 17 I Hard
21 
22 int[] solveEquation(int rl, int r2) { 
23 /* axA2 +b x+ c 
24 * -->
25 * x = [-b +- sqrt(bA2 - 4ac)] / 2a
26 * In this case, it has to be a+ not a - */
27 
28 
29 
30 
int a 
int b 
int C 
2;
-2 * rl;
rl * rl - r2;
31 double partl = -1 * b; 
32 double part2 = Ma"
3160,492,"37 
38 int[] solution = {solutionX, solutionY}; 
39 return solution; 
40 } 
You might notice that the quadratic formula usually gives us two answers (see the+ or - part), yet in our 
code, we only use the ( +) result. We never checked the ( -) answer. Why is that? 
The existence of the ""alternate"" s"
3161,493,"= 0. 
That's true. There are. What's the other one? The other value is y! 
If this doesn't immediately make sense to you, remember that x and y are interchangeable. Had we solved 
for y earlier instead of x, we would have wound up with an identical equation: 2y2 - 2sy + (s2 -t) =
0. So of course y c"
3162,501,"s2 -t = 0, then the other something that fulfills that equation must be y.
Still not convinced? Okay, we can do some math. Let's say we took the alternate value forx: [ -b - sqrt(b2 
- 4ac)] / 2a. What's y?
X + y = r 1 
y r1 - X 
r1 - [-b - sqrt(b2 - 4ac)J/2a
[2a*r1 + b + sqrt(b2 - 4ac)J/2a
Partiall"
3163,365,"Recall that b = -2r 1. Now, we wind up with this equation: 
= [-b + sqrt(b2 - 4ac)]/2a
Therefore,if we usex = (partl + part2) / part3,then we'll get (partl - part2) / part3 
for the value for y. 
We don't care which one we call x and which one we call y, so we can use either one. It'll work out the "
3164,498,"Solutions to Chapter 17 I Hard 
17.20 Continuous Median: Numbers are randomly generated and passed to a method. Write a program 
to find and maintain the median value as new values are generated. 
pg 789
SOLUTIONS 
One solution is to use two priority heaps: a max heap for the values below the median"
3165,471,"What do we mean by ""roughly in half;' though? ""Roughly"" means that, if we have an odd number of values, 
one heap will have an extra value. Observe that the following is true: 
If maxHeap. size() > minHeap. size(), maxHeap. top() will be the median. 
If maxHeap. size() == minHeap. size(), then the a"
3166,508,"The algorithm works as follows. When a new value arrives, it is placed in the maxHeap if the value is less 
than or equal to the median, otherwise it is placed into the min Heap. The heap sizes can be equal, or the 
maxHeap may have one extra element. This constraint can easily be restored by shifti"
3167,485,"1 Comparator<Integer> maxHeapComparator, minHeapComparator; 
2 PriorityQueue<Integer> maxHeap, minHeap; 
3 
4 void addNewNumber(int randomNumber) { 
5 /* Note: addNewNumber maintains a condition that 
6 * maxHeap.size() >= minHeap.size() */
7 if (maxHeap.size() == minHeap.size()) {
8 if ((minHeap.pe"
3168,463,"13 maxHeap.offer(randomNumber); 
14 } 
15 } else { 
16 if(randomNumber < maxHeap.peek()) { 
17 minHeap.offer(maxHeap.poll()); 
18 maxHeap.offer(randomNumber); 
19 } 
20 else { 
21 minHeap.offer(randomNumber); 
22 } 
23 } 
24 } 
25 
26 double getMedian() { 
27 
28 
29 
/* maxHeap is always at least a"
3169,441,"Solutions to Chapter 17 I Hard 
32 
33 
34 
if (maxHeap.size() == minHeap.size()) { 
return ((double)minHeap.peek()+(double)maxHeap.peek()) / 2; 
} else { 
35 /* If maxHeap and minHeap are of different sizes, then maxHeap must have one 
36 * extra element. Return maxHeap's top element.*/
37 return m"
3170,508,"volume of water it 
could hold if someone poured water across the top. You can assume that each 
histogram bar has width 1. 
EXAMPLE 
lnput{0, 0, 4, 0, 0, 6, 0, 0, 3, 0, 5, 0, 1, 0, 0, 0} 
(Black bars are the histogram. Gray is water.) 
0040060030501000 
Output:26 
SOLUTION 
This is a difficult prob"
3171,415,"areas are? 
Solution #1 
Let's look at the tallest bar, which has size 8. What role does that bar play? It plays an important role for 
being the highest, but it actually wouldn't matter if that bar instead had height 100. It wouldn't affect the 
volume. 
The tallest bar forms a barrier for water on"
3172,502,"by the next highest bar on the left and right. 
• Water on immediate left of tallest bar: The next tallest bar on the left has height 6. We can fill up the
area in between with water, but we have to deduct the height of each histogram between the tallest and
next tallest.This gives av olume on the i"
3173,485,"compute the volume: (5-0) + (5-2) + (5-0) 13. 
This just tells us part of the volume. 
Solutions to Chapter 17 I Hard 
0 0 4 0 0 6 0 0 3 0 8 0 2 0 5 2 0 3 0 0 
What about the rest? 
We have essentially two subgraphs, one on the left and one on the right. To find the volume there, we 
repeat a very s"
3174,464,"highest on the right subgraph is the left border (5).)
2. Find the second tallest in each subgraph. In the left subgraph, this is 4. In the right subgraph, this is 3.
3. Compute the volume between the tallest and the second tallest.
4. Recurse on the edge of the graph.
The code below implements this"
3175,469,"4 
5 int max findindexOfMax(histogram, start, end); 
6 int leftVolume = subgraphVolume(histogram, start, max, true); 
7 int rightVolume = subgraphVolume(histogram, max, end, false); 
8 
9 return leftVolume + rightVolume; 
10 } 
11 
12 /* Compute the volume of a subgraph of the histogram. One max is "
3176,510,"15 int subgraphVolume(int[] histogram, int start, int end, boolean isleft) { 
16 if (start>= end) return 0; 
17 int sum = 0; 
18 if (isleft) { 
19 int max = findindexOfMax(histogram, start, end - 1); 
20 sum += borderedVolume(histogram, max, end); 
21 sum+= subgraphVolume(histogram, start, max, isle"
3177,84,"26 } 
27 
28 return sum; 
29 } 
30 
CrackingTheCodinglnterview.com I 6th Edition 597"
3178,460,"Solutions to Chapter 17 I Hard 
31 /* Find tallest bar in histogram between start and end. */ 
32 int findindexOfMax(int[] histogram, int start, int end) { 
33 int indexOfMax = start; 
34 for (int i= start+ 1; i <= end; i++) { 
35 if (histogram[i] > histogram[indexOfMax]) { 
36 indexOfMax = i; 
37 }"
3179,487,"43 * second tallest is at end. */
44 int borderedVolume(int[] histogram, int start, int end) { 
45 if (start>= end) return 0; 
46 
47 int min= Math.min(histogram[start], histogram[end]); 
48 int sum = 0; 
49 for (int i= start+ 1; i < end; i++) { 
50 sum += min - histogram[i]; 
51 } 
52 return sum; 
"
3180,469,"Solution #2 (Optimized) 
To optimize the previous algorithm, let's think about the exact cause of the inefficiency of the prior algo­
rithm. The root cause is the perpetual calls to findindexOfMax. This suggests that it should be our focus 
for optimizing. 
One thing we should notice is that we don'"
3181,472,"there a quicker way we could know what the max height is from a given point to each edge? 
Yes. We could precompute this information in O(N) time. 
In two sweeps through the histogram (one moving right to left and the other moving left to right), we can 
create a table that tells us, from any index "
3182,188,"If\DEX LEFT MAX: 0 0 2 2 2 5 5 5 5 5 
INDEX RIG-ff l'IIAX: 5 5 5 5 5 5 7 7 9 9 
The rest of the algorithm precedes essentially the same way. 
598 Cracking the Coding Interview, 6th Edition"
3183,503,"Solutions to Chapter 17 I Hard 
We've chosen to use a HistogramData object to store this extra information, but we could also use a 
two-dimensional array. 
1 int computeHistogramVolume(int[] histogram) { 
2 int start = 0; 
3 int end= histogram.length - 1; 
4 
5 HistogramData[] data = createHistogra"
3184,489,"9 int rightVolume = subgraphVolume(data, max, end, false); 
10 
11 return leftVolume + rightVolume; 
12 } 
13 
14 HistogramData[] createHistogramData(int[] histo) { 
15 HistogramData[] histogram= new HistogramData[histo.length]; 
16 for (int i= 0; i < histo.length; i++) { 
17 histogram[i] = new Hist"
3185,470,"23 if (histo[maxlndex] < histo[i]) { 
24 maxlndex = i; 
25 } 
26 histogram[i].setLeftMaxindex(maxindex); 
27 } 
28 
29 /* Set right max index. */ 
30 maxlndex = histogram.length - 1; 
31 for (int i= histogram.length - 1; i >= 0; i-- ) { 
32 if (histo[maxindex] < histo[i]) { 
33 maxindex = i; 
34 } 
"
3186,479,"42 * or end (depending on isleft). Find second tallest, then compute volume between
43 * tallest and second tallest. Then compute volume of subgraph. */
44 int subgraphVolume(HistogramData[] histogram, int start, int end, 
45 boolean isleft) { 
46 if (start>= end) 
return 0; 
4/ int sum= 0; 
48 if ("
3187,165,"52 } else { 
53 int max= histogram[start + 1].getRightMaxindex(); 
54 sum += borderedVolume(histogram, start, max); 
CrackingTheCodinglnterview.com J 6th Edition 599"
3188,475,"Solutions to Chapter 17 I Hard
55 sum += subgraphVolume(histogram, max, end, isleft); 
56 } 
57 
58 return sum; 
59 } 
60 
61 /* Compute volume between start and end. Assumes that tallest bar is at start and 
62 * second tallest is at end. */
63 int borderedVolume(HistogramData[] data, int start, in"
3189,505,"67 int sum = 0; 
68 for (int i= start + 1; i < end; i++) { 
69 sum += min - data[i].getHeight(); 
70 } 
71 return sum; 
72 } 
73 
74 public class HistogramData { 
75 private int height; 
76 private int leftMaxlndex = -1; 
77 private int rightMaxindex = -1; 
78 
79 
80 
81 
82 
83 
84 
85 } 
public 
"
3190,493,"void setLeftMaxindex(int idx) { leftMaxlndex 
int getRightMaxlndex() { return rightMaxindex; 
void setRightMaxindex(int idx) { rightMaxindex 
idx; }; 
} 
= idx; }; 
This algorithm takes 0( N) time. Since we have to look at every bar, we cannot do better than this. 
Solution #3 (Optimized & Simplifie"
3191,441,"0 0 4 0 0 6 0 0 3 0 8 0 2 0 5 2 0 3 0 0 
As we've seen, the volume of water in a particular area is determined by the tallest bar to the left and to 
the right (specifically, by the shorter of the two tallest bars on the left and the tallest bar on the right). For 
example, water fills in the area b"
3192,194,"The total volume of water is the volume of water above each histogram bar. Can we efficiently compute 
how much water is above each histogram bar? 
600 Cracking the Coding Interview, 6th Edition"
3193,468,"\ 
k' 
Solutions to Chapter 17 I Hard 
Yes. In Solution #2, we were able to precompute the height of the tallest bar on the left and right of each 
index. The minimums of these will indicate the ""water level"" at a bar. The difference between the water level 
and the height of this bar will be the vo"
3194,457,"RIG-IT MAX: 8 8 8 8 8 8 8 8 8 8 8 5 5 5 5 3 3 3 0 0 
MIN: 0 0 4 4 4 6 6 6 6 6 8 5 5 5 5 3 3 3 0 0 
DELTA: 0 0 0 4 4 0 6 6 3 6 0 5 3 5 0 1 3 0 0 0 
Our algorithm now runs in a few simple steps: 
1. Sweep left to right, tracking the max height you've seen and setting left max.
2. Sweep right to left, "
3195,495,"4. Sweep across the histogram, computing the delta between each minimum and the bar. Sum these
deltas.
In the actual implementation, we don't need to keep so much data around. Steps 2, 3, and 4 can be merged 
into the same sweep. First, compute the left maxes in one sweep. Then sweep through in reve"
3196,472,"1 /* Go through each bar and compute the volume of water above it. 
2 * Volume of water at a bar =
3 * height - min(tallest bar on left, tallest bar on right)
4 * [where above equation is positive]
5 * Compute the left max in the first sweep, then sweep again to compute the right
6 * max, minimum of"
3197,478,"10 int leftMax = histo[0]; 
11 for (int i= 0; i < histo.length; i++) { 
12 leftMax = Math.max(leftMax, histo[i]); 
13 leftMaxes[i] = leftMax; 
14 } 
15 
16 int sum = 0; 
17 
18 /* Get right max */ 
19 int rightMax = histo[histo.length - 1]; 
20 for (int i= histo.length - 1; i >= 0; i--) { 
21 rightM"
3198,146,"25 * above this bar. Compute the volume and add to the sum. */
26 if (secondTallest > histo[i]) {
CrackingTheCodinglnterview.com I 6th Edition 601"
3199,476,"Solutions to Chapter 17 I Hard 
27 sum += secondTallest - histo[i]; 
28 } 
29 } 
30 
31 return sum; 
32 } 
Yes, this really is the entire code! It is still 0( N) time, but it's a lot simpler to read and write.
17.22 Word Transformer: Given two words of equal length that are in a dictionary, write a "
3200,493,"EXAMPLE 
Input: DAMP, LIKE 
Output: DAMP-> LAMP-> LIMP-> LIME-> LIKE 
pg 789
SOLUTION 
Let's start with a naive solution and then work our way to a more optimal solution. 
Brute Force 
One way of solving this problem is to just transform the words in every possible way (of course checking at 
each s"
3201,507,"• QOld, Q.Old, ••• , �old
b.Q.ld,b.!2_ld, ••• ,b�ld
boQd,boQ.d, ••• ,bo�d
• bol� bol.!2., ••• , bol�
We will terminate (not pursue this path) if the string is not a valid word or if we've already visited this word. 
This is essentially a depth-first search where there is an ""edge"" between two words "
3202,507,"1 Linkedlist<String> transform(String start, String stop, String[] words) { 
2 HashSet<String> diet= setupDictionary(words); 
3 HashSet<String> visited= new HashSet<String>(); 
4 return transform(visited, start, stop, diet); 
5 } 
5 
7 HashSet<String> setupDictionary(String[] words) { 
8 HashSet<Str"
3203,46,"602 Cracking the Coding Interview, 6th Edition"
3204,439,"Solutions to Chapter 17 I Hard
16 String stopWord, Set<String> dictionary) { 
17 if (startword.equals(stopWord)) { 
18 Linkedlist<String> path= new Linkedlist<String>(); 
19 path.add(startWord); 
20 return path; 
21 } else if (visited.contains(startWord) I 
I !dictionary.contains(startWord)) { 
22 r"
3205,508,"27 
28 for (String word: words) { 
29 Linkedlist<String> path= transform(visited, word, stopWord, dictionary);
30 if (path != null) { 
31 path.addFirst(startWord); 
32 return path; 
33 } 
34 } 
35 
36 return null; 
37 } 
38 
39 Arraylist<String> wordsOneAway(String word) { 
40 Arraylist<String> word"
3206,440,"44. words.add(w);
45 } 
46 } 
47 return 
words; 
48 } 
One major inefficiency in this algorithm is finding all strings that are one edit away. Right now, we're finding 
the strings that are one edit away and then eliminating the invalid ones. 
Ideally, we want to only go to the ones that are valid. "
3207,490,"words. 
What makes two words""related"" (one edit away)?They are one edit away if all but one character is the same. 
For example, ball and bill are one edit away, because they are both in the form b_ll. Therefore, one 
approach is to group all words that look like b_ll together. 
We can do this for t"
3208,172,"mapping might look like this: 
il ->
le ->-
11 -> 
_pe -> 
a e ->-
a 1 -> -
ail 
ale 
all, 
ape 
ape, 
all, 
ill 
ale 
ail 
CrackingTheCodinglnterview.com I 6th Edition 603"
3209,485,"Solutions to Chapter 17 I Hard 
i 1 -) ill 
ai -) ail -
al -> all, ale 
ap_ -) ape 
il -) ill -
Now, when we wantto know the words that are one edit away from a word like ale, we look up _le, a_e, 
and al in the hash table. 
The algorithm is otherwise essentially the same. 
1 Linkedlist<String> tran"
3210,497,"3 HashSet<String> visited= new HashSet<String>(); 
4 return transform(visited, start, stop, wildcardToWordList); 
5 } 
6 
7 /* Do a depth-first search from startWord to stopWord, traveling through each word 
8 * that is one edit away. */
9 Linkedlist<String> transform(HashSet<String> visited, String"
3211,509,"13 path.add(start); 
14 return path; 
15 } else if (visited.contains(start)) { 
16 return null; 
17 } 
18 
19 visited.add(start); 
20 Arraylist<String> words getValidLinkedWords(start, wildcardToWordlist); 
21 
22 for (String word: words) { 
23 Linkedlist<String> path= transform(visited, word, stop,"
3212,480,"34 HashMapList<String, String> createWildcardToWordMap(String[] words) { 
35 HashMapList<String, String> wildcardToWords = new HashMaplist<String, String>(); 
36 for (String word : words) { 
37 Arraylist<String> linked= getWildcardRoots(word); 
38 for (String linkedWord : linked) { 
39 wildcardToWor"
3213,152,"46 ArrayList<String> getWildcardRoots(String w) { 
47 ArrayList<String> words = new Arraylist<String>(); 
604 Cracking the Coding Interview, 6th Edition"
3214,502,"Solutions to Chapter 17 I Hard
48 for (inti= 0; i 
< w.length(); i++) { 
49 String word= w.substring(0, i) + ""_"" + w.substring(i + 1); 
50 words.add(word); 
51 } 
S2 return words; 
53 } 
54 
55 /* Return words that are one edit away. */ 
56 Arraylist<String> getValidLinkedWords(String word, 
57 Hash"
3215,443,"60 for (String wildcard : wildcards ) { 
61 ArrayList<String> words = wildcardToWords.get(wildcard); 
62 for (String linkedWord : words) { 
63 if (!linkedWord.equals(word)) { 
54 linkedWords.add(linkedWord); 
65 } 
66 } 
67 } 
68 return linkedWords; 
69 } 
70 
71 /* HashMaplist<String, String> is a "
3216,496,"This will work, but we can still make it faster. 
One optimization is to switch from depth-first search to breadth-first search. If there are zero paths or one 
path, the algorithms are equivalent 
speeds. However, if there are multiple paths, breadth-first search may 
run faster. 
Breadth-first sea"
3217,447,"in fact, the nodes were quite close. 
Optimal Solution 
As noted earlier, we can optimize this using breadth-first search. Is this as fast as we can make it? Not quite. 
Imagine that the path between two nodes has length 4. With breadth-first search, we will visit about 154 
nodes to find them. 
Bre"
3218,365,"breadth-first searches would collide after each had done about two levels each. 
Nodes travelled to from source: 152 
Nodes travelled to from destination: 152 
• Total nodes: 152 + 152 
This is much better than the traditional breadth-first search. 
We will need to track the path that we've travelle"
3219,479,"Solutions to Chapter 17 I Hard 
To implement this approach, we've used an additional class BFSData. BFSData helps us keep things a 
bit clearer, and allows us to keep a similar framework for the two simultaneous breadth-first searches. The 
alternative is to keep passing around a bunch of separate v"
3220,503,"3 
4 BFSData sourceData = new BFSData(startWord); 
5 BFSData destData = new BFSData(stopWord); 
6 
7 while (!sourceData.isFinished() && !destData.isFinished()) { 
8 /* Search out from source. */ 
9 String collision= searchLevel(wildcardToWordList, sourceData, destData); 
10 if (collision != null) { "
3221,488,"16 if (collision != null) { 
17 return mergePaths(sourceData, destData, collision); 
18 } 
19 } 
20 
21 return null; 
22 } 
23 
24 /* Search one level and return collision, if any. */ 
25 String searchLevel(HashMapList<String, String> wildcardToWordList, 
26 BFSData primary, BFSData secondary) { 
27"
3222,497,"29 * to add nodes to the end. */
30 int count= primary.toVisit.size();
31 for (int i= 0; i < count; i++) {
32 /* Pull out first node. */ 
33 PathNode pathNode = primary.toVisit.poll(); 
34 String word= pathNode.getWord(); 
35 
36 /* Check if it's already been visited. */ 
37 if (secondary.visited.co"
3223,274,"43 for (String w : words) { 
44 if (!primary.visited.containsKey(w)) { 
4S PathNode next= new PathNode(w, pathNode); 
46 primary.visited.put(w, next); 
47 primary.toVisit.add(next); 
48 } 
49 } 
50 } 
51 return null; 
52 } 
53 
606 Cracking the Coding Interview, 6th Edition"
3224,506,"Solutions to Chapter 17 I Hard 
54 Linkedlist<String> mergePaths(BFSData bfsl, BFSData bfs2, String connection) {
PathNode endl = bfsl.visited.get(connection); // endl -> source55 
56 
57 
58 
59 
PathNode end2 = bfs2.visited.get(connection); // end2 -> dest 
Linkedlist<String> pathOne = endl.collap"
3225,493,"61 return pathOne; 
62 } 
63 
64 /* Methods getWildcardRoots, getWildcardToWordlist, and getValidlinkedWords are
65 * the same as in the earlier solution. */
66 
67 public class BFSData { 
68 public Queue<PathNode> toVisit = new LinkedList<PathNode>();
69 public HashMap<String, PathNode> visited= ne"
3226,491,"74 ·visited.put(root, sourcePath);
75 } 
76 
77 public boolean isFinished() { 
78 return toVisit.isEmpty(); 
79 } 
80 } 
81 
82 public class PathNode { 
83 private String word= null; 
84 private PathNode previousNode = null; 
85 public PathNode(String word, PathNode previous) { 
86 this.word= word; "
3227,441,"101 
102 
/* Traverse path and return linked list of nodes. */ 
public Linkedlist<String> collapse(boolean startsWithRoot) { 
Linkedlist<String> path = new Linkedlist<String>(); 
PathNode node = this; 
while (node != null) { 
if (startsWithRoot) { 
path.addlast(node.word); 
} else { 
path.addFirst(n"
3228,496,"Solutions to Chapter 17 I Hard
110 /* HashMaplist<String, Integer> is a HashMap that maps from Strings to 
111 * Arraylist<Integer>. See appendix for implementation. */ 
This algorithm's runtime is a bit harder to describe since it depends on what the language looks like, as well 
as the actual sour"
3229,504,"work each breadth-first search does. 
Of course, this is a lot of code to implement in an interview. It just wouldn't be possible. More real­
istically, you'd leave out a lot of the details. You might write just the skeleton code of transform and 
search Level, but leave out the rest. 
17.23 Max Squ"
3230,455,"black pixels. 
pg 790
SOLUTION 
Like many problems, there's an easy way and a hard way to solve this. We'll go through both solutions. 
The ""Simple"" Solution: 0( N4 ) 
We know that the biggest possible square has a length of size N, and there is only one possible square of 
size NxN. We can easily c"
3231,447,"all squares of this size and return the first one we find. We then do the same for N-2, N-3, and so on. Since 
we are searching progressively smaller squares, we know that the first square we find is the biggest. 
Our code works as follows: 
1 Subsquare findSquare(int[][] matrix) { 
2 for (int i= ma"
3232,509,"5 } 
6 return null; 
7 } 
8 
9 Subsquare findSquareWithSize(int[][] matrix, int squareSize) { 
10 /* On an edge of length N, there are (N - sz + 1) squares of length sz. */ 
11 int count= matrix.length - squareSize + 1; 
12 
13 /* Iterate through all squares with side length squareSize. */ 
14 for ("
3233,158,"18 } 
19 } 
20 } 
21 return null; 
22 } 
23 
24 boolean issquare(int[][] matrix, int row, int col, int size) 1 
608 Cracking the Coding Interview, 6th Edition"
3234,492,"Solutions to Chapter 17 I Hard
25 // Check top and bottom border. 
26 for (int j 
= 0; j < size; j++){ 
27 if (matrix[row][col+j] == 1) { 
28 return false; 
29 } 
30 if (matrix[row+size-l][col+j] 1){ 
31 return false; 
32 } 
33 } 
34 
35 // Check left and right border. 
36 for (int i= 1; i < size - "
3235,444,"43 } 
44 return true; 
45 } 
Pre-Processing Solution: O ( N3 ) 
A large part of the slowness of the""simple""solution above is due to the fact we have to doO(N) work each 
time we want to check a potential square. By doing some pre-processing, we can cut down the time of 
isSquare to 0(1). The time of"
3236,492,"items, on the right of as well as below particular cells, are zeros. We can pre-compute this data in a straight­
forward, iterative fashion. 
We iterate from right to left, bottom to top. At each cell, we do the following computation: 
if A[r][c] is white, zeros right and zeros below are 0 
else A[r"
3237,468,"(0s right, 0s below) Original Matrix 
0,0 1,3 0,0 w B w 
2,2 1,2 0,0 B B w 
2,1 1,1 0,0 B B w 
Now, instead of iterating throughO(N) elements, the isSquare method just needs to check zeros Right 
and zeros Below for the corners. 
Our code for this algorithm is below. Note that findSquare and findSqu"
3238,107,"1 public class SquareCell { 
2 public int zerosRight = 0; 
CrackingTheCodinglnterview.com j 6th Edition 609"
3239,496,"Solutions to Chapter 17 I Hard 
3 public int zerosBelow = 0; 
4 /* declaration, getters, setters */ 
5 } 
6 
7 Subsquare findSquare(int[][] matrix) { 
8 SquareCell[][J processed= processSquare(matrix); 
9 for (int i= matrix.length; i >= 1; i--) { 
10 Subsquare square = findSquareWithSize(processed, "
3240,496,"17 /* equivalent to first algorithm */ 
18 } 
19 
20 boolean isSquare(SquareCell[][] matrix, int row, int col, int sz) { 
21 SquareCell topleft = matrix[row][col]; 
22 SquareCell topRight = matrix[row][col + sz - 1]; 
23 SquareCell bottomleft = matrix[row + sz - l][col]; 
24 
25 
26 
27 
28 
/* Chec"
3241,486,"return false; 
29 } 
return true; 30 
31 } 
32 
33 
34 
SquareCell[][] processSquare(int[][] matrix) { 
SquareCell[][] processed= 
35 new SquareCell[matrix.length][matrix.length]; 
36 
37 for (int r = matrix.length - 1; r >= 0; r--) { 
38 for (int c = matrix.length - 1; c >= 0; c--) { 
39 int rightZ"
3242,456,"44 belowZeros++; 
45 // next column over is on same row 
46 if (c + 1 < matrix.length) { 
47 SquareCell previous = processed[r][c + 1]; 
48 rightZeros += previous.zerosRight; 
49 } 
50 if (r + 1 < matrix.length) { 
51 SquareCell previous = processed[r + l][c]; 
52 belowzeros += previous.zerosBelow; "
3243,473,"Solutions to Chapter 17 I Hard 
59 } 
17.24 Max Submatrix: Given an NxN matrix of positive and negative integers, write code to find the 
submatrix with the largest possible sum. 
pg 190 
SOLUTION 
This problem can be approached in a variety of ways. We'll start with the brute force solution and the"
3244,499,"simply iterates through all possible submatrices, computes the sum, and finds the largest. 
To iterate through all possible submatrices (with no duplicates), we simply need to iterate through all 
ordered pairs of rows, and then all ordered pairs of columns. 
This solution is O(N6 ), since we iterat"
3245,486,"3 int columnCount = matrix[0].length; 
4 SubMatrix best = null; 
5 for (int rowl = 0; rowl < rowCount; rowl++) { 
6 for (int row2 = rowl; row2 < rowCount; row2++) { 
7 for (int coll = 0; coll< columnCount; coll++) { 
8 for (int col2 = coll; col2 < columnCount; col2++) { 
9 int sum = sum(matrix, rowl"
3246,509,"12 
13 
14 
15 
16 
17 
18 
19 
} 
}
}
} 
return 
} 
} 
best; 
20 int sum(int[][] matrix, int rowl, int coll, int row2, int col2) { 
21 int sum = 0; 
22 for (int r 
= rowl; r <= row2; r++) { 
23 for (int c = coll; c <= col2; c++) { 
24 sum += matrix[r][c]; 
25 } 
26 } 
27 return sum; 
28 } 
29 
30 p"
3247,497,"Solutions to Chapter 17 I Hard
35 row2 = 
r2; 
36 col2 = c2; 
37 sum = sm; 
38 } 
39 
40 public int get Sum() { 
41 return sum; 
42 } 
43 } 
It is good practice to pull the sum code into its own func.tion since it's a fairly distinct set of code.
Dynamic Programming Solution: 
0 ( N4 ) 
Notice that "
3248,507,"co mputeSum to 0(1). 
Consider the following rectangle: 
xl x2 
A C 
yl 
y2 
B 
Suppose we knew the following values: 
ValD area(point(0, 0) -> point(x2, 
Val( area(point(0, 0) -> point(x2, 
ValB area(point(0, 0) -> point(xl, 
ValA area(point(0, 0) -> point(xl, 
D 
y2)) 
yl)) 
y2)) 
yl)) 
Each Val* "
3249,494,"Or, written another way: 
area(D) = ValD - ValB - Vale + ValA 
We can efficiently compute these values for all points in the matrix by using similar logic: 
Val(x, y) = Val(x-1, y) + Val(y-1, x) - Val(x-1, y-1) + M [x][y] 
We can precompute all such values and then efficiently find the maximum subma"
3250,341,"4 int columnCount = matrix[0].length; 
5 int[][] sumThrough = precomputeSums(matrix); 
7 for (int rowl = 0; rowl < rowcount; rowl++) { 
8 for (int row2 = rowl; row2 < rowCount; row2++) { 
9 for (int coll = 0; coll< columnCount; coll++) { 
10 for (int col2 = coll; col2 < columnCount; col2++) { 
612 C"
3251,509,"11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
} 
} 
} 
} 
return 
} 
Solutions to Chapter 17 I Hard 
int sum = sum(sumThrough, rowl, coll, row2, col2); 
if (best== null I I best.getSum() < sum) { 
best = new SubMatrix(rowl, coll, row2, col2, sum); 
} 
best; 
22 int[][] precomputeSums(int[][] matrix) {"
3252,482,"26 int left= c > 0? sumThrough[r][c - 1] : 0; 
27 int top= r > 0? sumThrough[r - l][c] : 0; 
28 int overlap= r > 0 && c > 0? sumThrough[r-l][c-1] : 0; 
29 sumThrough[r][c] =left + top - overlap + matrix[r][c]; 
30 } 
31 } 
32 return sumThrough; 
33 } 
34 
35 int sum(int[][] sumThrough, int rl, int c"
3253,490,"38 int top= rl > 0? sumThrough[rl - l][c2] : 0; 
39 int full= sumThrough[r2][c2]; 
40 return full - left - top+ topAndLeft; 
41 } 
This algorithm takes 0( N4) time, since it goes through each pair of rows and each pair of columns. 
Optimized Solution: 0 ( N3 ) 
Believe it or not, an even more optima"
3254,466,"the largest sum:'We can find the maximum subarray in O(N) time. We will leverage this solution for this 
problem. 
Every submatrix can be represented by a contiguous sequence of rows and a contiguous sequence of 
columns. If we were to iterate through every contiguous sequence of rows, we would then"
3255,441,"2 foreach rowStart in rows 
3 foreach rowEnd in rows 
4 /* We have many possible submatrices with rowStart and rowEnd as the top and 
5 * bottom edges of the matrix. Find the colStart and colEnd edges that give
6 * the highest sum. */
7 maxSum = max(runningMaxSum, maxsum)
8 return maxSum 
Now the qu"
3256,478,"Solutions to Chapter 17 I Hard
9 -8
-3 7 
6 -4
12 -5
rowStart 
1 
6 
-4
3 
rowEnd 
3 -2
-2 4 
8 -7 
9 -5 
Given a rowStart and rowEnd, we want to find the colStart and colEnd that give us the highest 
possible sum. To do this, we can sum up each column and then apply the maximumSubArray function 
ex"
3257,510,"maximum submatrix is (rowStart, 
first column) through (rowEnd, fourth column). 
We now have pseudocode that looks like the following. 
1 maxSum = 0 
2 foreach rowStart in rows 
3 foreach rowEnd in rows 
4 foreach col in columns 
5 partialSum[col] = sum of matrix[rowStart, col] through matrix[rowEnd"
3258,489,"so this gives us a runtime of O ( R3C). We're not quite done yet. 
In lines 5 and 6, we're basically adding up a [ 0] ••. a [ i] from scratch, even though in the previous itera­
tion of the outer for loop, we already added up a [ 0] ••• a [ i-1]. Let's cut out this duplicated effort. 
1 maxSum = 0 
"
3259,473,"7 runningMaxSum = maxSubArray(partialSum) 
8 maxSum = max(runningMaxSum, maxSum) 
9 return maxSum 
Our full code looks like this: 
1 SubMatrix getMaxMatrix(int[][] matrix) { 
2 int rowCount = matrix.length; 
3 int colCount = matrix[0].length; 
4 SubMatrix best= null; 
5 
6 for (int rowStart = 0; row"
3260,122,"18 /* Add values at row rowEnd. */ 
11 for (int i= 0; i < colCount; i++) { 
614 Cracking the Coding Interview, 6th Edition"
3261,498,"Solutions to Chapter 17 I Hard 
partialSum[i] += matrix[rowEnd][i]; 
} 
12 
13 
14 
15 
16 
17 
18 
Range bestRange = maxSubArray(partialSum, colCount); 
if (best== null II best.getSum() < bestRange.sum) { 
best= new SubMatrix(rowStart, bestRange.start, rowEnd, 
bestRange.end, bestRange.sum); 
19 } "
3262,492,"29 
30 for (int i= 0; i < N; i+ +) { 
31 sum += array[i]; 
32 if (best== null I I sum > best.sum) { 
33 best= new Range(start, i, sum); 
34 } 
35 
36 /* If running_sum is < 0 no point in trying to continue the series. Reset. */ 
37 if (sum < 0) { 
38 start = i + 1; 
39 sum= 0; 
40 } 
41 } 
42 return"
3263,420,"49 this.end end; 
50 this.sum= sum;
51 } 
52 } 
This was an extremely complex problem. You would not be expected to figure out this entire problem in an 
interview without a lot of help from your interviewer. 
17 .25 Word Rectangle: Given a list of millions of words, design an algorithm to create th"
3264,350,"a word (reading top to bottom). The words need not be chosen consecutively from the list, but all 
rows must be the same length and all columns must be the same height. 
pg 190
SOLUTION 
Many problems involving a dictionary can be solved by doing some pre-processing. Where can we do pre­
processing?"
3265,463,"Solutions to Chapter 17 I Hard
Well, if we're going to create a rectangle of words, we know that each row must be the same length and 
each column must be the same length. So let's group the words of the dictionary based on their sizes. Let's 
call this grouping D, where D [ i] contains the list of "
3266,489,"formed? It's length ( largest word )2. 
1 int maxRectangle = longestWord * longestWord; 
2 for z = maxRectangle to 1 { 
3 for each pair of numbers (i, j) where i*j = z { 
4 /* attempt to make rectangle. return if succes sful. */ 
s } 
6 } 
By iterating from the biggest possible rectangle to the smal"
3267,416,"words which has length 1 and height h. 
One way to do this is to iterate through all (ordered) sets of h words and then check if the columns are also 
valid words. This will work, but it's rather inefficient. 
Imagine that we are trying to build a 6x5 rectangle and the first few rows are: 
there 
qu"
3268,452,"word starts with tqp. Why do we bother continuing to build a rectangle when we know we'll fail to create 
a valid one in the end? 
This leads us to a more optimal solution. We can build a trie to easily look up if a substring is a prefix of a 
word in the dictionary. Then, when we build our rectangl"
3269,431,"The code below implements this algorithm. It is long and complex, so we will go through it step by step. 
First, we do some pre-processing to group words by their lengths. We create an array of tries (one for each 
word length), but hold off on building the tries until we need them. 
1 WordGroup[] g"
3270,470,"3 Trie trielist[] = new Trie[maxWordlength]; 
The maxRectangle method is the ""main"" part of our code. It starts with the biggest possible rectangle 
area (which is maxWord Length2) and tries to build a rectangle of that size. If it fails, it subtracts one from 
the area and attempts this new, smalle"
3271,389,"2 int maxSize = maxWordLength * maxWordLength; 
3 for (int z = maxSize; z > 0; z--) {// start from biggest area 
4 for (int i= 1; i <= maxWordLength; i TT) { 
s if (z % i == 0) { 
6 int j = z / i; 
7 if (j <= maxWordLength) { 
8 /* Create rectangle of length i and height j. Note that i * j z. */
9 R"
3272,476,"Solutions to Chapter 17 I Hard 
10 if (rectangle != null) return rectangle; 
11 } 
12 } 
13 } 
14 } 
15 return null; 
16 }
The makeRectangle method is called by maxRectangle and tries to build a rectangle of a specific 
length and height. 
1 Rectangle makeRectangle(int length, int height) { 
2 if (g"
3273,450,"7 if (trielist[height - 1] == null) { 
null) { 
8 LinkedList<String> words = grouplist[height - 1].getWords(); 
9 trielist[height - 1] = new Trie(words); 
10 } 
11 
12 return makePartialRectangle(length, height, new Rectangle(length)); 
13 } 
The makePartialRectangle method is where the action happe"
3274,476,"just check to see if the columns form valid, complete words, and return. 
Otherwise, we check to see if the columns form valid prefixes. If they do not, then we immediately break 
since there is no way to build a valid rectangle off of this partial one. 
But, if everything is okay so far, and all th"
3275,432,"offof{current rectangle with new word appended}. 
1 Rectangle makePartialRectangle(int 1, int h, Rectangle rectangle) { 
2 if (rectangle.height== h) {// Check if complete rectangle 
3 if (rectangle.isComplete(l, h, grouplist[h - 1])) { 
4 return rectangle; 
5 } 
6 return null; 
7 } 
8 
9 /* Compare "
3276,487,"11 return null; 
12 } 
13 
14 /* Go through all words of the right length. Add each one to the current partial 
15 * rectangle, and attempt to build a rectangle recursively. */
16 for (int i= 0; i < grouplist[l-1].length(); i++) {
17 /* Create a new rectangle which is this rect + new word. */ 
18 Re"
3277,147,"21 Rectangle rect = makePartialRectangle(l, h, orgPlus); 
22 if (rect != null) { 
23 return rect; 
CrackingTheCodinglnterview.com I 6th Edition 617"
3278,474,"Solutions to Chapter 17 I Hard 
24 } 
25 } 
26 return null; 
27 } 
The Rectangle class represents a partially orfullyformed rectangle of words. The method isPartialOk 
can be called to check if the rectangle is, thus far, a valid one (that is, all the columns are prefixes of words). 
The method isCo"
3279,487,"2 public int height, length; 
3 public char[][] matrix; 
4 
5 /* Construct an ""empty"" rectangule. Length is fixed, but height varies as we add 
6 *words.*/ 
7 public Rectangle(int 1) {
8 height 0; 
9 length= l; 
10 } 
11 
12 /* Construct a rectangular array of letters of the specified length and hei"
3280,499,"15 *dimensions.)*/ 
16 public Rectangle(int length, int height, char[][] letters) {
17 this.height = letters.length; 
18 this.length = letters[0].length; 
19 matrix = letters; 
20 } 
21 
22 public char getletter (int i, int j) { return matrix[i][j]; } 
23 public String getColumn(int i) { ... } 
24 
"
3281,486,"28 if (height== h) { 
29 /* Check if each column is a word in the dictionary. */ 
30 
31 
32 
33 
34 
35 
for (int i= 0; i < l; i++) { 
String col= getColumn(i); 
if (!groupList.containsWord(col)) { 
return false; 
} 
} 
36 return true; 
37 } 
38 return false; 
39 } 
40 
41 public boolean isPartialO"
3282,79,"46 return false; 
47 
48 
618 
} 
} 
Cracking the Coding Interview, 6th Edition"
3283,480,"49 return true; 
50 } 
51 
Solutions to Chapter 17 I Hard
52 /* Create a new Rectangle by taking the rows of the current rectangle and 
53 * appending s. */
54 public Rectangle append(String s) { ... }
55 } 
The WordGroup class is a simple container for all words of a specific length. For easy looku"
3284,492,"1 public class WordGroup { 
2 private HashMap<String, Boolean> lookup= new HashMap<String, Boolean>(); 
3 private Arraylist<String> group= new Arraylist<String>(); 
4 public boolean containsWord(String s) { return lookup.containsKey(s); } 
5 public int length() { return group.size(); } 
6 public Str"
3285,506,"10 group.add(s); 
11 lookup.put(s, true); 
12 } 
13 
14 public static WordGroup[] createWordGroups(String[] list) { 
15 WordGroup[] grouplist; 
16 int maxWordlength = 0; 
17 /* Find the length of the longest word*/ 
18 for (int i= 0; i < list.length; i++) { 
19 if (list[i].length() > maxWordLength) "
3286,425,"26 grouplist = new WordGroup[maxWordlength];
27 for (int i= 0; i < list.length; i++) {
28 /*We do wordlength - 1 instead of just wordlength since this is used as 
29 * an index and no words are of length 0 */ 
30 int wordLength = list[i].length() - 1;
31 if (groupList[wordLength] == null) {
32 group"
3287,381,"35 } 
36 return grouplist; 
37 } 
38 } 
The full code for this problem, including the code for Trie and TrieNode, can be found in the code 
attachment. Note that in a problem as complex as this, you'd most likely only need to write the pseudocode. 
Writing the entire code would be nearly impossible "
3288,464,"Solutions to Chapter 17 I Hard 
17.26 Sparse Similarity: The similarity of two documents (each with distinct words) is defined to be the 
size of the intersection divided by the size of the union. For example, if the documents consist of 
integers, the similarity of {1, 5, 3} and { 1, 7, 2, 3} is 0."
3289,506,"similarity is believed to be ""sparse:'That is, any two arbitrarily selected documents are very likely to 
have similarity O. Design an algorithm that returns a list of pairs of document IDs and the associated 
similarity. 
Print only the pairs with similarity greater than 0. Empty documents should n"
3290,425,"16: {32, 1, 9, 3, 5} 
19: {15, 29, 2, 6, 8, 7} 
24: {7, 10} 
Output: 
SOLUTION 
ID1, ID2 
13, 19 
13, 16 
19, 24 
SIMILARITY 
0.1 
0.25 
0.14285714285714285 
pg 190 
This sounds like quite a tricky problem, so let's start off with a brute force algorithm. If nothing else, it will 
help wrap our head"
3291,499,"Brute Force 
A brute force algorithm is as simple as just comparing all arrays to all other arrays. At each comparison, we 
compute the size of the intersection and size of the union of the two arrays. 
Note that we only want to print this pair if the similarity is greater than 0. The union of two a"
3292,497,"How do we compute the size of the intersection and the union? 
The intersection means the number of elements in common. Therefore, we can just iterate through the first 
array (A) and check if each element is in the second array (B). If it is, increment an intersection variable. 
To compute the unio"
3293,357,"avoid double counting as the duplicate elements are only counted with B. 
Alternatively, we can think about it this way. If we did double count elements, it would mean that elements 
in the intersection (in both A and B) were counted twice. Therefore, the easy fix is to just remove these 
duplicate "
3294,462,"Solutions to Chapter 17 I Hard 
union(A, B) =A+ B - intersection(A, B) 
This means that all we really need to do is compute the intersection. We can derive the union, and therefore 
similarity, from that immediately. 
This gives us an O(AB) algorithm,just to compare two arrays (or documents). 
Howev"
3295,426,"then the runtime is O ( D2 w2 ). 
Slightly Better Brute Force 
As a quick win, we can optimize the computation for the similarity of two arrays. Specifically, we need to 
optimize the intersection computation. 
We need to know the number of elements in common between the two arrays. We can throw all"
3296,502,"an element in A. 
This takes O(A + B) time. If each array has size Wand we do this for D arrays, then this takes O(D2 W). 
Before implementing this, let's first think about the classes we'll need. 
We'll need to return a list of document pairs and their similarities. We'll use a DocPair class for th"
3297,502,"3 
4 public DocPair(int dl, int d2) { 
5 docl dl; 
6 doc2 = d2; 
7 } 
8 
9 
10 
11 
12 
13 
@Override 
public boolean equals(Object o) { 
if (o instanceof DocPair) { 
DocPair p = (DocPair) o; 
14 } 
return p.docl == docl && p.doc2 
15 return false; 
16 } 
17 
18 @Override 
doc2; 
19 public int hashC"
3298,297,"2 private Arraylist<Integer> words; 
3 private int docid; 
4 
5 public Document(int id, Arraylist<Integer> w) { 
6 docid = id; 
7 words = w; 
8 } 
9 
10 public Arraylist<Integer> getWords() { return words;} 
11 public int getid() { return docid; } 
CrackingTheCodinglnterview.com I 6th Edition 621"
3299,493,"Solutions to Chapter 17 I Hard
12 public int size() { return words == null ? 0: words.size(); } 
13 } 
Strictly speaking, we don't need any of this. However, readability is important, and it's a lot easier to read 
ArrayList<Document>than Arraylist<Arraylist<Integer>>. 
Doing this sort of thing not "
3300,495,"time or your interviewer asked you to.) 
1 HashMap<DocPair, Double> computeSimilarities(Arra yList<Document> documents) { 
2 HashMap<DocPair, Double> similarities = new HashMap<DocPair, Double>(); 
3 for (int i = 0; i < documents.size(); i++) { 
4 for (int j = i + 1; j < documents.size(); j++) { 
5 "
3301,488,"9 DocPair pair = new DocPair(docl.getid(), doc2.getld()); 
10 similarities.put(pair, sim); 
11 } 
12 } 
13 } 
14 return similarities; 
15 } 
16 
17 double computeSimilarity(Document docl, Document doc2) { 
18 int intersection = 0; 
19 Has hSet<Integer> setl = new HashSet<Integer>(); 
20 setl.addAll("
3302,430,"28 double union = docl.size() + doc2.size() - intersection; 
29 return intersection/ union; 
30 } 
Observe what's happening on line 28. Why did we make union a double , when it's obviously an integer? 
We did this to avoid an integer division bug. If we didn't do this, the division would ""round"" dow"
3303,502,"Slightly Better Brute Force (Alternate) 
If the documents were sorted, you could compute the intersection between two documents by walking 
through them in sorted order, much like you would when doing a sorted merge of two arrays. 
This would take O(A + B) time. This is the same time as our current "
3304,97,"time.Thefullruntimetheni sO(D * W log W + 0 2 W). 
622 Cracking the Coding Interview, 6th Edition"
3305,441,"Solutions to Chapter 17 1 Hard
We cannot necessarily assume that the second part ""dominates"" the first one, because it doesn't neces­
sarily. It depends on the relative size of D and log W. Therefore, we need to keep both terms in our runtime 
expression. 
Optimized (Somewhat) 
It is useful to creat"
3306,446,"16: {32, 1, 9, 3, 5} 
19: {15, 29, 2, 6, 8, 7} 
24: {7, 10, 3} 
At first, we might try various techniques that allow us to more quickly eliminate potential comparisons. 
For example, could we compute the min and max values in each array? If we did that, then we'd know that 
arrays with no overlap in"
3307,438,"change, we're still going to be comparing all O(D2) pairs, but theO(W) part might go to 0(1) sometimes.
ThatO(D2 ) part is going to be a really big problem when D gets large. 
Therefore, let's focus on reducing that O ( D2) factor. That is the ""bottleneck"" in our solution. Specifically, this
means t"
3308,474,"do this without ""talking""to each document. 
What would make a document similar to docA? That is, what characteristics define the documents with 
similarity > O? 
Suppose docA is {14, 15, 100, 9, 3 }. For a document to have similarity > 0, it needs to have a 14, a 15, 
a 100, a 9, or a 3. How can we "
3309,431,"ments that contain a 14, a 15, a 100, a 9, or a 3. That will take O ( DW) time. Not good. 
However, note that we're doing this repeatedly. We can reuse the work from one call to the next. 
If we build a hash table that maps from a word to all documents that contain that word, we can very quickly 
kn"
3310,419,"5 -> 16 
6 -> 19 
7 -> 19, 
8 -> 19 
9 -> 13, 
16, 24 
24 
16 
When we want to know all the documents that overlap with docA, we just look up each of docA's items in 
this hash table. We'll then get a list of all documents with some overlap. Now, all we have to do is compare 
docA to each of those d"
3311,173,"O(DW) time to create and read this hash table). Since we expect P to be much less than D2, this is much
better than before. 
Crackin9TheCodinglnterview.com \ 6th Edition 623"
3312,488,"Solutions to Chapter 17 I Hard
Optimized {Better) 
Let's think about our previous algorithm. Is there any way we can make it more optimal? 
If we consider the runtime-O(PW + DW)-we probably can't get rid of the O(DW) factor. We have to 
touch each word at least once, and there are O(DW) words. There"
3313,481,"takesO(P) time). The best place to focus, then, is on the W part. ls there some way we can do less than O(W) 
work for each pair of similar documents? 
One way to tackle this is to analyze what information the hash table gives us. Consider this list of docu-
ments: 
12: {1, 5, 9}
13: {5, 3, 1, 8}
14"
3314,420,"1 -> {12, 13, 15, 17} 
5 -> {12, 13, 15} 
9 -> {12, 15} 
This tells us that documents 13, 15, and 17 have some similarity. Under our current algorithm, we would 
now need to compare document 12 to documents 13, 15, and 17 to see the number of elements document 
12 has in common with each (that is, t"
3315,431,"document sizes and the intersection, as we did before. 
Observe, though, that document 13 appeared twice in the hash table, document 15 appeared three times, 
and document 17 appeared once. We discarded that information. But can we use it instead? What does it 
indicate that some documents appeared "
3316,462,"once because it has only one element (1) in common. Document 15 appeared three times because it has 
three elements (1, 5, and 9) in common. This information can actually directly give us the size of the inter­
section. 
We could go through each document, look up the items in the hash table, and the"
3317,486,"1. As before, build a hash table for a list of documents.
2. Create a new hash table that maps from a document pair to an integer (which will indicate the size of
the intersection).
3. Read the first hash table by iterating through each list of documents.
4. For each list of documents, iterate throu"
3318,459,"we were doing O(W) work for each similar pair. That's because once we noticed that two documents were 
similar, we touched every single word in each document. With this algorithm, we're only touching the words 
that actually overlap. The worst cases are still the same, but for many inputs this algor"
3319,492,"Solutions to Chapter 17 I Hard
3 HashMapList<Integer, Integer> wordToDocs = groupWords(documents); 
4 HashMap<DocPair, Double> similarities= computeintersections(wordToDocs); 
5 adjustToSimilarities(documents, similarities); 
6 return similarities; 
7 } 
8 
9 /* create hash table from each word to w"
3320,481,"12 
13 for (Document doc : documents.values()) { 
14 Arraylist<Integer> words = doc.getWords(); 
15 for (int word : words) { 
16 wordToDocs.put(word, doc.getid()); 
17 } 
18 } 
19 
20 return wordToDocs; 
21 } 
22 
23 /* Compute intersections of documents. Iterate through each list of documents and 
"
3321,477,"26 HashMapList<Integer, Integer> wordToDocs { 
27 HashMap<DocPair, Double> similarities= new HashMap<DocPair, Double>(); 
28 Set<Integer> words = wordToDocs.keySet(); 
29 for (int word : words) { 
30 Arraylist<Integer> docs= wordToDocs.get(word); 
31 Collections.sort(docs); 
32 for (int i= 0; i < do"
3322,470,"35 } 
36 } 
37 } 
38 
39 return similarities; 
40 } 
41 
42 /* Increment the intersection size of each document pair. */ 
43 void increment(HashMap<DocPair, Double> similarities, int docl, int doc2) { 
44 DocPair pair= new DocPair(docl, doc2); 
45 if (!similarities.containsKey(pair)) { 
46 similarit"
3323,353,"53 void adjustToSimilarities(HashMap<Integer, Document> documents, 
54 HashMap<DocPair, Double> similarities) { 
55 for (Entry<DocPair, Double> entry : similarities.entrySet()) { 
56 DocPair pair = entry.getKey(); 
57 Double intersection = entry.getValue(); 
58 Document docl = documents.get(pair.doc"
3324,497,"Solutions to Chapter 17 I Hard
59 Document doc2 = documents.get(pair.doc2); 
60 double union= (double) docl.size() + doc2.size() - intersection; 
61 entry.setValue(intersection / union); 
62 } 
63 } 
64 
65 /* HashMapList<Integer, Integer> is a HashMap that maps from Integer to 
66 * Arraylist<Integ"
3325,490,"which compares all pairs of documents directly. 
Optimized (Alternative} 
There's an alternative algorithm that some candidates might come up with. It's slightly slower, but still quite 
good. 
Recall our earlier algorithm that computed the similarity between two documents by sorting them. We can 
e"
3326,496,"list of documents would look like this: 
Now we have essentially the same approach as before. We iterate through this list of elements. For each 
sequence of identical elements, we increment the intersection counts for the corresponding pair of docu­
ments. 
We will use an Element class to group tog"
3327,473,"2 public int word, document; 
3 public Element(int w, int d) { 
4 word= w; 
5 document= d; 
6 } 
7 
8 /* When we sort the words, this function will be used to compare the words. */ 
9 public int compareTo(Element e) { 
10 if (word== e.word) { 
11 return document - e.document; 
12 } 
13 return word -"
3328,474,"19 Arraylist<Element> elements= sortWords(documents); 
20 HashMap<DocPair, Double> similarities= computeintersections(elements); 
21 adjustToSimilarities(documents, similarities); 
22 return similarities; 
23 } 
24 
25 /* Throw all words into one list, sorting by the word and then the document. */ 
"
3329,510,"for (Document doc : docs.values()) { 
Arraylist<Integer> words= doc.getWords(); 
for (int word : words) { 
Solutions to Chapter 17 I Hard 
28 
29 
30 
31 
32 
33 
34 
35 
elements.add(new Element(word, doc.get!d())); 
36 } 
37 
} 
} 
Collections.sort(elements); 
return elements; 
38 /* Increment the"
3330,469,"41 if (!similarities.containsKey(pair)) { 
42 similarities.put(pair, 1.0); 
43 } else { 
44 similarities.put(pair, similarities.get(pair) + 1); 
45 } 
46 } 
47 
48 /* Adjust the intersection value to become the similarity. */ 
49 HashMap<DocPair, Double> computeintersections(ArrayList<Element> eleme"
3331,460,"53 Element left = elements.get(i); 
54 for (int j = i + 1; j < elements.size(); j++) { 
55 Element right = elements.get(j); 
56 if (left.word != right.word) { 
57 break; 
58 } 
59 increment(similarities, left.document, right.document); 
60 } 
61 } 
62 return similarities; 
63 } 
64 
65 /* Adjust the"
3332,405,"67 HashMap<DocPair, Double> similarities) { 
68 for (Entry<DocPair, Double> entry : similarities.entrySet()) { 
69 DocPair pair = entry.getKey(); 
70 Double intersection = entry.getValue(); 
71 Document docl = documents.get(pair.doc1); 
72 Document doc2 = documents.get(pair.doc2); 
73 double union ="
3333,339,"74 entry.setValue(intersection / union); 
75 } 
76 } 
The first step of this algorithm is slower than that of the prior algorithm, since it has to sort rather than just 
add to a list. The second step is essentially equivalent. 
Both will run much faster than the original naive algorithm. 
CrackingT"
3334,498,"XI 
Advanced Topics 
W
hen writing the 6th edition, I had a number of debates about what should and shouldn't be included. 
Red-black trees? Dijkstra's algorithm? Topological sort? 
On one hand, I'd had a number of requests to include these topics. Some people insisted that these topics 
are asked """
3335,493,"On the other hand, I know these topics to be rarely asked. It happens, of course. Interviewers are individuals 
and might have their own ideas of what is ""fair game"" or""relevant""for an interview. But it's rare. When it does 
come up, if you don't know the topic, it's unlikely to be a big red flag. 
"
3336,467,"knew the algorithm, they did not benefit from this knowledge (nor were they hurt by it). I want 
to evaluate your ability to solve a problem you haven't seen before. So, I'll take into account 
whether you know the underlying algorithm in advance. 
I believe in giving people a fair expectation of th"
3337,471,"and energy. That's not fair or right to do to you. 
(Additionally, I didn't want to give interviewers-who I know to be reading this-the impression that they 
can or should be covering these more advanced topics. Interviewers: If you ask about these topics, you're 
testing knowledge of algorithms. Yo"
3338,423,"Ultimately, I decided to leave the decision in your hands. After all, you know better than I do how thorough 
you want to be in your preparation. If you want to do an extra thorough job, read this. If you just love 
learning data structures and algorithms, read this. If you want to see new ways of a"
3339,285,"� Useful Math 
Here's some math that can be useful in some questions. There are more formal proofs that you can look 
up on line, but we'll focus here on giving you the intuition behind them. You can think of these as informal 
proofs. 
CrackingTheCodinglnterview.com I 6th Edition 629"
3340,503,"XI. Advanced Topics
Sum of Integers 7 through N 
What is 1 
+ 2 + ... + n? Let's figure it out by pairing up low values with high values. 
If n is even, we pair 1 with n, 2 with n - 1, and so on. We will have f pairs each with sum n + 1. 
If n is odd, we pair O with n, 1 with n - 1, and so on. We wi"
3341,431,"1 4 3 n -
n _I!_ 
-%-+1 n + 1 n+l n-1 n+l 2 2 -2- -2- -2-
n(n+l) In either case, the sum is --2-. 
This reasoning comes up a lot in nested loops. For example, consider the following code: 
1 for (inti= 0; i < n; i++) { 
2 for (int j = i + 1; j < n; j++) { 
3 System.out.println(i + j); 
4 } 
5 } 
n 
"
3342,443,"the outer for loop, the inner for loop iterates n -2 times. Next, n - 3, then n - 4, and so on. There are n<n;
i) 
total iterations of the inner for loop. Therefore, this code takes O( n2) time. 
Sum of Powers of 2 
Consider this sequence: 2° + 21 + 22 + ... + 2"". What is its result? 
A nice way to "
3343,452,"23 01000 
24 10000 
1 
2 
4 
8 
16 
Therefore, the sum of 2° + 
21 + 22 + ... + 2"" would, in base 2, be a sequence of (n + 1) 1 s. This is 2n+1 - 1.
Takeaway: The 
sum of a sequence of powers of two is roughly equal to the next value in the sequence. 
Bases of Logs 
Suppose we have something in log2"
3344,420,"Let's do some math. Assume c logbk and y = logxk. 
logb k = c - - > b e = k / / This is the definition of log. 
XI. Advanced Topics
log.(be ) 
= logxk // Take log of both sides of be = k. 
c logxb = logxk // Rules of logs. You can move out the exponents. 
log,k/ 
c = logbk = /log,b // Dividing above"
3345,462,"log2p logrnp= log210
Takeaway: Logs of different bases are only off by a constant factor. For this reason, we largely ignore what 
the base of a log within a big O expression. It doesn't matter since we drop constants 
anyway. 
Permutations 
How many ways are there of rearranging a string of n uniqu"
3346,445,"n - 2 options for what to put in the third slot, and so on. Therefore, the total number of strings is n ! . 
n ! = D. * D_:___l * !L..:.__2_ * .!l.__.=._J * . . . * 1
What if you were forming a k-length string (with all unique characters) from n total unique characters? You 
can follow similar logic"
3347,508,"Combinations 
Suppose you have a set of n distinct characters. How many ways are there of selecting k characters into 
a new set (where order doesn't matter)? That is, how many k-sized subsets are�f\ere out of n distinct 
elements? This is what the expression n-choose-k means, which is often written"
3348,479,"_ k) ! k-length substrings. 
Since each k-sized subset can be rearranged k ! unique ways into a string, each subset will be duplicated k! 
times in this list of substrings. Therefore, we need to divide by k ! to take out these duplicates. 
(n)-
_1___* n! _ n! 
k - kl (n-k)! -k!(n -k )! 
Proof by Ind"
3349,447,"form. 
Task: Prove statement P ( k) is true for all k >= b. 
Base Case: Prove the statement is true for P ( b). This is usually just a matter of plugging in numbers. 
Assumption: Assume the statement is true for P ( n). 
Inductive Step: Prove that if the statement is true for P ( n), then it's true "
3350,212,"dominoes must fall. 
Let's use this to prove that there are 2n subsets of an n-element set. 
Definitions: let 5 = { a 1 , a2 , a3 , ••• , aJ be the n-element set. 
CrackingTheCodinglnterview.com I 6th Edition 631"
3351,478,"XI. Advanced Topics
Base case: Prove there are 2° subsets of {}. This is true, since the only subset of {} is {}. 
, Assume that there are 2n subsets of { a1 , a2 , a3 , ••• , aJ. 
Prove that there are 2n+l subsets of { a1, a 2, a 3, , • , , a n+l} ·
Consider the subsets of {a1 , a2 , a3 , ••• , an+"
3352,494,"there are 2"" of those. 
Since we have the same number of subsets with x as without x, there are 2"" subsets with an+i·
Therefore, we have 2"" + 2"" subsets, which is 2n+1. 
Many recursive algorithms can be proved valid with induction. 
� Topological Sort 
A topological sort of a directed graph is a way"
3353,454,"topological sort. 
There are a number of applications for th is. For example, suppose the graph represents parts on an assembly 
line. The edge (Handle, Door) indicates that you need to assemble the handle before the door. The topo­
logical sort would offer a valid ordering for the assembly line. 
W"
3354,438,"» We know those nodes are safe to add first since they have nothing that needs to come before
them. Might as well get them over with!
» We know that such a node must exist if there's no cycle. After all, if we picked an arbitrary node
we could just walk edges backwards arbitrarily. We'll either stop"
3355,429,"is a cycle).
2. When we do the above, remove each node's outbound edges from the graph.
» Those nodes have already been added to the topological sort, so they're basically irrelevant. We
can't violate those edges anymore.
3. Repeat the above, adding nodes with no incoming edges and removing their ou"
3356,505,"More formally, the algorithm is this: 
1. Create a queue order, which will eventually store the valid topological sort. It is currently empty.
2. Create a queue processNext. This queue will store the next nodes to process.
3. Count the number of incoming edges of each node and set a class variable n"
3357,224,"4. Walk through the nodes again and add to processNext any node where x. inbound 0. 
5. While processNext is not empty, do the following:
» Remove first node n from processNext.
632 Cracking the Coding Interview, 6th Edition"
3358,488,"XI. Advanced Topics
» For each edge (n, x),decrementx. inbound. lfx. inbound == 0,appendx toprocessNext.
» Append n to order.
6. If order contains all the nodes, then it has succeeded. Otherwise, the topological sort has failed due
to a cycle.
This algorithm does sometimes come up in interview quest"
3359,501,"before. 
� Dijkstra's Algorithm 
In some graphs, we might want to have edges with weights. If the graph represented cities, each edge 
might represent a road and its weight might represent the travel time. In this case, we might want to ask, 
just as your GPS mapping system does, what's the shortest"
3360,508,"(which might have cycles). All edges must have positive values. 
Rather than just stating what Dijkstra's algorithm is, let's try to derive it. Consider the earlier described 
graph. We could find the shortest path from s tot by literally taking all possible routes using actual time. 
(Oh, and we'll"
3361,473,"should actually take 5 minutes to get there.
3. Each time we get to a node, check if anyone's been there before. If so, then just stop. We're automatically
not as fast as another path since someone beat us here from s. If no one has been here before, then
clone ourselves and head out in all possible"
3362,487,"shortest path. 
Imagine that each clone could jump immediately from one node to its adjacent nodes (regardless of the 
edge weight), but it kept a time_so_far log of how long its path would have taken if it did walk at the 
""true"" speed. Additionally, only one person moves at a time, and it's always"
3363,79,"Consider the following graph. 
CrackingTheCodinglnterview.com I 6th Edition 633"
3364,445,"XI. Advanced Topics
Assume we are trying to find the shortest path from a to i. We'll use Dijkstra's algorithm to find the shortest 
path from a to all other nodes, from which we will clearly have the shortest path from a to i. 
We first initialize several variables: 
path_weight [node]: maps from e"
3365,488,"previous [node]: maps from each node to the previous node in the (current) shortest path. 
remaining: a priority queue of all nodes in the graph, where each node's priority is defined by its 
path_weight. 
Once we've initialized these values, we can start adjusting the values of path_ weight. 
I 
A "
3366,458,"it like a typical queue, except that, instead of removing the oldest item, it removes the item with 
the lowest or highest priority.) It is an abstract data type because it is defined by its behavior (its 
operations). Its underlying implementation can vary. You could implement a priority queue with"
3367,418,"1. Select the node in remaining with the lowest value in path_weight. Call this node n.
2. For each adjacent node, compare path_weight [ x] (which is the weight of the current shortest path
from a tox) to path_weight[n] + edge_weight[ (n, x) ]. That is.could we get a path from a to
x with lower weig"
3368,431,"previous.
3. Remove n from remaining.
When remaining is empty, then path_weight stores the weight of the current shortest path from a to 
each node. We can reconstruct this path by tracing through previous. 
Let's walk through this on the above graph. 
1. The first value of n is a. We look at its ad"
3369,250,"2. Then, we go to the next smallest node, which is e. We previously updated path_weight [ e] to be 2. Its
adjacent nodes are h and i, so we update path_weight (to 6 and 9) and previous for both of those.
634 Cracking the Coding Interview, 6th Edition"
3370,506,"XI. Advanced Topics
Observe that 6 is path_weight[ e] (which is 2) + the weight of the edge ( e, h) (which is 4). 
3. The next smallest node is c, which has path_weight 3. Its adjacent nodes are b and d. The value of
path_weight [ d] is infinity, so we update it to 4 (which is path_weight [ c] + wei"
3371,458,"+ 1 = 4) is less than 5, we update path_weight [ b] to 4 and
previous to c. This indicates that we would improve the path from a to b by going 
through c.
We continue 
doing this until remaining is empty. The following diagram shows the changes to the path_ 
weight (left) and previous (right) at eac"
3372,462,"Once we're done, we can follow this chart backwards, starting at i to find the actual path. In this case, the 
smallest weight path has weight 8 and is a - > c - > d - > g - > i. 
Priority Queue and Runtime 
As mentioned earlier, our algorithm used a priority queue, but this data structure can be im"
3373,426,"have v vertices and e nodes. 
If you implemented the priority queue with an array, then you would call remove_min up to v times. 
Each operation would take O(v) time, so you'd spend O(v2 ) time in the remove_min calls. Addition­
ally, you would update the values of path_weight and previous at most o"
3374,488,"more edges than there are pairs of vertices. Therefore, the total runtime is 0( v2). 
If you implemented the priority queue with a min heap, then the remove_min calls will each take 
0( log v) time (as will inserting and updating a key). We will do one remove_min call for each vertex, 
so that's O(v"
3375,384,"Which one is better? Well, that depends. If the graph has a lot of edges, then v2 will be close toe. In this
case, you might be better off with the array implementation, as O(v2 ) is better than 0( (v + 
v2 ) log
v). However, if the graph is sparse, then e is much less than v2• In this case, the min"
3376,506,"XI. Advanced Topics
� Hash Table Collision Resolution 
Essentially any hash table can have collisions. There are a number of ways of handling this. 
Chaining with Linked Lists 
With this approach (which is the most common), the hash table's array maps to a linked list of items. We 
just add items to"
3377,412,"happen with either some very strange data or a very poor hash function (or both). 
Chaining with Binary Search Trees 
Rather than storing collisions in a linked list, we could store collisions in a binary search tree. This will bring 
the worst-case runtime toO(log n). 
In practice, we would rarely "
3378,475,"Open Addressing with Linear Probing 
In this approach, when a collision occurs (there is already an item stored at the designated index), we just 
move on to the next index in the array until we find an open spot. (Or, sometimes, some other fixed distance, 
like the index + 5.) 
If the number of col"
3379,429,"the array. This is not the case with chaining. 
There's another issue here. Consider a hash table with an underlying array of size 100 where indexes 20 
through 29 are filled (and nothing else). What are the odds of the next insertion going to index 30?The odds 
are 10% because an item mapped to any"
3380,404,"issue called clustering. 
Quadratic Probing and Double Hashing 
The distance between probes does not need to be linear. You could, for example, increase the probe 
distance quadratically. Or, you could use a second hash function to determine the probe distance. 
� Rabin-Karp Substring Search 
The br"
3381,492,"length of S and b is the length of B. We do this by searching through the first b - s + 1 characters in B 
and, for each, checking if the next s characters match S. 
The Rabin-Karp algorithm optimizes this with a little trick: if two strings are the same, they must have the 
same hash value. (The co"
3382,479,"the locations of Si n O(b) time. We then just need to validate that those locations really do match S. 
For example, imagine our hash function was simply the sum of each character (where space= 0, a= 1, b = 
2, and so on). If S is ear and B = doe a re hearing me, we'd then just be looking for sequen"
3383,489,"XI. Advanced Topics
If we computed these sums by doing hash(· doe·), then hash ( 
• oe ·),then hash(· e a·), and soon, 
we would still be atO(s (b-s)) time. 
Instead, we compute the hash values by recognizing that hash ( 'oe ') hash ('doe') - code (' d') 
+ co de(' '). This takes O(b) time to comput"
3384,496,"could match. That's absolutely true-for this hash function. 
In practice, we would use a better rolling hash function, such as the Rabin fingerprint. This essentially treats 
a string like doe as a base 128 (or however many characters are in our alphabet) number. 
hash('doe') = code('d') * 1282 + co"
3385,448,"This will considerably cut down on the number of false matches. Using a good hash function like this will 
give us expected time complexity of O(s + b ), although the worst case is 0( sb ). 
Usage of this algorithm comes up fairly frequently in interviews, so it's useful to know that you can identif"
3386,452,"but you can look up deletions separately if you're interested. 
Properties 
An AVL tree stores in each node the height of the subtrees rooted at this node. Then, for any node, we can 
check if it is height balanced: that the height of the left subtree and the height of the right subtree differ by 
n"
3387,387,"-1 <= balance(n) <= 1
When you insert a node, the balance of some nodes might change to -2 or 2. Therefore, when we ""unwind"" 
the recursive stack, we check and fix the balance at each node. We 
do this through a series of rotations. 
Rotations can be either left or right rotations. The right rotatio"
3388,476,"XI. Advanced Topics
RIGHT 
,. LEFT 
Depending on the balance and where the imbalance occurs, we fix it in a different way. 
Case 7: Balance is 2. 
In this case, the left's height is two bigger than the right's height. If the left side is larger, the left subtree's 
extra nodes must be hanging to the"
3389,475,"SHAPE then into BALANCED. If it looks like the LEFT LEFT SHAPE already, just transform it into BALANCED. 
LEFT RIGHT SHAPE 
Case 2: Balance is -2. 
LEFT 
ROTATION 
___. 
LEFT LEFT SHAPE 
RIGHT 
ROTATION 
___. 
BALANCED 
This case is the mirror image of the prior case. The tree will look like either "
3390,479,"RIGHT 
ROTATION 
___. 
BALANCED 
In both cases, ""balanced"" just means that the balance of the tree is between -1 and 1. It does not mean 
that the balance is O. 
We recurse up the tree, fixing any imbalances. If we ever achieve a balance of Oon a subtree, then we know 
that we have completed all the"
3391,46,"638 Cracking the Coding Interview, 6th Edition"
3392,425,"XI. Advanced Topics
� Red-Black Trees 
Red-black trees (a type of self-balancing binary search tree) do not ensure quite as strict balancing, but the
balancing is still good enough to ensure O ( log N) insertions, deletions, and retrievals. They require a bit 
less memory and can rebalance faster (w"
3393,477,"in situations where the tree will be modified frequently. 
Red-black trees operate by enforcing a quasi-alternating red and black coloring (under certain rules, 
described below) and then requiring every path from a node to its leaves to have the same number of black 
nodes. Doing so leads to a reas"
3394,468,"1. Every node is either red or black.
2. The root is black.
3. The leaves, which are NULL nodes, are considered black.
4. Every red node must have two black children. That is, a red node cannot have red children (although a
black node can have black children).
5. Every path from a node to its leaves"
3395,444,"more than half the nodes in a path can be red. 
Consider two paths from a node (say, the root) to its leaves. The paths must have the same number of 
black nodes (property #5), so let's assume that their red node counts are as different as possible: one path 
contains the minimum number of red nodes"
3396,442,"Path 2 (Max Red): The maximum number of red nodes is b, since red nodes must have black children and 
there are b black nodes. Therefore, path 2 has 2b nodes total. 
Therefore, even in the most extreme case, the lengths of paths cannot differ by more than a factor of two. 
That's good enough to ensu"
3397,229,"0( log N) insert and find, anyway. The question then is how to maintain these properties efficiently. We'll 
only discuss insertion here, but you can look up deletion on your own. 
CrackingTheCodinglnterview.com \ 6th Edition 639"
3398,459,"XI. Advanced Topics
Insertion 
Inserting a new node into a red-black tree starts off with a typical binary search tree insertion. 
New nodes are inserted at a leaf, which means that they replace a black node. 
New nodes are always colored red and are given two black leaf (NULL) nodes. 
Once we've do"
3399,501,"Black violations: One path has more blacks than another path. 
The node inserted is red. We didn't change the number of black nodes on any path to a leaf, so we know that 
we won't have a black violation. However, we might have a red violation. 
In the special case that where the root is red, we can"
3400,510,"Let's call N the current node.Pis N's parent. G is N's grandparent. U is N's uncle and P's sibling. We know that 
N is red and Pis red, since we have a red violation. 
G is definitely black, since we didn't previously have a red violation. 
The unknown parts are: 
U could be either red or black. 
U "
3401,441,"Case 1 : U is red. 
It doesn't matter whether U is a left or right child, nor whether Pis a left or right child. We can merge four 
of our eight cases into one. 
If U is red, we can just toggle the colors of P, U, and G. Flip G from black to red. Flip P and U from red to 
black. We haven't changed t"
3402,356,"apply the full logic to handle a red violation, where this G becomes the new N. 
Note that in the general recursive case, N, P, and U may also have subtrees in place of each black NULL 
(the leaves shown). In Case 1, these subtrees stay attached to the same parents, as the tree structure 
remains un"
3403,467,"XI. Advanced Topics
Case 2: U is black. 
We'll need to consider the configurations (left vs. right child) of N and U. In each case, our goal is to fix up 
the red violation (red on top of red) without: 
» Messing up the ordering of the binary search tree.
» Introducing a black violation (more black "
3404,437,"maintain the node ordering. 
Further, the below rotations maintain the exact number of black nodes in each path through the affected 
portion of the tree that were in place beforehand. The children of the rotating section are either NULL 
leaves or subtrees that remain internally unchanged. 
Case A:"
3405,414,"If you picture the in-order traversal, you can see the rotation maintains the node ordering (a < = N < = 
b <= P <= c <= G <= U). The tree maintains the same, equal number of black nodes in the path 
down to each subtree a, b, c, and U (which may all be NULL) . 
Case 8: Pis a left child, and N is a "
3406,171,"N < = c < = G < = U. Again, the count of the black nodes remains constant in each path down to the 
leaves (or subtrees). 
CrackingTheCodinglnterview.com I 6th Edition 641"
3407,453,"XI. Advanced Topics
Case C: N and Pare both right children. 
This is a mirror image of case A. 
Case D: N is a left child, and Pis a right child. 
This is a mirror image of case B. 
In each of Case 2's subcases, the middle element by value of N, P, and G is rotated to become the root of 
what was G'"
3408,502,"no red violations, no black violations, and no violations of the binary search tree property? 
� MapReduce 
MapReduce is used widely in system design to process large amounts of data. As its name suggests, a 
MapReduce program requires you to write a Map step and a Reduce step. The rest is handled b"
3409,488,"4. The system-provided Shuffle process reorganizes the data so that all <key, value> pairs associated
with a given key go to the same machine, to be processed by Red uce .
5. The user-provided Reduce program takes a key and a set of associated values and ""reduces""them in
some way, emitting a new key"
3410,93,"frequency of words within a set of documents. 
642 Cracking the Coding Interview, 6th Edition"
3411,504,"XI. Advanced Topics
Of course, you could write this as a single function that reads in all the data, counts the number of times 
each word appears via a hash table, and then outputs the result. 
MapReduce allows you to process the document in parallel. The Map function reads in a document and 
emits"
3412,470,"input for 
another call to Reduce on the same key (as shown in the diagram). 
1 void map(String name, String document): 
2 for each word wi n document: 
3 emit(w, 1) 
4 
5 void reduce(String word, Iterator partialCounts): 
6 int sum= 0 
7 for each count in partialCounts: 
8 sum+= count 
9 emit(word,"
3413,491,"kto, li---1a-
1do t o, 21----L . .... ,L ........ .J 
Here's another example: You have a list of data in the form {City, Temperature, Date}. Calculate the average 
temperature in each city every year. For example {(2012, Philadelphia, 58.2), (2011, Philadelphia, 56.6), 
(2012, Seattle, 45.1 )}. 
•
M"
3414,504,"be important for the Reduce step.
Reduce: The Reduce step will be given a list of temperatures that correspond with a particular city and
year. It must use these to compute the average temperature for this input. You cannot simply add up the
temperatures and divide by the number of values.
To see th"
3415,463,"up being input for another Reduce step with 50, and it would be a mistake to just naively 
average 80 and
50. The 80 has more weight.
Therefore, our Reduce step instead takes in {(80, 2), (SO, 1 }}, then sums the weighted temperatures. So it 
does 80 * 
2 + 50 * 1 and then divides by (2 + 1) to get "
3416,377,"the final answer: (67, 5). In other words, the average temperature in this city for this year was 67 degrees. 
We could do this in other ways, too. We could have just the city as the key, and the value be (Year, Tempera­
ture, Count). The Reduce step would do essentially the same thing, but would ha"
3417,464,"XI. Advanced Topics
In many cases, it's useful to think about what the Reduce step should do first, and then design the Map step 
around that. What data does Reduce need to have to do its job? 
� Additional Studying 
So, you've mastered this material and you want to learn even more? Okay. Here are s"
3418,416,"with positive and negative edges. 
Floyd-Warshall Algorithm: Finds the shortest paths in a weighted graph with positive or negative 
weight edges (but no negative weight cycles). 
Minimum Spanning Trees: In a weighted, connected, undirected graph, a spanning tree is a tree that 
connects all the ver"
3419,408,"are various algorithms to do this. 
B-Trees: A self-balancing search tree (not a binary search tree) that is commonly used on disks or other
storage devices. It is similar to a red-black tree, but uses fewer 1/0 operations.
A*: Find the least-cost path between a source node and a goal node (or one o"
3420,487,"Interval Trees: An extension of a balanced binary search tree, but storing intervals (low -> high ranges) 
instead of simple values. A hotel could use this to store a list of all reservations and then efficiently detect 
who is staying at the hotel at a particular time. 
Graph coloring: A way of col"
3421,492,"K colors. 
P, NP, and NP-Complete: P. NP. and NP-Complete refer to classes of problems. P problems are prob­
lems that can be quickly solved (where ""quickly"" means polynomial time). NP problems are those where, 
given a solution, the solution can be quickly verified. NP-Complete problems are a subse"
3422,452,"It is an open (and very famous) question whether P = NP, but the answer is generally believed to be no. 
Combinatorics and Probability: There are various things you can learn about here, such as random 
variables, expected value, and n-choose-k. 
Bipartite Graph: A bipartite graph is a graph where y"
3423,433,"set). There is an algorithm to check if a graph is a bipartite graph. Note that a bipartite graph is equiva­
lent to a graph that can be colored with two colors. 
Regular Expressions: You should know that regular expressions exist and what they can be used for 
(roughly). You can also learn about ho"
3424,340,"There is of course a great deal more to data structures and algorithms. If you're interested in exploring 
these topics more deeply, I recommend picking up the hefty Introduction to Algorithms (""CLRS"" by Carmen, 
Leiserson, Rivest and Stein) or The Algorithm Design Manual (by Steven Skiena). 
644 Cr"
3425,480,"Code Library 
C
ertain patterns came up while implementing the code for this book. We've tried to generally include 
the full code for a solution with the solution, but in some cases it got quite redundant. 
This appendix provides the code for a few bf the most useful chunks of code. 
All code for t"
3426,502,"from an item of type ofT to an Array List of type E. 
For example, we might want a data structure that maps from an integer to a list of strings. Ordinarily, we'd 
have to write something like this: 
1 HashMap<Integer, Arraylist<String>> maplist = 
2 new HashMap<Integer, Arraylist<String>>(); 
3 for"
3427,505,"8 maplist.get(key).add(s); 
9 } 
Now, we can just write this: 
1 HashMaplist<Integer, String> maplist new HashMapList<Integer, String>(); 
2 for (String s : strings) { 
3 int key= computeValue(s); 
4 maplist.put(key, s); 
5 } 
It's not a big change, but it makes our code a bit simpler. 
1 public cla"
3428,147,"6 if (!map.containsKey(key)) { 
7 map.put(key, new Arraylist<E>()); 
8 } 
9 map.get(key).add(item); 
646 Cracking the Coding Interview, 6th Edition"
3429,494,"10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 } 
} 
/* Insert list of items at key. */ 
public void put(T key, Arraylist<E> items) { 
map.put(key, items); 
} 
/* Get list of items at key. */ 
public Arraylist<E>"
3430,495,"} 
/* Check if list at key contains value. */ 
public boolean containsKeyValue(T key, E value) { 
Arraylist<E> list = get(key); 
if (list == null) return false; 
return list.contains(value); 
} 
/* Get the list of keys. */ 
public Set<T> keySet() { 
return map.keySet(); 
} 
@Override 
public String "
3431,496,"possible. In many questions, we needed access to the internals of the node or tree class (or needed to tweak 
these) and thus couldn't use the built-in libraries. 
The TreeNode class supports a variety of functionality, much of which we wouldn't necessarily want for 
every question/solution. For exa"
3432,220,"1 public class TreeNode { 
2 public int data; 
3 public TreeNode left, right, parent; 
4 private int size = 0; 
5 
6 public TreeNode(int d) { 
7 data d; 
8 size = 1; 
9 } 
CrackingTheCodinglnterview.com I 6th Edition 647"
3433,509,"XI. Code Library
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 } 
public void insertinOrder(int d) { 
if (d <= data) { 
} 
if (left == null) { 
setLeftChil"
3434,494,"} 
size++; 
public int size() { 
return size; 
} 
public TreeNode find(int d) { 
if (d == data) { 
} 
return this; 
} else if (d <= data) { 
return left != null? left.find(d) : null; 
} else if (d > data) { 
return right != null? right.find(d) : null; 
} 
return null; 
public void setLeftChild(TreeN"
3435,417,"if (right != null) { 
right.parent = this; 
} 
} 
This tree is implemented to be a binary search tree. However, you can use it for other purposes. You would 
just need to use the setLeftCh ild/setRightChild methods, or the left and right child variables. 
For this reason, we have kept these methods "
3436,510,"XI. Code Library
� LinkedlistNode (Linked List) 
Like the TreeNode class, we often needed access to the internals of a linked list in a way that the built-in 
linked list class wouldn't support. For this reason, we implemented our own class and used it for many 
problems. 
1 public class LinkedListN"
3437,496,"25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 } 
public LinkedlistNode(int d, LinkedlistNode n, LinkedListNode p){ 
data = d; 
setNext(n); 
setPrevious(p); 
} 
public LinkedListNode(int d) { 
data = d; 
} 
public LinkedListNode() {} 
public void setNext(LinkedListNode n) { 
next"
3438,493,"prev = p; 
} 
if (p != null && p.next != this) { 
p.setNext(this); 
} 
public LinkedListNode clone() { 
LinkedListNode next2 = null; 
if (next != null) { 
} 
next2 = next.clone(); 
} 
LinkedlistNode head2 = new LinkedListNode(data, next2, null); 
return head2; 
Again, we've kept the methods and vari"
3439,346,"� Trie & TrieNode 
The trie data structure is used in a few problems to make it easier to look up if a word is a prefix of any other 
words in a dictionary (or list of valid words). This is often used when we're recursively building words so that 
we can short circuit when the word is not valid. 
Cr"
3440,501,"XI. Code Library
1 public class Trie { 
2 II The root of this trie. 
3 private TrieNode root; 
4 
5 I* Takes a list of strings as an argument, and constructs a trie that stores 
6 * these strings. */
7 public Trie(Arraylist<String> list) {
8 root = new TrieNode(); 
9 for (String word : list) { 
10 r"
3441,482,"17 public Trie(String[] list) {
18 root = new TrieNode(); 
19 for (String word : list) { 
20 root.addWord(word); 
21 } 
22 } 
23 
24 I* Checks whether this trie contains a string with the prefix passed in as 
25 * argument. *I
26 public boolean contains(String prefix, boolean exact) {
27 TrieNode la"
3442,498,"31 if (lastNode == null) { 
32 return false; 
33 } 
34 } 
35 return !exact I I lastNode.terminates(); 
36 } 
37 
38 public boolean contains(String prefix) { 
39 return contains(prefix, false); 
40 } 
41 
42 public TrieNode getRoot() { 
43 return root; 
44 } 
45 } 
The Trie class uses the TrieNode cl"
3443,326,"4 private boolean terminates = false; 
5 
6 /* The character stored in this node as data.*/ 
7 private char character; 
8 
9 /* Constructs an empty trie node and initializes the list of its children to an 
10 * empty hash map. Used only to construct the root node of the trie. */
650 Cracking the Cod"
3444,497,"11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 } 
XI. Code Library
public TrieNode() { 
children= new HashMap<Character, TrieNode>()"
3445,499,"public TrieNode(char character) {
this(); 
this.character = character; 
} 
/* Returns the character data stored in this node. */ 
public char getChar() { 
return character; 
} 
/* Add this word to the trie, and recursively create the child 
* nodes. */
public void addWord(String word) {
} 
if (word="
3446,464,"children.put(firstChar, child); 
} 
if (word.length() > 1) { 
child.addWord(word.substring(l)); 
} else { 
child.setTerminates(true); 
} 
/* Find a child node of this node that has the char argument as its data. Return 
* null if no such child node is present in the trie. */
public TrieNode getChild"
3447,220,"public boolean terminates() { 
return terminates; 
} 
/* Set whether this node is the end of a complete word.*/ 
public void setTerminates(boolean t) { 
terminates= t; 
} 
CrackingTheCodinglnterview.com I 6th Edition 651"
3448,493,"#1. 
#2. 
#3. 
#4. 
#5. 
#6. 
#7. 
#8. 
#9. 
#10. 
#11. 
#12. 
1.2 
3.1 
2.4 
4.10 
2.6 
4.12 
2.5 
2.2 
2.1 
4.8 
4.10 
3.1 
I 
Hints for Data Structures 
Describe what it means for two strings to be permutations of each other. Now, look at 
that definition you provided. Can you check the strings a"
3449,481,"many possible solutions, and there are tradeoffs of each. 
There are many solutions to this problem, most of which are equally optimal in runtime. 
Some have shorter, cleaner code than others. Can you brainstorm different solutions? 
If T2 is a subtree of Tl, how will its in-order traversal compare "
3450,488,"What if you reversed the linked list? 
Try simplifying the problem. What if the path had to start at the root? 
Of course, you could convert the linked lists to integers, compute the sum, and then 
convert it back to a new linked list. If you did this in an interview, your interviewer would 
likely "
3451,486,"last element and finding the Xth element? 
Have you tried a hash table? You should be able to do this in a single pass of the linked 
list. 
If each node has a link to its parent, we could leverage the approach from question 2.7 
on page 95. However, our interviewer might not let us make this assump"
3452,509,"in-order traversal means: contents are in-order. (And if it won't work in the specific case 
of a binary search tree, then it certainly won't work for a general binary tree.) The pre­
order traversal, however, is much more indicative. 
We could simulate three stacks in an array by just allocating th"
3453,69,"with the divisions? 
CrackingTheCodinglnterview.com \ 6th Edition 653"
3454,483,"11 Hints for Data Structures 
#13. 
#14. 
#15. 
#16. 
#17. 
#18. 
#19. 
#20. 
#21. 
#22. 
#23. 
#24. 
#25. 
#26. 
#27. 
#28. 
#29. 
#30. 
2.6 
4.12 
3.5 
4.8 
1.8 
4.10 
4.2 
2.7 
4.4 
3.6 
1.5 
2.4 
2.2 
4.7 
3.2 
4.8 
2.6 
2.5 
Try using a stack. 
Don't forget that paths could overlap. For example"
3455,456,"a new array in sorted order. Can you do this with a stack? 
The first common ancestor is the deepest node such that p and q are both descendants. 
Think about how you might identify this node. 
If you just cleared the rows and columns as you found Os, you'd likely wind up clearing 
the whole matrix."
3456,497,"Tl. preorderTraversal (), then T2 is a subtree of Tl. This is almost true, except 
that the trees could have duplicate values. Suppose Tl and T2 have all duplicate values 
but different structures. The pre-order traversals will look the same even though T2 is 
not a subtree of Tl. How can you handle"
3457,494,"same number of nodes are on the left of the root as on the right? 
You can do this in O(A+B) time and 0(1) additional space. That is, you do not need a 
hash table (although you could do it with one). 
Think about the definition of a balanced tree. Can you check that condition for a single 
node? Ca"
3458,486,"Start with the easy thing. Can you check each of the conditions separately? 
Consider that the elements don't have to stay in the same relative order. We only need 
to ensure that elements less than the pivot must be before elements greater than the 
pivot. Does that help you come up with more solut"
3459,506,"edge exists from A to B if B depends on A (A must be built before B). You can also build 
it the other way if it's easier for you. 
Observe that the minimum element doesn't change very often. It only changes when a 
smaller element is added, or when the smallest element is popped. 
How would you fig"
3460,289,"2-> 3->6-> 7 (representing 7632), and a function that operates on the remainder of the 
lists (5->9 and 3->6->7). Could you use this to create the sum method? What is the 
relationship between sum(l->5->9, 2->3->6->7) and sum(5->9, 3->6->7)? 
654 Cracking the Coding Interview, 6th Edition"
3461,470,"#31. 
#32. 
#33. 
#34. 
#35. 
#36. 
#37. 
#38. 
#39. 
#40. 
#41. 
#42. 
#43. 
#44. 
#45. 
#46. 
4.10 
3.5 
4.4 
1.9 
4.5 
4.8 
4.10 
3.1 
4.9 
2.1 
2.2 
4.11 
3.5 
1.1 
2.7 
4.8 
11 Hints for Data Structures 
Although the problem seems like it stems from duplicate values, it's really deeper than 
th"
3462,426,"value into the pre-order traversal string whenever you reach a null node. Register the 
null node as a ""real"" node so that you can distinguish between the different structures. 
Imagine your secondary stack is sorted. Can you insert elements into it in sorted order? 
You might need some extra storag"
3463,431,"computing the height of the subtrees for each node, you could have a pretty inefficient 
algorithm. 
If a string is a rotation of another, then it's a rotation at a particular point. For example, 
a rotation of waterbottle at character 3 means cutting waterbottle at character 3 
and putting the righ"
3464,495,"the right order, does this indicate that the tree is actually in order? What happens for 
duplicate elements? If duplicate elements are allowed, they must be on a specific side 
(usually the left). 
Start with the root. Can you identify if root is the first common ancestor? If it is not, can 
you id"
3465,470,"can we check to see if its subtree matches T2? 
If you want to allow for flexible divisions, you can shift stacks around. Can you ensure 
that all available capacity is used? 
What is the very first value that must be in each array? 
Without extra space, you'll need O(N2 ) time. Try using two pointe"
3466,492,"find the Kth element? 
Be very careful in this problem to ensure that each node is equally likely and that 
your solution doesn't slow down the speed of standard binary search tree algorithms 
(like insert, find, and delete). Also, remember that even if you assume that it's a 
balanced binary search"
3467,459,"primary stack for additional storage. 
Try a hash table. 
Examples will help you. Draw a picture of intersecting linked lists and two equivalent 
linked lists (by value) that do not intersect. 
Try a recursive approach. Check if p and q are descendants of the left subtree and the 
right subtree. If "
3468,126,"holds the first common ancestor. Now, how do you implement this efficiently? 
CrackingTheCodinglnterview.com I 6th Edition 655"
3469,491,"11 Hints for Data Structures 
#47. 
#48. 
#49. 
#50. 
#51. 
#52. 
#53. 
#54. 
#55. 
#56. 
#57. 
#58. 
#59. 
#60. 
#61. 
#62. 
4.7 
4.9 
4.4 
2.8 
1.7 
4.12 
1.3 
4.11 
2.7 
3.6 
4.5 
3.1 
3.2 
4.7 
2.6 
4.11 
Look at this graph. ls there any node you can identify that will definitely be okay to buil"
3470,471,"the left subtree values need to be inserted before the right subtree? 
What if you could modify the binary tree node class to allow a node to store the height 
of its subtree? 
There are really two parts to this problem. First, detect if the linked list has a loop. 
Second, figure out where the loop"
3471,428,"the root. We can track the sum as we go, incrementing totalPaths each time we 
find a path with our target sum. Now, how do we extend this to paths that can start 
anywhere? Remember: Just get a brute-force algorithm done. You can optimize later. 
It's often easiest to modify strings by going from t"
3472,504,"tree structure or nodes that you'd like (provided it doesn't have other negative implica­
tions, like making insert much slower). In fact, there's probably a reason the interview 
question specified that it was your own class. You probably need to store some addi­
tional information in order to impl"
3473,498,"animal of any type? Be creative! 
To be a binary search tree, it's not sufficient that the left. value <= current. 
value < right. value for each node. Every node on the left must be less than the 
current node, which must be less than all the nodes on the right. 
Try thinking about the array as cir"
3474,489,"easier to solve the problem? 
If you identify a node without any incoming edges, then it can definitely be built. Find 
this node (there could be multiple) and add it to the build order. Then, what does this 
mean for its outgoing edges? 
In the recursive approach (we have the length of the list), t"
3475,323,"that checks out. What about the previous node a? If x->middle->y is a palindrome, 
how can it check that a->x->middle->y->b is a palindrome? 
As a naive ""brute force"" algorithm, can you use a tree traversal algorithm to implement 
this algorithm? What is the runtime of this? 
656 Cracking the Coding"
3476,440,"#63. 
#64. 
#65. 
#66. 
#67. 
#68. 
#69. 
#70. 
#71. 
#72. 
#73. 
#74. 
#75. 
#76. 
#77. 
#78. 
#79. 
3.6 
3.3 
2.7 
4.9 
2.2 
4.12 
2.8 
4.8 
2.5 
2.3 
4.2 
1.8 
4.11 
2.7 
4.12 
3.2 
4.6 
1 I Hints for Data Structures 
Think about how you'd do it in real life. You have a list of dogs in chronologi"
3477,479,"How would you maintain this data? 
You will need to keep track of the size of each substack. When one stack is full, you may 
need to create a new stack. 
Observe that two intersecting linked lists will always have the same last node. Once they 
intersect, all the nodes after that will be equal. 
Th"
3478,468,"reverse (right values before left), or any other ordering. 
You might find it useful to return multiple values. Some languages don't directly support 
this, but there are workarounds in essentially any language. What are some of those 
workarounds? 
To extend this to paths that start anywhere, we ca"
3479,455,"pointer move faster than the other. 
In the more naive algorithm, we had one method that indicated if x is a descendent 
of n, and another method that would recurse to find the first common ancestor. This is 
repeatedly searching the same elements in a subtree. We should merge this into one 
firstCo"
3480,500,"Picture the list 1->5->9->12. Removing 9 would make it look like 1->5->12. You only 
have access to the 9 node. Can you make it look like the correct answer? 
You could implement this by finding the ""ideal"" next element to add and repeatedly 
calling insertValue. This will be a bit inefficient, as y"
3481,498,"need from the list of cells that are zero? 
Alternatively, you could pick a random depth to traverse to and then randomly traverse, 
stopping when you get to that depth. Think this through, though. Does this work? 
You can determine if two linked lists intersect by traversing to the end of each and "
3482,426,"O(log N) at worst. A node is touched once for each node above it. Therefore, the N 
nodes will be touched O ( log N) time. There is an optimization that will give us an 
O(N) algorithm. 
Consider having each node know the minimum of its ""substack"" (all the elements 
beneath it, including itself). 
T"
3483,476,"11 Hints for Data Structures 
#80. 
#81. 
#82. 
#83. 
#84. 
#85. 
#86. 
#87. 
#88. 
#89. 
#90. 
#91. 
#92. 
#93. 
4.8 
3.3 
4.9 
2.8 
1.2 
4.7 
4.5 
4.12 
1.9 
4.11 
2.8 
4.6 
1.6 
2.7 
The firstCommonAnc estor function could return the first common ancestor (if p 
and q are both contained in the tr"
3484,500,"capacity. Is this an issue? There's no right answer, but you should think about how to 
handle this. 
Break this down into subproblems. Use recursion. If you had all possible sequences for 
the left subtree and the right subtree, how could you create all possible sequences for 
the entire tree? 
You"
3485,478,"they land? Why there? 
There is one solution that is 0( N log N) time. Another solution uses some space, but 
isO(N) time. 
Once you decide to build a node, its outgoing edge can be deleted. After you've done 
this, can you find other nodes that are free and clear to build? 
If every node on the lef"
3486,446,"the current node. 
What work is duplicated in the current brute-force algorithm? 
We are essentially asking if there's a way of splitting the first string into two parts, x and 
y, such that the first string is xy and the second string is yx. For example, x = wat and 
y = erbottle. The first string "
3487,492,"than higher depths. Second, even if we re-balanced these probabilities, we could 
hit a ""dead end"" where we meant to pick a node at depth 5 but hit a leaf at depth 3. 
Re-balancing the probabilities is an interesting , though. 
If you haven't identified the pattern of where the two pointers start, t"
3488,481,"is a loop). Then make the ? the node 2. Then the node 3. Then the node 4. What is the 
pattern? Can you explain why this happens? 
Here's one step of the logic: The successor of a specific node is the leftmost node of the 
right subtree. What if there is no right subtree, though? 
Do the easy thing "
3489,83,"same length. How could you do this? 
658 Cracking the Coding Interview, 6th Edition"
3490,472,"#94. 
#95. 
#96. 
#97. 
#98. 
#99. 
#100. 
#101. 
#102. 
#103. 
#104. 
#105. 
#106. 
#107. 
#108. 
4.12 
2.5 
4.8 
1.5 
3.4 
4.11 
1.7 
2.6 
1.8 
4.12 
1.9 
4.4 
1.4 
4.3 
4.12 
11 Hints for Data Structures 
Consider each path that starts from the root (there are N such paths) as an array. What 
our"
3491,461,"and their sums. It might be useful to just focus on this little subproblem. Given an array, 
how would you find all contiguous subsequences with a particular sum? Again, think 
about the duplicated work in the brute-force algorithm. 
Does your algorithm work on linked lists like 9->7->8 and 6->8->5?"
3492,438,"happen? You might need to tweak the return values a bit. 
What is the relationship between the ""insert character"" option and the ""remove char­
acter"" option? Do these need to be two separate checks? 
The major difference between a queue and a stack is the order of elements. A queue 
removes the olde"
3493,455,"A naive approach that many people come up with is to pick a random number between 
1 and 3. If it's 1, return the current node. If it's 2, branch left. If it's 3, branch right. This 
solution doesn't work. Why not? Is there a way you can adjust it to make it work? 
Rotating a specific layer would ju"
3494,491,"arrays? 
Go back to the previous hint. Remember: There are ways to return multiple values. You 
can do this with a new class. 
You probably need some data storage to maintain a list of the rows and columns that 
need to be zeroed. Can you reduce the additional space usage to 0(1) by using the 
matri"
3495,459,"element i. For a subarray of element i through element j to have sum targetSum, 
runningSumi-i + targetSum must equal runningSumj (try drawing a picture of
an array or a number line). Given that we can track the runningSum as we go, how can 
we quickly look up the number of indices i where the previ"
3496,461,"erbottlewat to itself. You get erbottlewaterbottlewat. 
You don't need to modify the binary tree class to store the height of the subtree. Can 
your recursive function compute the height of each subtree while also checking if a 
node is balanced?Try having the function return multiple values. 
You d"
3497,154,"Try using a hash table that maps from a runningSum value to he number of elements 
with this runningSum. 
CrackingTheCodinglnterview.co1 I 6th Edition 659"
3498,481,"I \ Hints for Data Structures 
#109. 
#110. 
#111. 
#112. 
#113. 
#114. 
#115. 
#116. 
#117. 
#118. 
#119. 
#120. 
#121. 
#122. 
#123. 
2.5 
1.6 
2.7 
4.11 
4.5 
3.4 
4.12 
4.2 
1.1 
1.3 
4.11 
2.7 
1.4 
1.2 
4.3 
For the follow-up question: The issue is that when the linked lists aren't the same le"
3499,436,"linked list to do that, without changing the value it represents? 
Be careful that you aren't repeatedly concatenating strings together. This can be very 
inefficient. 
If the two linked lists were the same length, you could traverse forward in each until you 
found an element in common. Now, how do"
3500,509,"work is that the probabilities for the nodes won't be equal. For example, the root will be 
returned with probability X, even if there are 50+ nodes in the tree. Clearly, not all the
nodes have probability X, so these nodes won't have equal probability. We can resolve
this one issue by picking a ran"
3501,481,"rightTree. min, can we flip around the logic? Validate the left tree's nodes to ensure 
that they are smaller than current. value. 
We can remove the oldest item from a stack by repeatedly removing the newest item 
(inserting those into the temporary stack) until we get down to one element. Then, af"
3502,496,"scenarios where we might do several pops in a row? 
Once you've solidified the algorithm to find all contiguous subarrays in an array with a 
given sum, try to apply this to a tree. Remember that as you're traversing and modifying 
the hash table, you may need to ""reverse the damage"" to the hash tab"
3503,436,"you use this to operate on the root of the tree? Could you write the base case for the 
function? Great! Then that's basically the entire function. 
Could a bit vector be useful? 
You might find you need to know the number of spaces. Can you just count them? 
The issue with the earlier solution is t"
3504,431,"on the number of nodes on each side. How does this work, exactly? How can we know 
the number of nodes? 
Try using the difference between the lengths of the two linked lists. 
What characteristics would a string that is a permutation of a palindrome have? 
Could a hash table be useful? 
A hash table"
3505,453,"#124. 
#125. 
#126. 
#127. 
#128. 
#129. 
#130. 
#131. 
#132. 
#133. 
#134. 
#135. 
#136. 
4.4 
4.7 
2.2 
4.1 
4.5 
2.7 
1.5 
1.2 
1.1 
4.7 
1.4 
4.3 
1.4 
11 Hints for Data Structures
Actually, you can just have a single ch eckHeight function that does both the height 
computation and the balance c"
3506,477,"trary node. What is the relationship between this depth-first search and a valid build 
order? 
Can you do it iteratively? Imagine if you had two pointers pointing to adjacent nodes 
and they were moving at the same speed through the linked list. When one hits the end 
of the linked list, where will"
3507,483,"within an allowable (min, max) range. At first, this range is infinite. When we traverse 
to the left, the min is negative infinity and the max is root. value. Can you implement 
this recursive function and properly adjust these ranges as you traverse the tree? 
If you move a pointer in the longer l"
3508,481,"Can you do all three checks in a single pass? 
Two strings that are permutations should have the same characters, but in different 
orders. Can you make the orders the same? 
Can you solve it in O(N log N) time? What might a solution like that look like? 
Pick an arbitrary node and do a depth-first "
3509,343,"does this mean about the nodes right before it? 
Have you tried a hash table? You should be able to get this down to 0( N) time. 
You should be able to come up with an algorithm involving both depth-first search and 
breadth-first search. 
Can you reduce the space usage by using a bit vector? 
Crack"
3510,458,"#137. 
#138. 
#139. 
#140. 
#141. 
#142. 
#143. 
#144. 
#145. 
#146. 
#147. 
#148. 
#149. 
#150. 
#151. 
#152. 
#153. 
#154. 
#155. 
5.1 
8.9 
6.9 
11.5 
7.11 
9.6 
5.2 
8.6 
5.7 
6.10 
5.4 
8.14 
6.5 
8.7 
5.5 
8.1 
7.1 
6.7 
8.13 
II 
Hints for Concepts and Algorithms 
Break this into parts. Focus"
3511,487,"What does the interviewer mean by a pen? There are a lot of different types of pens. 
Make a list of potential questions you would want to ask. 
This is not as complicated as it sounds. Start by making a list of the key objects in the 
system, then think about how they interact. 
First, start with m"
3512,490,"Try the Base Case and Build approach. 
Swapping each pair means moving the even bits to the left and the odd bits to the right. 
Can you break this problem into parts? 
Solution 1: Start with a simple approach. Can you just divide up the bottles into groups? 
Remember that you can't re-use a test st"
3513,481,"Can we just try all possibilities? What would this look like? 
Play around with the jugs of water, pouring water back and forth, and see if you can 
measure anything other than 3 quarts or 5 quarts. That's a start. 
Approach 1: Suppose you had all permutations of abc. How can you use that to get all"
3514,247,"Note that a ""card deck"" is very broad. You might want to think about a reasonable scope 
to the problem. 
Observe that each family will have exactly one girl. 
Will sorting the boxes help in any way? 
662 Cracking the Coding Interview, 6th Edition"
3515,489,"#156. 
#157. 
#158. 
#159. 
#160. 
#161. 
#162. 
#163. 
#164. 
#165. 
#166. 
#167. 
#168. 
#169. 
#170. 
#171. 
#172. 
#173. 
#174. 
#175. 
6.8 
6.4 
9.6 
5.3 
6.7 
8.8 
9.7 
6.10 
11.5 
9.8 
8.5 
5.2 
8.14 
5.1 
8.3 
6.7 
6.9 
5.2 
8.9 
5.4 
11 I Hints for Concepts and Algorithms 
This is really an"
3516,442,"In what cases will they not collide? 
We've assumed that the rest of the eCommerce system is already handled, and we just 
need to deal with the analytics part of safes rank. We can get notified somehow when a 
purchase occurs. 
Start with a brute force solution. Can you try all possibilities? 
Thin"
3517,437,"them (or adding them to a list). You can do this with a hash table. In what case might this 
be okay? In what case might it not be a very good solution? 
Will this application be write-heavy or read-heavy? 
Solution 1: There is a relatively simple approach that works in 28 days, in the worst case. 
"
3518,508,"use cases? 
Scope the problem well. What will and won't you tackle as part of this system? 
Think about multiplying 8 by 9 as counting the number of cells in a matrix with width 8 
and height 9. 
In a number like • 893 (in base 10), what does each digit signify? What then does each 
digit in .10010 "
3519,489,"the base case? 
To clear the bits, create a ""bit mask""that looks like a series of 1 s, then Os, then 1 s. 
Start with a brute force algorithm. 
You can attempt this mathematically, although the math is pretty difficult. You might 
find it easier to estimate it up to families of, say, 6 children. Thi"
3520,475,"A number such as • 893 (in base 10) indicates 8 * 10-1 + 9 * 10-2 + 3 * 10-3•
Translate this system into base 2. 
Suppose we had all valid ways of writing two pairs of parentheses. How could we use 
this to get all valid ways of writing three pairs? 
Get Next: Picture a binary number-something with "
3521,102,"number get bigger? In what case will it get smaller? 
CrackingTheCodinglnterview.com I 6th Edition 663"
3522,457,"11 I Hints for Concepts and Algorithms 
#176. 
#177. 
#178. 
#179. 
#180. 
#181. 
#182. 
#183. 
#184. 
#185. 
#186. 
#187. 
#188. 
#189. 
#190. 
#191. 
#192. 
#193. 
9.6 
10.2 
8.1 
7.8 
9.7 
6.2 
10.2 
6.10 
9.8 
8.7 
6.1 
8.9 
6.7 
9.6 
8.8 
6.10 
7.6 
10.9 
Think about what sort of expectations o"
3523,486,"more important than others? 
How do you check if two words are anagrams of each other? Think about what the defi­
nition of""anagram"" is. Explain it in your own words. 
If we knew the number of paths to each of the steps before step 100, could we compute 
the number of steps to 100? 
Should white pie"
3524,450,"data very frequently. 
Calculate the probability of winning the first game and winning the second game, then 
compare them. 
Two words are anagrams if they contain the same characters but in different orders. 
How can you put characters in order? 
Solution 2: Why do we have such a time lag between t"
3525,443,"lag is there for a reason. 
How evenly do you think traffic is distributed? Do all documents get roughly the same 
age of traffic? Or is it likely there are some very popular documents? 
Approach 1: The permutations of abc represent all ways of ordering abc. Now, we want 
to create all orderings of "
3526,446,"the string bca, can you create all the""related"" orderings that include d, too? 
You can only use the scale once. This means that all, or almost all, of the bottles must 
be used. They also must be handled in different ways or else you couldn't distinguish 
between them. 
We could try generating the "
3527,468,"and after. That is: ()<SOLUTION>, (<SOLUTION>), <SOLUTION>(). Will this 
work? 
Logic might be easier than math. Imagine we wrote every birth into a giant string of Bs 
and Gs. Note that the groupings of families are irrelevant for this problem. What is the 
probability of the next character added t"
3528,420,"If you haven't solved 8.7 yet, do that one first. 
Solution 2: Consider running multiple tests at once. 
A common trick when solving a jigsaw puzzle is to separate edge and non-edge pieces. 
How will you represent this in an object-oriented manner? 
Start with a naive solution. (But hopefully not to"
3529,491,"#194. 
#195. 
#196. 
#197. 
#198. 
#199. 
#200. 
#201. 
#202. 
#203. 
#204. 
#205. 
#206. 
#207. 
#208. 
#209. 
#210. 
#211. 
#212. 
#213. 
#214. 
8.13 
6.4 
10.11 
8.14 
7.3 
9.7 
8.7 
6.7 
5.5 
8.5 
8.3 
6.10 
9.8 
10.6 
9.6 
8.9 
11.6 
10.9 
9.7 
7.7 
8.13 
11 I Hints for Concepts and Algorithms "
3530,488,"the array. 
The only way they won't collide is if all three are walking in the same direction. What's 
the probability of all three walking clockwise? 
Imagine the array were sorted in ascending order. Is there any way you could ""fix it""to 
be sorted into alternating peaks and valleys? 
The base cas"
3531,501,"reasonable assumptions, but you need to make them explicit. 
The system will be write-heavy: Lots of data being imported, but it's rarely being read. 
Approach 1: Given a string such as bca, you can create all permutations of abed that 
have {a, b, c} in the order bca by inserting d into each possib"
3532,434,"having kids has changed. Each pregnancy has a 50% odds of being a boy and a 50% 
odds of being a girl. 
What does it mean if A & B == 0? 
If you wanted to count the cells in an 8x9 matrix, you could count the cells in a 4x9 
matrix and then double it. 
Your brute force algorithm probably ran in O(N)"
3533,473,"runtime? 
Solution 2: Think about trying to figure out the bottle, digit by digit. How can you detect 
the first digit in the poisoned bottle? What about the second digit? The third digit? 
How will you handle generating URLs? 
Think a bout merge sort versus quick sort. Wou Id one of them work well "
3534,432,"cate values. We could eliminate this by using a hash table. 
Be careful about your assumptions. Who are the users? Where are they using this? It 
might seem obvious, but the real answer might be different. 
We can do a binary search in each row. How long will this take? How can we do better? 
Think "
3535,254,"pushed?), what features the system will support, etc. 
As always, scope the problem. Are ""friendships"" mutual? Do status messages exist? Do 
you support group chat? 
Try to break it down into subproblems. 
CrackingTheCodinglnterview.com \ 6th Edition 665"
3536,457,"11 I Hints for Concepts and Algorithms 
#215. 
#216. 
#217. 
#218. 
#219. 
#220. 
#221. 
#222. 
#223. 
#224. 
#225. 
#226. 
#227. 
#228. 
#229. 
#230. 
#231. 
#232. 
#233. 
5.1 
7.11 
8.1 
6.6 
10.11 
11.5 
6.10 
8.8 
9.6 
8.6 
11.6 
5.3 
8.5 
7.8 
10.9 
6.10 
10.11 
9.8 
6.8 
It's easy to create a "
3537,494,"left side and then another one for the right side. Then you can merge those. 
What is the relationship between files and directories? 
We can compute the number of steps to 100 by the number of steps to 99, 98, and 97. 
This corresponds to the child hopping 1, 2, or 3 steps at the end. Do we add tho"
3538,465,"it. 
Try walking through a sorted array. Can you just swap elements until you have fixed the 
array? 
Have you considered both intended uses (writing, etc.) and unintended use? What 
about safety? You would not want a pen for children to be dangerous. 
Solution 2: Be very careful about edge cases. W"
3539,466,"Don't forget that a product can be listed under multiple categories. 
You can easily move the smallest disk from one tower to another. It's also pretty easy 
to move the smallest two disks from one tower to another. Can you move the smallest 
three disks? 
In a real interview, you would also want to"
3540,462,"separated by only one 0. 
Think about how you might handle this for odd numbers. 
What class should maintain the score? 
If you're considering a particular column, is there a way to quickly eliminate it (in some 
cases at least)? 
Solution 2: You can run an additional day of testing to check digit 3"
3541,471,"iteration to fix the array can skip over every other element. 
If you generate URLs randomly, do you need to worry about collisions (two documents 
with the same URL)? If so, how can you handle this? 
As a first approach, you might try something like binary search. Drop it from the 50th 
floor, then"
3542,222,"floor and going up. This could take, at worst, 50 drops (the 50th floor drop, the 1st floor 
drop, the 2nd floor drop, and up through the 49th floor drop). Can you beat this? 
666 Cracking the Coding Interview, 6th Edition"
3543,442,"#234. 
#235. 
#236. 
#237. 
#238. 
#239. 
#240. 
#241. 
#242. 
#243. 
#244. 
#245. 
#246. 
#247. 
#248. 
#249. 
#250. 
#251. 
#252. 
#253. 
8.5 
10.7 
9.6 
8.1 
7.6 
6.2 
8.3 
6.10 
5.4 
8.9 
9.6 
7.7 
8.5 
9.7 
5.7 
6.10 
8.6 
10.9 
11 I Hints for Concepts and Algorithms 
If there's duplicated work"
3544,488,"Where would it be appropriate to cache data or queue up tasks? 
We multiply the values when it's ""we do this then this:' We add them when it's ""we do 
this or this:' 
Think about how you might record the position of a piece when you find it. Should it be 
stored by row and location? 
To calculate th"
3545,440,"Can you solve the problem in O(log N)? 
Solution 3: Think about each test strip as being a binary indicator for poisoned vs. non­
poisoned. 
Get Next: If you flip a 1 to a O and a Oto a 1, it will get bigger if the 0-> 1 bit is more signifi­
cant than the 1->0 bit. How can you use this to create the"
3546,443,"left and right parens at each step. Will this eliminate duplicates? How do we know if we 
can add a left or right paren? 
Depending on what assumptions you made, you might even be able to do without a 
database at all. What would this mean? Would it be a good idea? 
This is a good problem to think a"
3547,436,"Try to reduce unnecessary database queries. If you don't need to permanently store the 
data in the database, you might not need it in the database at all. 
Can you create a number that represents just the even bits? Then can you shift the even 
bits over by one? 
Solution 3: If each test strip is a"
3548,483,"Think about moving the smallest disk from tower X=0 to towerY=2 using tower Z=1 as 
a temporary holding spot as having a solution for f(1, X=0, Y=2, Z=1). Moving 
the smallest two disks is f(2, X=0, Y=2, Z=1). Given that you have a solution for 
f(l, X=0, Y=2, Z=l) andf(2, X=0, Y=2, Z=1),can you sol"
3549,269,"6.1 What happens if you put one pill from each bottle on the scale? What if you put two pills 
from each bottle on the scale? 
10.11 Do you necessarily need the arrays to be sorted? Can you do it with an unsorted array? 
CrackingTheCodinglnterview.com I 6th Edition 667"
3550,457,"11 I Hints for Concepts and Algorithms 
#254. 
#255. 
#256. 
#257. 
#258. 
#259. 
#260. 
#261. 
#262. 
#263. 
#264. 
#265. 
#266. 
#267. 
#268. 
#269. 
#270. 
#271. 
#272. 
#273. 
#274. 
#275. 
10.7 
8.8 
10.5 
11.1 
7.4 
9.5 
8.13 
5.5 
8.1 
10.2 
6.9 
8. 9
10.9 
8.7 
11.6 
5.2 
9.2 
7.7 
8. 6
8.4 "
3551,427,"acter: A, B, or C. If it's an A, then you need all permutations with 2 As, 2 Cs, and 1 B. 
Try modifying binary search to handle this. 
There are two mistakes in this code. 
Does the parking lot have multiple levels? What ""features"" does it support? Is it paid? 
What types of vehicles? 
You may need"
3552,500,"viewer here). That's okay. Make those assumptions explicit. 
Think about the first decision you have to make. The first decision is which box will be at 
the bottom. 
If A & B == 0, then it means that A and B never have a 1 at the same spot. Apply this 
to the equation in the problem. 
What is the r"
3553,479,"this mean that all numbers have an even number of factors? 
Adding a left or right paren at each step will eliminate duplicates. Each substring will be 
unique at each step. Therefore, the total string will be unique. 
If the value xis smaller than the start of the column, then it also can't be in a"
3554,465,"What are the different features and uses we would want to test? 
How would you get the first digit in • 893? If you multiplied by 10, you'd shift the values 
over to get 8. 93. What happens if you multiply by 2? 
To find the connection between two nodes, would it be better to do a breadth-first 
sea"
3555,495,"You can dof(3, X=0, Y=2, Z=l) byfirst doingf(2, X=0, Y=l, Z=2) (moving 
two disks from tower Oto tower 1, using tower 2 as a buffer), then moving disk 3 from 
tower Oto tower 2, then doing f ( 2, X=l, Y=2, Z=0) (moving two disks from tower 
1 to tower 2, using tower Oas a buffer). How does this proc"
3556,114,"table? How would that work? 
How, if at all, will you handle aces? 
668 Cracking the Coding Interview, 6th Edition"
3557,505,"#276. 
#277. 
#278. 
#279. 
#280. 
#281. 
#282. 
#283. 
#284. 
#285. 
#286. 
#287. 
#288. 
#289. 
#290. 
#291. 
#292. 
#293. 
#294. 
9.7 
10.11 
8.7 
10.9 
8.5 
10.7 
6.6 
7.6 
6.2 
9.2 
8.3 
7.12 
10.9 
10.8 
8.4 
10.9 
10.11 
9.5 
6.8 
11 I Hints for Concepts and Algorithms 
As much work as possib"
3558,487,"Approach 2: If you had all permutations of two-character substrings, could you generate 
all permutations of three-character substrings? 
Think about the previous hint in the context of rows. 
Alternatively, if you're doing 9 * 7, you could do 4*7, double that, and then add 7. 
Try using one pass to"
3559,462,"wou Id they leave? 
Which will be the easiest pieces to match first? Can you start with those? Which will be 
the next easiest, once you've nailed those down? 
If two events are mutually exclusive (they can never occur simultaneously), you can add 
their probabilities together. Can you find a set of"
3560,457,"long path, even though the shortest path is actually very short. Is there a modification 
to a breadth-first search that might be even faster? 
Binary search has a runtime of O( log N). Can you apply a form of binary search to the 
problem? 
In order to handle collisions, the hash table should be an"
3561,482,"and cons of this? 
Can you use a bit vector? 
Anything that is a subset of {a, b} is also a subset of {a, b, c}. Which sets are 
subsetso f{a, b, c}but not{a, b}? 
Can we use the previous hints to move up, down, left, and right around the rows and 
columns? 
Revisit the set of sequences for { 0, 1, "
3562,502,"won't invalidate the previous part of the array? 
Can you combine a hash table and a linked list to get the best of both worlds? 
It's actually better for the first drop to be a bit lower. For example, you could drop at the 
10th floor, then the 20th floor, then the 30th floor, and so on. The worst "
3563,95,"number of drops of each egg factor into that? 
CrackingTheCodinglnterview.com I 6th Edition 669"
3564,431,"11 I Hints for Concepts and Algorithms 
#295. 
#296. 
#297. 
#298. 
#299. 
#300. 
#301. 
#302. 
#303. 
#304. 
#305. 
#306. 
#307. 
#308. 
#309. 
#310. 
#311. 
#312. 
#313. 
8.9 We can ensure that this string is valid by counting the number of left and right parens. 
It is always valid to add a left "
3565,451,"6.4 You can think about this either as the probability(3 ants walking clockwise) + proba­
bility(3 ants walking counter-clockwise). Or, you can think about it as: The first ant picks 
a direction. What's the probability of the other ants picking the same direction? 
5.2 Think about what happens for "
3566,463,"11.1 What will happen to the unsigned int? 
8.11 Try breaking it down into subproblems. If you were making change, what is the first 
choice you would make? 
10.1 O The problem with using an array is that it will be slow to insert a number. What other 
data structures could we use? 
5.5 
10.9 
9.2 
"
3567,440,"spot. Why would that happen? 
Another way to think about this is that if you drew a rectangle around a cell extending 
to the bottom, right coordinate of the matrix, the cell would be bigger than all the items 
in this square. 
Is there any way to search from both the source and destination? For wha"
3568,455,"boolean result, and left/right side), think about the relationship between the different 
parts. Try to simplify your code. It should not need a ton of complicated if-state­
ments. For example, consider expressions of the form <LEFT>OR<RIGHT> versus 
<LEFT>AND<RIGHT>. Both may need to know the numbe"
3569,493,"number of factors (1, 2, 3, 4, 6, 12). What numbers do not? What does this tell you about 
the doors? 
Think carefully about what information the linked list node needs to contain. 
We know that each row must have a queen. Can you try all possibilities? 
Approach 2: To generate a permutation of abed"
3570,504,"this approach to generate all permutations of the full string? 
What is the runtime of your algorithm? What will happen if the array has duplicates? 
How would you scale this to a larger system? 
Get Next: Can you flip a Oto a 1 to create the next biggest number? 
Think about what load testing is de"
3571,464,"#314. 
#315. 
#316. 
#317. 
#318. 
#319. 
#320. 
#321. 
#322. 
#323. 
#324. 
#325. 
#326. 
#327. 
#328. 
#329. 
#330. 
#331. 
#332. 
5.3 
10.8 
11 I Hints for Concepts and Algorithms 
Each sequence can be lengthened by merging it with an adjacent sequence (if any) or 
just flipping the immediate nei"
3572,482,"part of this problem. 
10.11 You should be able to design an O(n) algorithm. 
10.9 A cell will be larger than all the items below it and to the right. It will be smaller than all 
cells above it and to the left. If we wanted to eliminate the most elements first, which 
element should we compare the "
3573,451,"Once you've figured out how to move the top two disks from tower Ot o tower 2, trust 
that you have this working. When you need to move three disks, trust that you can move 
two disks from one tower to another. Now, two disks have been moved. What do you do 
about the third? 
Imagine there were just"
3574,482,"bottle 2 has 2 pills, and bottle 3 has 9 pills). What would the scale show? 
Think about how binary search works. What will be the issue with just implementing 
binary search? 
Discuss how you might implement these algorithms and this system in the real world. 
What sort of optimizations might you m"
3575,500,"2, miss shot 3) + probability(make shot 1, miss shot 2, make shot 3) + probability(miss 
shot 1, make shot 2, make shot 3) + probability(make shot 1, make shot 2, make shot 3). 
If you were making change, the first choice you might make is how many quarters you 
need to use. 
Think about issues both"
3576,435,"The value 1010 in binary is 10 in decimal or OxA in hex. What will a sequence of 101010 ... 
be in hex? That is, how do you represent an alternating sequence of 1 sand Os with 1 si n 
the odd places? How do you do this for the reverse (1 si n the even spots)? 
Consider both extreme cases and more ge"
3577,332,"quarter of the elements in the matrix. 
For the robot to reach the last cell, it must find a path to the second-to-last cells. For it to 
find a path to the second-to-last cells, it must find a path to the third-to-last cells. 
Try moving from the end of the array to the beginning. 
CrackingTheCodin"
3578,447,"11 I Hints for Concepts and Algorithms 
#333. 
#334. 
#335. 
#336. 
#337. 
#338. 
#339. 
#340. 
#341. 
#342. 
#343. 
#344. 
#345. 
#346. 
#347. 
#348. 
#349. 
#350. 
6.8 If we drop Egg 1 at fixed intervals (e.g., every 10 floors), then the worst case is the worst 
case for Egg 1 + the worst case for"
3579,451,"a bit. As Egg 1 does more work (has survived more drops), Egg 2 should have less work 
to do. What might this mean? 
9.3 Think about how infinite loops might occur. 
8.7 Approach 2: To generate all permutations of abed, pick each character (a, b, c, or d) 
as a starting character. Permute the remain"
3580,483,"follows the same logic. 
5.6 How would you figure out how many bits are different between two numbers? 
10.4 Binary search requires comparing an element to the midpoint. Getting the midpoint 
requires knowing the length. We don't know the length. Can we find it? 
8.4 Subsets that contain c will be s"
3581,432,"the smaller the bigger number is. If we have a number like 1001, we want to flip the 
rightmost O (to create 1011 ). But if we have a number like 1010, we should not flip the 
rightmost 1. 
8.3 Given a specific index and value, can you identify if the magic index would be before or 
after it? 
6.6 
"
3582,462,"know? When would they leave? Remember your answer from the prior hint. Assume 
they know the answer to the earlier hint. 
Do you even need to truly ""sort""? Or is just reorganizing the list sufficient? 
Once you've decided to use two quarters to make change for 98 cents, you now need 
to figure out h"
3583,496,"to support. You don't have to do everything, but you should think about making your 
assumptions explicit. 
Could you build your own? What might that look like? 
What is the relationship between how n looks and how n - 1 looks? Walk through a 
binary subtraction. 
Will you need multiple passes? Mult"
3584,215,"What can we automate? 
Each row must have a queen. Start with the last row. There are eight different columns 
on which you can put a queen. Can you try each of these? 
672 Cracking the Coding Interview, 6th Edition"
3585,465,"#351. 7.10 
#352. 5.3 
#353. 9.3 
#354. 8.4 
#355. 5.7 
#356. 8.7 
#357. 6.8 
#358. 5.4 
#359. 8.1 
#360. 8.2 
#361. 7.10 
#362. 11.1 
#363. 7.2 
#364. 8.10 
#365. 9.3 
#366. 5.8 
#367. 6.3 
#368. 8.13 
#369. 5.6 
#370. 6.6 
#371. 8.12 
11 I Hints for Concepts and Algorithms 
Should number cells, bl"
3586,502,"How would you detect the same page? What does this mean? 
You can build the remaining subsets by adding c to all the subsets of {a, b}. 
Try masks 0xaaaaaaaa and 0x55555555 to select the even and odd bits. Then try 
shifting the even and odd bits around to create the right number. 
Approach 2: You c"
3587,492,"push down a prefix to the recursive calls. 
Try dropping Egg 1 at bigger intervals at the beginning and then at smaller and smaller 
intervals. The idea is to keep the sum of Egg 1 and Egg 2's drops as constant as possible. 
For each additional drop that Egg 1 takes, Egg 2 takes one fewer drop. What"
3588,475,"as possible, but bigger than the original number (1010). What do we do? How can we 
shrink the number? 
Try memoization as a way to optimize an inefficient recursive program. 
Simplify this problem a bit by first figuring out if there's a path. Then, modify your algo­
rithm to track the path. 
What "
3589,506,"rithms. Picture the code. Do you have everything you need? 
Think about this as a graph. 
How do you define if two pages are the same? Is it the URLs? Is it the content? Both of 
these can be flawed. Why? 
First try the naive approach. Can you set a particular ""pixel""? 
Picture a domino laying down "
3590,441,"mize it. Are there any repeated subproblems? 
Think about what an XOR indicates. If you do a XOR b, where does the result have 1 s? 
Where does it have Os? 
Build up from this. What if there were three blue-eyed people? What if there were four 
blue-eyed people? 
Break this down into smaller subprob"
3591,130,"8 and column 3? You then need to check all the ways of placing a queen on row 7. 
CrackingTheCodinglnterview.com I 6th Edition 673"
3592,470,"11 I Hints for Concepts and Algorithms 
#372. 
#373. 
#374. 
#375. 
#376. 
#377. 
#378. 
#379. 
#380. 
#381. 
#382. 
#383. 
#384. 
#385. 
#386. 
#387. 
#388. 
#389. 
#390. 
#391. 
#392. 
5.5 
8.4 
6.8 
5.4 
When you do a binary subtraction, you flip the rightmost Os to a 1, stopping when you 
get to"
3593,457,"represent a ""boolean""flag for whether an element is in the set. 
Let X be the first drop of Egg 1. This means that Egg 2 would do X - 1 drops if Egg 1 
broke. We want to try to keep the sum of Egg 1 and Egg 2's drops as constant as possible. If 
Egg 1 breaks on the second drop, then we want Egg 2 to"
3594,468,"Egg 2 fairly constant. What is X? 
Get Next: We can shrink the number by moving all the 1 s to the right of the flipped bit 
as far right as possible (removing a 1 in the process). 
10.1 O Would it work well to use a binary search tree? 
7.1 O To place the bombs randomly on the board:Think about the"
3595,460,"stack? Does the second box go on the stack? And so on. 
6.5 If you fill the 5-quart jug and then use it to fill the 3-quart jug, you'll have two quarts 
left in the 5-quart jug. You can either keep those two quarts where they are, or you can 
dump the contents of the smaller jug and pour the two qua"
3596,476,"When you're drawing a long line, you'll have entire bytes that will become a sequence of 
1 s. Can you set this all at once? 
You can implement this using depth-first search (or breadth-first search). Each adjacent 
pixel of the ""right"" color is a connected edge. 
Picture n and n -1. To subtract 1 f"
3597,442,"does that mean about n? 
What about the start and end of the line? Do you need to set those pixels individually, 
or can you set them all at once? 
Think about this as a real-world application. What are the different factors you would 
need to consider? 
How do you count the number of bombs neighbor"
3598,419,"weight. 
Think again about the efficiency of your algorithm. Can you optimize it? 
The rotate () method should be able to run in 0( 1) time. 
Get Previous: Once you've solved Get Next, try to invert the logic for Get Previous. 
Does your code handle the case when xl and x2 are in the same byte? 
Con"
3599,428,"#393. 11.6 
#394. 8.11 
#395. 6.8 
#396. 9.1 
#397. 6.3 
#398. 5.5 
#399. 7.10 
#400. 6.5 
#401. 11.3 
11 I Hints for Concepts and Algorithms 
Have you thought about security and reliability? 
Try using memoization. 
I got 14 drops in the worst case. What did you get? 
There's no one right answer he"
3600,481,"We know that n must have only one 1 if n & ( n -1) == 0. What sorts of numbers have 
only one 1? 
When you click on a blank cell, what is the algorithm to expand the neighboring cells? 
Once you've developed a way to solve this problem, think about it more broadly. If you 
are given a jug of size X "
3601,492,"#402. 
#403. 
#404. 
#405. 
#406. 
#407. 
#408. 
#409. 
#410. 
#411. 
#412. 
#413. 
#414. 
#415. 
#416. 
#417. 
#418. 
#419. 
12.9 
15.2 
Ill 
Hints for Knowledge-Based Questions 
Focus on the concept firsts, then worry about the exact implementation. How should 
SmartPointer look? 
A context switch"
3602,462,"13.1 Think about who can access private methods. 
15.1 How do these differ in terms of memory? 
12.11 Recall that a two dimensional array is essentially an array of arrays. 
15.2 Ideally, we would like to record the timestamp when one process ""stops"" and the time­
stamp when another process ""starts:"
3603,446,"13.4 
15.5 
12.11 
15.3 
A GROUP BY clause might be useful. 
When does a finally block get executed? Are there any cases where it won't get executed? 
Can we do this in place? 
It might be helpful to break the approach into two pieces. The first piece is to get each 
building ID and the number of op"
3604,469,"are applied. 
Typically, malloc will just give us an arbitrary block of memory. If we can't override this 
behavior, can we work with it to do what we need? 
First implement the single-threaded FizzBuzz problem. 
Try setting up two processes and have them pass a small amount of data back and forth. "
3605,340,"differ? 
How can we ensure that first () has terminated before calling second ()? 
One approach is to call malloc for each array. How would we free the memory here? 
A deadlock can happen when there's a ""cycle"" in the order of who is waiting for whom. 
How can we break or prevent this cycle? 
676 Cr"
3606,491,"#420. 13.5 
#421. 12.7 
#422. 15.4 
#423. 12.3 
#424. 13.5 
#425. 13.4 
#426. 12.11 
#427. 12.8 
#428. 14.7 
#429. 15.6 
#430. 13.5 
#431. 14.3 
#432. 12.10 
#433. 15.5 
#434. 15.4 
#435. 13.6 
#436. 14.6 
#437. 15.3 
#438. 12.9 
#439. 15.7 
#440. 12.10 
#441. 15.2 
#442. 14.7 
111 I Hints for Knowl"
3607,435,"possible deadlocks in advance? 
What is the underlying data structure behind each? What are the implications of this? 
HashMap uses an array of linked lists. TreeMap uses a red-black tree. Link edHashMap 
uses doubly-linked buckets. What is the implication of this? 
Consider the usage of primitive t"
3608,486,"Can we allocate this instead as a contiguous block of memory? 
This data structure can be pictured as a binary tree, but it's not necessarily. What if 
there's a loop in the structure? 
You probably need a list of students, their courses, and another table building a relation­
ship between students "
3609,476,"methods on the same instance at the same time. 
Consider how they might differ in terms of the order of iteration through the keys. Why 
might you want one option instead of the others? 
First try to get a list of the IDs (just the IDs) of all the relevant apartments. 
Imagine we have a sequential s"
3610,465,"Why would using boolean flags to do this be a bad idea? 
Think about the order of requests as a graph. What does a deadlock look like within this 
graph? 
Object reflection allows you to get information about methods and fields in an object. 
Why might this be useful? 
Be particularly careful about "
3611,467,"one. 
Think about tracking the number of references. What will this tell us? 
Don't try to do anything fancy on the single-threaded problem. Just get something that 
is simple and easily readable. 
How will we free the memory? 
It's okay if your solution isn't totally perfect. That might not be poss"
3612,474,"111 I Hints for Knowledge-Based Questions 
#443. 13.8 
#444. 14.5 
#445. 12.5 
#446. 15.5 
#447. 15.7 
#448. 13.7 
#449. 12.1 
#450. 13.8 
#451. 14.4 
#452. 12.2 
#453. 12.9 
#454. 13.5 
#455. 14.5 
#456. 12.6 
#457. 13.8 
#458. 15.7 
#459. 12.1 
#460. 12.7 
#461. 13.7 
#462. 12.8 
#463. 12.4 
#464."
3613,483,"Denormalization means adding redundant data to a table. It's typically used in very 
large systems. Why might this be useful? 
A shallow copy copies just the initial data structure. A deep copy does this, and also 
copies any underlying data. Given this, why might you use one versus the other? 
Woul"
3614,461,"If we already had the number of lines in the file, how would we do this? 
Pick the list of all the subsets of an n-element set. For any given item x, half of the 
subsets contain x and half do not. 
Describe INNER JOINs and OUTER JOINs. OUTER JOINs can have multiple types: left, 
right, and full. 
B"
3615,498,"What would the runtime of the common operations be? 
Think about the cost of joins on a large system. 
The keyword volatile signals that a variable might be changed from outside of the 
program, such as by another process. Why might this be necessary? 
Do not pick the length of the subset in advance"
3616,430,"nize. 
Suppose we didn't have the number of lines in the file. Is there a way we could do this 
without first counting the number of lines? 
What would happen if the destructor were not virtual? 
Break this up into two parts: filtering the countries and then getting a sum. 
Consider using a hash tab"
3617,508,"#465. 
#466. 
#467. 
#468. 
#469. 
#470. 
#471. 
#472. 
#473. 
#474. 
#475. 
#476. 
#477. 
#478. 
#479. 
#480. 
#481. 
#482. 
#483. 
16.3 
16.12 
17.1 
16.13 
17.24 
17.14 
16.20 
16.3 
16.7 
IV 
Hints for Additional Review Problems 
Think about what you're going to design for. 
Consider a recursive"
3618,428,"Start with a brute force solution. 
There are actually several approaches. Brainstorm these. It's okay to start off with a naive 
approach. 
Consider recursion. 
Will all lines intercept? What determines if two lines intercept? 
Let k be 1 if a > b and O otherwise. If you were given k, could you ret"
3619,440,"17.15 Try simplifying this problem: What if you just needed to know the longest word made 
up of two other words in the list? 
16.1 O Solution 1: Can you count the number of people alive in each year? 
17.25 Start by grouping the dictionary by the word lengths, since you know each column has 
to be "
3620,433,"would you identify transitive relationships? A == B, A == C, and C == D implies A 
== D == B == C. 
16.13 Any straight line that cuts a square in half goes through the center of the square. How 
then can you find a line that cuts two squares in half? 
17.17 Start with a brute force solution. What is"
3621,207,"the max size of the grid? 
16.16 Would it help to know the longest sorted sequences at the beginning and end? 
17.2 Try approaching this problem recursively. 
CrackingTheCodinglnterview.com I 6th Edition 679"
3622,458,"IV I Hints for Additional Review Problems
#484. 
#485. 
#486. 
#487. 
#488. 
#489. 
#490. 
#491. 
#492. 
#493. 
#494. 
#495. 
#496. 
#497. 
#498. 
#499. 
#500. 
#501. 
#502. 
#503. 
17.26 Solution 1: Start with just a simple algorithm comparing all documents to all other docu­
ments. How would you c"
3623,449,"having an array of As and Bs. You would then be looking for the longest subarray with 
an equal number of As and Bs. 
17.11 Consider first the algorithm for finding the closest distance if you will run the algorithm 
only once. You should be able to do this in O(N) time, where N is the number of wor"
3624,461,"16.3 
17.26 
17.15 
Can you recursively try all possibilities? 
Be clear about what this problem is asking for. It's asking for the kth smallest number in 
the form 3a * Sb * 7c.
Think about what the best conceivable runtime is for this problem. If your solution 
matches the best conceivable runtime"
3625,487,"people are alive in that year. 
Sometimes, a brute force is a pretty good solution. Can you try all possible lines? 
Try picturing the two numbers, a and b, on a number line. 
The core part of the problem is to group names into the various spellings. From there, 
figuring out the frequencies is rela"
3626,461,"start with the recursive solution. 
Try a recursive approach. 
Infinite lines will almost always intersect-unless they're parallel. Parallel lines might 
still ""intercept""-if they're the same lines. What does this mean for line segments? 
Solution 1: To compute the similarity of two documents, try r"
3627,479,"could iterate over all words, from longest to shortest, checking if each could be made up 
of other words. To check this, we split the string in all possible locations. 
17.25 Can you find a word rectangle of a specific length and width? What if you just tried all 
options? 
17.11 Adapt your algorit"
3628,138,"17.19 Start with the first part: Finding the missing number if only one number is missing. 
680 Cracking the Coding Interview, 6th Edition"
3629,509,"#504. 
#505. 
#506. 
#507. 
#508. 
#509. 
#510. 
#511. 
#512. 
#513. 
#514. 
#515. 
#516. 
#517. 
#518. 
#519. 
#520. 
#521. 
#522. 
IV I Hints for Additional Review Problems 
17 .16 Recursive solution: You have two choices at each appointment (take the appointment 
or reject the appointment). As a "
3630,493,"request i + 1. 
16.23 
17.22 
16.10 
17.9 
17.12 
17.26 
17.24 
17.7 
Be very careful that your solution actually returns each value from O through 6 with 
equal probability. 
Start with a brute force, recursive solution. Just create all words that are one edit away, 
check if they are in the dictio"
3631,510,"like? 
Try a recursive approach. 
Solution 1: You should be able to get an O ( A+B) algorithm to compute the similarity of 
two documents. 
The brute force solution requires us to continuously compute the sums of each matrix. 
Can we optimize this? 
One thing to try is maintaining a mapping of each "
3632,501,"can get it to work. Then see if you can simplify/optimize it. 
16.7 lfk werelwhena > bandOotherwise,then you could returna*k + b*(not k). 
But how do you create k? 
16.1 O Solution 2: Do you actually need to match the birth years and death years? Does it 
matter when a specific person died, or do yo"
3633,472,"runtime of this approach? 
16.3 How can we find the intersection between two lines? If two line segments intercept, 
then this must be at the same point as their ""infinite"" extensions. Is this intersection 
point within both lines? 
17.26 Solution 1: What is the relationship between the intersection"
3634,502,"the numbers are smaller. 
16.14 You can't truly try all possible lines in the world-that's infinite. But you know that a 
""best"" line must intersect at least two points. Can you connect each pair of points? Can 
you check if each line is indeed the best line? 
16.26 Can we just process the expressio"
3635,464,"IV I Hints for Additional Review Problems 
#S23. 
#S24. 
#S25. 
#526. 
#527. 
#528. 
#529. 
#530. 
#531. 
#532. 
#533. 
#534. 
#535. 
#536. 
#537. 
#538. 
#539. 
#540. 
#541. 
16.1 O Solution 2: Observe that people are""fungible:'lt doesn't matter who was born and when 
they died. All you need is a l"
3636,486,"16.25 
17.24 
17.16 
16.3 
16.13 
16.14 
17.14 
16.17 
First scope the problem. What are the features you would want? 
Can you do any sort of precomputation to make computing the sum of a submatrix 
0(1)? 
Recursive solution: The runtime of your memoization approach should be O(N), with 
O(N) space."
3637,495,"You should be able to get to an O(N2) solution. 
Consider thinking about reorganizing the data in some way or using additional data 
structures. 
Picture the array as alternating sequences of positive and negative numbers. Observe 
that we would never include just part of a positive sequence or part"
3638,453,"16.22 Option #2:Think about how an Arraylist works. Can you use anArraylist for this? 
17.26 Solution 1: To understand the relationship between the union and the intersection of 
two sets, consider a Venn diagram (a diagram where one circle overlaps another circle). 
17.22 Once you have a brute forc"
3639,479,"the vast majority of them are not valid dictionary words. 
16.2 Can you use a hash table to optimize the repeated case? 
17.7 An easier way of taking the above approach is to have each name map to a list of alter­
nate spellings. What should happen when a name in one group is set equal to a name in "
3640,502,"17.24 What if you precomputed the sum of the submatrix starting at the top left corner and 
continuing to each cell? How long would it take you to compute this? If you did this, 
could you then get the sum of an arbitrary submatrix in O ( 1) time? 
16.22 Option #2: It's not impossible to use an Arra"
3641,202,"example of a list of people (with birth and death years) and then re-formatting this into 
a list of each year and a + 1 for a birth and a -1 for a death. 
682 Cracking the Coding Interview, 6th Edition"
3642,469,"#542. 
#543. 
#544. 
#545. 
#546. 
#547. 
#548. 
#549. 
#550. 
#551. 
#552. 
#553. 
#554. 
#555. 
IV I Hints for Additional Review Problems 
17.16 Iterative solution: Take the recursive solution and investigate it more. Can you imple­
ment a similar strategy iteratively? 
17.15 Extend the earlier id"
3643,456,"two bits, and then carrying over the one if necessary. You could also think about it as 
grouping the operations. What if you first added each of the bits (without carrying any 
overflow)? After that, you can handle the overflow. 
16.21 Do some math here or play around with some examples. What does "
3644,458,"first 100 elements could become the median. You can't just toss very low or very high 
elements. 
17.26 Solution 2: It's tempting to try to think of minor optimizations-for example, keeping 
track of the min and max elements in each array. You could then figure out quickly, in 
specific cases, if tw"
3645,466,"ments. It doesn't leverage the fact that the similarity is sparse. Given that we have a lot 
of documents, we really need to not compare all documents to all other documents 
(even if that comparison is very fast). All such solutions will be O ( D2 ), where D is the 
number of documents. We shouldn'"
3646,432,"runtime for this problem? 
16.10 Solution 3: What if you created an array of years and how the population changed in 
each year? Could you then find the year with the highest population? 
17.9 In looking for the kth smallest value of 3• * 5b * 7C, we know that a, b, and c will be 
less than or equal"
3647,511,"never start or end a sequence. (They could be present in a sequence if they connected 
two other sequences.) 
17.14 Can you sort the numbers? 
16.16 We can think about the array as divided into three subarrays: LEFT, MIDDLE, RIGHT. 
LEFT and RIGHT are both sorted. The MIDDLE elements are in an arbit"
3648,291,"wards. 
17.26 Solution 2: If we can't compare all documents to all other documents, then we need to 
dive down and start looking at things at the element level. Consider a naive solution 
and see if you can extend that to multiple documents. 
CrackingTheCodinglnterview.com I 6th Edition 683"
3649,511,"IV I Hints for Additional Review Problems 
#556. 
#557. 
#558. 
#559. 
#560. 
#561. 
#562. 
#563. 
#564. 
#565. 
#566. 
#567. 
17.22 To quickly get the valid words that are one edit away, try to group the words in the 
dictionary in a useful way. Observe that all words in the form b_ll (such as bill"
3650,465,"sum increases by a. What happens when you swap two values? What would be needed 
to swap two values and get the same sum? 
17.11 If you had a list of the occurrences of each word, then you are really looking for a pair 
of values within two arrays (one value for each array) with the smallest differe"
3651,485,"to an edge. How will you handle the ant wandering into negative coordinates, though? 
Arrays can't have negative indices. 
16.13 Given a line (slope and y-intercept), can you find where it intersects another line? 
17.26 Solution 2: One way to think about this is that we need to be able to very quic"
3652,486,"ments:'That wil I be at least O ( D2 ) .) 
17.16 Iterative solution: Observe that you would never skip three appointments in a row. Why 
would you? You would always be able to take the middle booking. 
16.14 Have you tried using a hash table? 
16.21 If you swap two values, a and b, then the sum of A"
3653,480,"compute the sum of an arbitrary submatrix in 0( 1) time. Picture a particular submatrix. 
The full, precomputed sum will include this submatrix, an array immediately above it 
(C), and array to the left (B), and an area to the top and left (A). How can you compute 
the sum of just D? 
yl 
y2 
xl x2 "
3654,374,"Suppose, for the first element, the first few checks reveal seven non-matching elements 
and three matching elements. Is it necessary to keep checking this element? 
16.17 Start from the beginning of the array. As that subsequence gets larger, it stays as the 
best subsequence. Once it becomes negat"
3655,498,"#568. 
#569. 
#570. 
#571. 
#572. 
#573. 
#574. 
#575. 
#576. 
#577. 
#578. 
#579. 
#580. 
#581. 
#582. 
#583. 
#584. 
#585. 
IV I Hints for Additional Review Problems
17.16 Iterative solution: If you take appointment i, you will never take appointment i + 1, 
but you will always take appointment i "
3656,490,"have? How would we gather all documents like that? 
16.22 Option #2: Observe that nothing in the problem stipulates that the label for the coor­
dinates must remain the same. Can you move the ant and all cells into positive coordi­
nates? In other words, what would happen if, whenever you needed to "
3657,450,"math to work out what this means for a and b's values. 
16.9 Approach these one by one, starting with subtraction. Once you've completed one 
function, you can use it to implement the others. 
17.6 Start with a brute force solution. 
16.23 Start with a brute force solution. How many times does it ca"
3658,503,"the top half of elements? 
16.10 Solution 3: Be careful with the little details in this problem. Does your algorithm/code 
handle a person who dies in the same year that they are born? This person should be 
counted as one person in the population count. 
17.26 Solution 2: The list of documents simi"
3659,479,"for many documents, so some precomputing can make sense. 
17.16 Iterative solution: Use an example and work backwards. You can easily find the optimal 
solution for the subarrays {rJ, {rn_1, rn}, {rn_2, ••• , rJ. How would you use
those to quickly find the optimal solution for { r n-3' ••• , r ""}?
1"
3660,426,"up to n elements? 
17.22 Create a mapping from a wildcard form (like b_ll) to all words in that form. Then, when 
you want to find all words that are one edit away from bill, you can look up _ill, 
b_ll, bi_l, and bil_ in the mapping. 
17.24 The sum ofjust Dw ill besum(A&B&C&D) - sum(A&B) - sum(A&C)"
3661,408,"sumB) / 2. The problem then reduces to looking for a pair of values with a particular 
difference. 
17.26 Solution 2: Try building a hash table from each word to the documents that contain this 
word. This will allow us to easily find all documents with some similarity to {13, 16, 21, 3}. 
16.5 How "
3662,493,"IV I Hints for Additional Review Problems 
#586. 
#587. 
#588. 
#589. 
#590. 
#591. 
#592. 
#593. 
#594. 
#595. 
#596. 
#597. 
#598. 
#599. 
#600. 
#601. 
17.7 If each name maps to a list of its alternate spellings, you might have to update a lot of 
lists when you set X and Y as synonyms. If Xis a "
3663,501,"Can we make this faster? 
17 .16 Iterative solution: If you take an appointment, you can't take the next appointment, but 
you can take anything after that. Therefore, optimal ( r i' ••• , r n) = max ( r i + 
optimal(r1+2, ••• , rJ, optimal(r1+1, ••• , rJ).You can solve this itera­
tively by working"
3664,475,"subproblems. 
17.19 Part 1: If you have to find the missing number in 0( 1) space and 0( N) time, then you 
can do a only constant number of passes through the array and can store only a few 
variables. 
17.9 Look at the list of all values for 3• * Sb * 7c, Observe that each value in the list will b"
3665,481,"right difference. This will probably look like an outer loop through A with an inner loop 
through B. For each value, compute the difference and compare it to what we're looking 
for. Can we be more specific here, though? Given a value in A and a target difference, do 
we know the exact value of the"
3666,463,"negative. We would never add a negative sequence to the beginning or end of another 
subsequence. 
17.24 
17.3 
16.24 
17.22 
16.22 
16.9 
17.1 
With precomputation, you should be able to get a runtime of O ( N4). Can you make this 
even faster? 
Try this recursively. Suppose you had an algorithm to"
3667,422,"Can we make this faster with a hash table? 
Your previous algorithm probably resembles a depth-first search. Can you make this 
faster? 
Option #3: Another thing to think about is whether you even need a grid to implement 
this. What information do you actually need in the problem? 
Subtraction: Wou"
3668,215,"help? Can you implement this using the add operator? 
Focus on just one of the steps above. If you ""forgot"" to carry the ones, what would the 
add operation look like? 
686 Cracking the Coding Interview, 6th Edition"
3669,460,"#602. 
#603. 
#604. 
#605. 
#606. 
#607. 
#608. 
#609. 
#610. 
#611. 
#612. 
#613. 
#614. 
#615. 
#616. 
IV I Hints for Additional Review Problems 
16.21 What the brute force really does is look for a value within B which equals a - target. 
How can you more quickly find this element? What approache"
3670,480,"document, you can go through and just compute the similarity to those documents 
using a simple algorithm. Can you make this faster? Specifically, can you compute the 
similarity directly from the hash table? 
17.1 O The majority element will not necessarily look like the majority element at first. "
3671,498,"the majority element will appear later in the array (in fact, many times later on in the 
array). It's not necessarily critical to continue checking a specific instance of an element 
for majority status once it's already looking ""unlikely:' 
17.7 lnstead,X,A, B,and C should map to the same instance"
3672,496,"F} to {X, A, B, C}). How else do we change the hash table?
16.21 We can use a hash table here. We can also try 
sorting. Both help us locate elements more 
quickly. 
17.16 Iterative solution: If you're careful about what data you really need, you should be able 
to solve this in O(n) time and 0(1) a"
3673,501,"together to convert the whole tree to a doubly linked list? 
17.19 Part 1: What if you added up all the values in the array? Could you then figure out the 
missing number? 
17.4 How long would it take you to figure out the least significant bit of the missing number? 
17.26 Solution 2: Imagine you a"
3674,462,"times when doing this lookup. What does that indicate? 
17.6 Rather than counting the number of twos in each number, think about digit by digit. 
That is, count the number of twos in the first digit (for each number), then the number 
of twos in the second digit (for each number), then the number of"
3675,444,"negative numbers? 
16.17 You can solve this in O(N) time and 0( 1) space. 
17.24 Suppose this was just a single array. How could we compute the subarray with the 
largest sum? See 16.17 for a solution to this. 
16.22 Option #3: All you actually need is some way of looking up if a cell is white or bl"
3676,501,"IV I Hints for Additional Review Problems 
#617. 
#618. 
#619. 
#620. 
#621. 
#622. 
#623. 
#624. 
#625. 
#626. 
#627. 
#628. 
#629. 
#630. 
#631. 
#632. 
#633. 
#634. 
#635. 
17.17 One solution is to insert every suffix of the larger string into the trie. For example, if the 
word is dogs, the suff"
3677,510,"the worst case, but in many cases. Why? Can you do something even faster than this? 
17.5 What if you just started from the beginning, counting the number of As and the number 
of Bs you've seen so far? (Try making a table of the array and the number of As and Bs 
thus far.) 
17.10 Note also that th"
3678,483,"ending at row r2, how could you most efficiently do this? (See the prior hint.) If I now 
wanted you find the maximum subarray from rl to ( r2+2), could you do this effi­
ciently? 
17.9 Since each number is 3, 5, or 7 times a previous value in the list, we could just check all 
possible values and p"
3679,424,"16.26 Multiplication and division are higher priority operations. In an expression like 3*4 + 
5*9/2 + 3, the multiplication and division parts need to be grouped together. 
17.14 If you picked an arbitrary element, how long would it take you to figure out the rank of 
this element (the number of el"
3680,498,"approach from part 1 will tell us the sum of a and b, but it won't actually tell us a and b. 
What other calculations could we do? 
16.22 
17.1 
17.21 
16.25 
16.18 
16.6 
17.11 
17.2 
16.21 
Option #3: You could consider keeping a hash set of all the white cells. How will you be 
able to print the "
3681,458,"What role does the tallest bar in the histogram play? 
What data structure would be most useful for the lookups? What data structure would 
be most useful to know and maintain the order of items? 
Start with a brute force approach. Can you try all possibilities for a and b? 
What if you sorted the a"
3682,419,"in O(A+B) time, where A and Bare the sizes of the two arrays. 
You could build this algorithm recursively by swapping the nth element for any of the 
elements before it. What would this look like iteratively? 
What if the sum of A is 11 and the sum of Bi s 8? Can there be a pair with the right diffe"
3683,510,"#636. 
#637. 
#638. 
#639. 
#640. 
#641. 
#642. 
#643. 
#644. 
#645. 
#646. 
#647. 
#648. 
#649. 
#650. 
IV I Hints for Additional Review Problems 
17.26 Solution 3: There's an alternative solution. Consider taking all of the words from all of the 
documents, throwing them into one giant list, and s"
3684,444,"to the result of rand?(). For example, if you were implementing rand3() with 
( rand2 () + rand2 ()) % 3, then the table would look like the below. Analyze this 
table. What can it tell you? 
17.8 
1st 
0 
0 
1 
1 
2nd 
0 
1 
0 
1 
Result 
0 
1 
1 
2 
This problem asks us to find the longest sequenc"
3685,491,"to increase? 
16.15 Try first creating an array with the frequency that each item occurs. 
17.21 Picture the tallest bar, and then the next tallest bar on the left and the next tallest bar on 
the right. The water will fill the area between those. Can you calculate that area? What 
do you do about t"
3686,483,"How do you make that more exact? 
17.1 You can do the add step with an XOR.
16.18 Observe that one of the substrings, either a or b, must start at the beginning of the 
string. That cuts down the number of possibilities. 
16.24 What if the array were sorted? 
17.18 Start with a brute force solution."
3687,506,"times it needs to return the end. There are multiple ways of solving this issue. Brainstorm 
some of them. 
17.14 If you picked an arbitrary element, you would, on average, wind up with an element 
around the 50th percentile mark (half the elements above it and half the elements 
below). What if you"
3688,488,"integer. 
17.19 Part 2: There are a lot of different calculations we could try. For example, we could 
multiply all the numbers, but that will only lead us to the product of a and b. 
17.10 Try this: Given an element, start checking if this is the start of a subarray for which it's 
the majority ele"
3689,428,"IV I Hints for Additional Review Problems 
#651. 
#652. 
#653. 
#654. 
#655. 
#656. 
#657. 
#658. 
#659. 
#660. 
#661. 
#662. 
#663. 
#664. 
#665. 
#666. 
17.21 You can calculate the area between the tallest bar overall and the tallest bar on the left 
by just iterating through the histogram and sub"
3690,507,"graph? 
17.18 One brute force solution is to take each starting position and move forward until you've 
found a subsequence which contains all the target characters. 
16.18 Don't forget to handle the possibility that the first character in the pattern is b. 
16.20 In the real world, we should know t"
3691,502,"cases like this? 
17.7 An alternative approach is to think of this as a graph. How would this work? 
17.13 You can think about the choices the recursive algorithm makes in one of two ways: (1) 
At each character, should I put a space here? (2) Where should I put the next space? You 
can solve both o"
3692,478,"any duplicates, since the longest sequence needs to strictly increase). What does this tell 
you about the original problem? 
17.21 You can handle the remainder of the graph by just repeating this process: find the tallest 
17.4 
bar and the second tallest bar, and subtract out the bars in between. "
3693,494,"bit, then the missing number's least significant bit must be a 1. Think about it: in any 
sequence of 0s and ls, you'd get a 0, then a 1, then a 0, then a 1, and so on. 
17.9 Rather than checking all values in the list for the next value (by multiplying each by 3, 
5, and 7), think about it this way"
3694,467,"17.21 How can you make the process of finding the next tallest bar on each side faster? 
16.18 Be careful with how you analyze the runtime. If you iterate through 0( n2) substrings 
and each one does an 0( n) string comparison, then the total runtime is O( n3). 
17.1 Now focus on the carrying. In wh"
3695,428,"to a separate ""process""to compute the result of this chunk. 
17.8 If you sort the values based on height, then this will tell you the ordering of the final pairs. 
The longest sequence must be in this relative order (but not necessarily containing all 
of the pairs). You now just need to find the lo"
3696,167,"as having an array of integers and trying to find the longest sequence you can build 
(without reordering those items). 
690 Cracking the Coding Interview, 6th Edition"
3697,503,"#667. 
#668. 
#669. 
#670. 
#671. 
#672. 
#673. 
#674. 
#675. 
#676. 
#677. 
#678. 
#679. 
#680. 
#681. 
IV I Hints for Additional Review Problems 
16.16 Consider the three subarrays: LEFT, MIDDLE, RIGHT. Focus on just this question: Can 
you sort middle such that the entire array becomes sorted? Ho"
3698,469,"probability, X th of the rows must map to 0, X th to l, and so on. Is this possible? 
1 7 .18 Another way of thinking about the brute force is that we take each starting index and 
find the next instance of each element in the target string. The maximum of all these 
next instances marks the end of "
3699,488,"16.6 Think about how you would merge two sorted arrays. 
17.5 When the above tables have equal values for the number of As and Bs, the entire 
subarray (starting from index 0) has an equal number of As and Bs. How could you use 
this table to find qualifying subarrays that don't start at index O? 
1"
3700,468,"and b? 
16.24 If we sorted the array, we could do repeated binary searches for the complement of 
a number. What if, instead, the array is given to us sorted? Could we then solve the 
problem in O(N) time and 0(1) space? 
16.19 If you were given the row and column of a water cell, how can you find a"
3701,497,"node. How then do we figure out the groups of synonyms? 
17.21 Can you do precomputation to compute the next tallest bar on each side? 
17.13 Will the recursive algorithm hit the same subproblems repeatedly? Can you optimize 
with a hash table? 
17.14 What if, when you picked an element, you swapped"
3702,435,"16.6 Imagine you had the two arrays sorted and you were walking through them. If the 
pointer in the first array points to 3 and the pointer in the second array points to 9, what 
effect will moving the second pointer have on the difference of the pair? 
17.12 To handle whether your recursive algori"
3703,425,"very well, though. The problem is that when you call convert (current. left), you 
want to get the end of left's linked list. This way you can join the end of the linked list 
to current. But, if current is someone else's right subtree, convert(current) 
needs to pass back the start of the linked li"
3704,279,"17.18 Consider the previously explained brute force solution. A bottleneck is repeatedly 
asking for the next instance of a particular character. Is there a way you can optimize 
this? You should be able to do this in O( 1) time. 
CrackingTheCodinglnterview.com \ 6th Edition 691"
3705,452,"IV I Hints for Additional Review Problems 
#682. 
#683. 
#684. 
#685. 
#686. 
#687. 
#688. 
#689. 
#690. 
#691. 
#692. 
#693. 
#694. 
#695. 
#696. 
#697. 
#698. 
#699. 
#700. 
17.8 
17.4 
Try a recursive approach that just evaluates all possibilities. 
Once you've identified that the least significa"
3706,491,"earlier part? 
17.23 Start with a brute force solution. Can you try the biggest possible square first? 
16.18 Suppose you decide on a specific value for the ""a"" part of a pattern. How many possibili­
ties are there for b? 
17.9 When you add x to the list of the first k values, you can add 3x, Sx, an"
3707,504,"you need to insert only 7x? You want to avoid seeing the same number twice. 
16.19 Try recursion to count the number of water cells. 
16.8 Consider dividing up a number into sequences of three digits. 
17.19 Part 2: We could do both. If we know that a + b = 87 and a * b = 962, then we 
can solve for"
3708,445,"a simpler calculation you can make? 
16.11 
17.18 
17.1 
17.21 
16.25 
17.23 
Consider building a diving board. What are the choices you make? 
Can you precompute the next instance of a particular character from each index? Try 
using a multi-dimensional array. 
The carry will happen when you are do"
3709,505,"have water on top of it. How much water will be on top of each bar? 
Both a hash table and a doubly linked list would be useful. Can you combine the two? 
The biggest possible square is NxN. So if you try that square first and it works, then 
you know that you've found the best square. Otherwise, yo"
3710,451,"16.23 It is not possible to divide Sk evenly by 7. Does this mean that you can't implement 
rand7 () with rands()? 
16.26 You can also maintain two stacks, one for the operators and one for the numbers. You 
push a number onto the stack every time you see it. What about the operators? When 
do you p"
3711,204,"at each element A[ 0] through A[ n -1 ], could you use that to find the longest sequence 
ending at element A [ n -1]? 
16.11 Consider a recursive solution. 
692 Cracking the Coding Interview, 6th Edition"
3712,506,"#701. 
#702. 
#703. 
#704. 
#705. 
#706. 
#707. 
#708. 
#709. 
#710. 
#711. 
#712. 
#713. 
#714. 
#715. 
#716. 
#717. 
#718. 
#719. 
IV I Hints for Additional Review Problems 
17.12 Many people get stuck at this point and aren't sure what to do. Sometimes they need 
the start of the linked list, and"
3713,454,"17.19 
16.20 
17.7 
17.23 
16.19 
16.7 
16.16 
Part 2: Try a sum of squares of the values. 
A trie might help us short-circuit. What if you stored the whole list of words in the trie? 
Each connected subgraph represents a group of synonyms. To find each group, we can 
do repeated breadth-first (or d"
3714,508,"breadth-first search or depth-first search on a graph works. 
When a > b, then a - b > 0. Can you get the sign bit of a - b? 
In order to be able to sort MIDDLE and have the whole array become sorted, you need 
MAX(LEFT) <= MIN(MIDDLE and RIGHT) and MAX(LEFT and MIDDLE) <=
MIN (RIGHT). 
17.20 What i"
3715,420,"17.1 You can use an AND operation to compute the carry. What do you do with it? 
17.5 Suppose,in this table,index ih as co unt(A, 0->i) = 3and count(B, 0->i) 
7. This means that there are four more Bs than As. If you find a later spot j with the same
difference(coun t(B, 0->j) - co unt(A, 0->j)),the"
3716,458,"17.23 Can you do preprocessing to optimize this solution? 
16.11 Once you have a recursive algorithm, think about the runtime. Can you make this faster? 
How? 
16.1 Let di ff be the difference between a and b.Can you use diff in some way?Then can 
you get rid of this temporary variable? 
17.19 Part "
3717,473,"16.18 Since the value of a determines the value of b (and vice versa) and either a or b must 
start at the beginning of the value, you should have only 0( n) possibilities for how to 
split up the pattern. 
17.12 You could return both the start and end of a linked list in multiple ways. You could 
r"
3718,346,"supports this (like Python), you could just return multiple values. You could solve the 
problem as a circular linked list, with the start's previous pointer pointing to the end 
(and then break the circular list in a wrapper method). Explore these solutions. Which 
one do you like most and why? 
Cr"
3719,502,"IV I Hints for Additional Review Problems 
#720. 
#721. 
#722. 
#723. 
#724. 
#725. 
#726. 
#727. 
#728. 
#729. 
#730. 
#731. 
#732. 
#733. 
#734. 
#735. 
#736. 
#737. 
#738. 
#739. 
16.23 You can implement rand7() with rands(), you just can't do it deterministically (such 
that you know it will def"
3720,489,"the square. 
16.11 Consider memoization to optimize the runtime. Think carefully about what exactly you 
cache. What is the runtime? The runtime is closely related to the max size of the table. 
16.19 You should have an algorithm that's O ( N2 ) on an NxN matrix. If your algorithm isn't, 
consider i"
3721,482,"might cause new values to carry. 
17.18 Once you have the precomputation solution figured out, think about how you can 
reduce the space complexity. You should be able to get it down to O(SB) time and 
O( B) space (where B is the size of the larger array and S is the size of the smaller array). 
16."
3722,492,"16.18 You should be able to have an O(n2 ) algorithm. 
16.7 Have you considered how to handle integer overflow in a - b? 
16.5 Each factor of 1 O in n ! means n ! is divisible by 5 and 2. 
16.15 For ease and clarity in implementation, you might want to use other methods and 
classes. 
17.18 Another "
3723,468,"Could you find the second? 
16.4 If you were designing this for an NxN board, how might your solution change? 
16.5 Can you count the number of factors of 5 and 2? Do you need to count both? 
17.21 Each bar will have water on top of it that matches the minimum of the tallest bar on the 
left and the"
3724,432,"17.23 When you're checking to see if a particular square is valid (all black borders), you check 
how many black pixels are above (or below) a coordinate and to the left (or right) of this 
coordinate. Can you precompute the number of black pixels above and to the left of a 
given cell? 
16.1 You co"
3725,271,"nation word? 
17.13 In real life, we would know that some paths will not lead to a word. For example, there 
are no words that start with hellothisism. Can we terminate early when going down 
a path that we know won't work? 
694 Cracking the Coding Interview, 6th Edition"
3726,469,"#740. 
#741. 
#742. 
#743. 
#744. 
#745. 
#746. 
#747. 
#748. 
#749. 
16.11 
17.18 
17.21 
17.17 
16.20 
16.5 
16.16 
16.11 
IV I Hints for Additional Review Problems 
There's an alternate, clever (and very fast) solution. You can actually do this in linear time 
without recursion. How? 
Consider us"
3727,463,"help you solve the problem? What is the runtime? 
With preprocessing, we can actually get the lookup time down to O( 1). 
Have you considered that 25 actually accounts for two factors of 5? 
You should be able to solve this in O(N) time. 
Think about it this way. You are picking K planks and there a"
3728,215,"you just iterate through all possible choices? 
17.25 Can you use a trie to terminate early when a rectangle looks invalid? 
17.13 For early termination, try a trie. 
CrackingTheCodinglnterview.com I 6th Edition 695"
3729,474,"XIV 
About the Author 
Gayle Laakmann McDowell has a strong background in soft­
ware development with extensive experience on both sides of 
the hiring table. 
She has worked for Microsoft, Apple, and Google as a software 
engineer. She spent three years at Google, where she was one 
of the top inte"
3730,500,"committee, and reviewed many more resumes. 
As a candidate, she interviewed with-and received offers from­
twelve tech companies, including Microsoft, Google, Amazon, 
IBM, and Apple. 
Gayle founded CareerCup to enable candidates to perform at 
their best during these challenging interviews. CareerC"
3731,450,"other two books: 
Cracking the Tech Career: Insider Advice on Landing a Job at Google, Microsoft, Am,le, or Any Top Tech 
Company provides a broader look at the interview process for major tech companies. It offers insight 
into how anyone, from college freshmen to marketing professionals, can posit"
3732,502,"management roles at startups and big tech companies. It offers strategies to break into these roles and 
teaches job seekers how to prepare for PM interviews. 
Through her role with CareerCup, she consults with tech companies on their hiring process, leads technical 
interview training workshops, an"
3733,205,"and an MBA from the Wharton School. 
She lives in Palo Alto, California, with her husband, two sons, dog, and computer science books. She still 
codes daily. 
696 Cracking the Coding Interview, 6th Edition"
3734,470,"Amazon.corn's #1 Best-Selling Interview Book 
I am not a recruiter. I am a software engineer. And as 
such. I know what it's like to be asked to whip up brilliant 
algorithms on the spot and then write flawless code on a 
whiteboard. I've been through this-as a candidate and 
as an interviewer. 
Cra"
3735,486,"know and enabling you to perform at your very best. I've 
coached and interviewed hundreds of software 
engineers. The result is this book. 
Learn how to uncover the hints and hidden details in a 
question, discover how to break down a problem into 
manageable chunks. develop techniques to unstick 
"
3736,498,"These interview questions are real: they are not pulled 
out of computer science textbooks. They reflect what's 
truly being asked at the top companies. so that you can 
be as prepared as possible. 
• 189 programming interview questions, ranging from
the basics to the trickiest algorithm problems.
•"
3737,498,". just
like what you would get in a real interview.
• Five proven strategies to tackle 
algorithm questions,
so that you can solve questions you haven't seen.
• Extensive coverage of essential topics. such as big 0
time. data structures . and core algorithms.
•
A ""behind the scenes· look at how top "
3738,491,"• For interviewers and companies: details on what
makes a good interview question and hiring process.
I 
Gayle Laakmann McDowell is 
the founder and CEO of 
CareerCup and the author of 
Cracking the PM Interview and 
Cracking the Tech Career. 
Gayle has a strong background in 
software development. "
3739,368,"and evaluated thousands of 
hiring 
packets as part of the 
hiring committee. She holds a 
B.S.E. and M.S.E. in computer 
science from the University of 
Pennsylvania and an MBA from 
the Wharton School. 
She now consults with tech 
companies to improve their 
hiring process and with startups 
to pr"
